From 535e4373bae9cd682fff1b498b4c0e27cb13034c Mon Sep 17 00:00:00 2001
From: Mooneer Salem <mooneer@gmail.com>
Date: Wed, 27 Oct 2021 17:59:57 -0700
Subject: [PATCH 32/53] Reverts all changes past 2ab504b.

Individual optimizations will be cherry-picked and included in subsequent PRs.
---
 src/codec2.c        |   4 --
 src/filter.c        |  27 -----------
 src/fmfsk.c         |  10 ++--
 src/fsk.c           |  15 +++---
 src/mbest.c         |  68 ++++++--------------------
 src/mbest.h         |   1 -
 src/modem_stats.c   |   4 +-
 src/newamp1.c       |  10 ++--
 src/nlp.c           |  38 ++-------------
 src/ofdm.c          | 113 +-------------------------------------------
 src/ofdm_internal.h |   8 ----
 src/phase.c         |  12 ++---
 src/sine.c          |  12 ++---
 src/sine.h          |   4 --
 14 files changed, 46 insertions(+), 280 deletions(-)

diff --git a/src/codec2.c b/src/codec2.c
index 62feb255..f3682519 100644
--- a/src/codec2.c
+++ b/src/codec2.c
@@ -2088,11 +2088,7 @@ void analyse_one_frame(struct CODEC2 *c2, MODEL *model, short speech[])
     for(i=0; i<n_samp; i++)
       c2->Sn[i+m_pitch-n_samp] = speech[i];
 
-#if defined(STM32F40_41xxx)
     dft_speech(&c2->c2const, c2->fft_fwd_cfg, Sw, c2->Sn, c2->w);
-#else
-    dft_speech(&c2->c2const, c2->fftr_fwd_cfg, Sw, c2->Sn, c2->w);
-#endif // STM32F40_41xxx
 
     /* Estimate pitch */
     nlp(c2->nlp, c2->Sn, n_samp, &pitch, Sw, c2->W, &c2->prev_f0_enc);
diff --git a/src/filter.c b/src/filter.c
index fa5f4af5..ccb58cde 100644
--- a/src/filter.c
+++ b/src/filter.c
@@ -20,10 +20,6 @@
 #include <math.h>
 #include <complex.h>
 
-#ifdef FDV_ARM_MATH
-#include "arm_math.h"
-#endif // FDV_ARM_MATH
-
 #include "filter.h"
 #include "filter_coef.h"
 #include "debug_alloc.h"
@@ -258,28 +254,6 @@ void quisk_cfTune(struct quisk_cfFilter * filter, float freq) {
 \*---------------------------------------------------------------------------*/
 
 void quisk_ccfFilter(complex float * inSamples, complex float * outSamples, int count, struct quisk_cfFilter * filter) {
-#if defined(FDV_ARM_MATH)
-    complex float ptSample[filter->nTaps + count - 1];
-    complex float *ptSamplePtr = &ptSample[0];
-    complex float ptCoeff[filter->nTaps];
-    memcpy(&ptSample, &filter->cSamples[1], (filter->nTaps - 1) * sizeof(complex float));
-    memcpy(&ptSample[filter->nTaps - 1], inSamples, count * sizeof(complex float));
-
-    // Reverse coefficients since we're going to go forwards over samples.
-    for (int i = 0, k = filter->nTaps - 1; i < filter->nTaps; i++, k--)
-    {
-        ptCoeff[i] = filter->cpxCoefs[k];
-    }
-
-    for (int i = 0; i < count; i++, ptSamplePtr++)
-    {
-        complex float accum = 0;
-        arm_cmplx_dot_prod_f32((float32_t*)ptSamplePtr, (float32_t*)&ptCoeff, filter->nTaps, (float32_t*)&accum, (float32_t*)&accum + 1);
-        outSamples[i] = accum;
-    }
-
-    memcpy((float32_t*)filter->cSamples, (float32_t*)&ptSample[count - 1 - filter->nTaps], filter->nTaps * sizeof(complex float));
-#else
     int i, k;
     complex float * ptSample;
     complex float * ptCoef;
@@ -303,6 +277,5 @@ void quisk_ccfFilter(complex float * inSamples, complex float * outSamples, int
         if (++filter->ptcSamp >= filter->cSamples + filter->nTaps)
             filter->ptcSamp = filter->cSamples;
     }
-#endif
 }
 
diff --git a/src/fmfsk.c b/src/fmfsk.c
index 86c526b6..eefff834 100644
--- a/src/fmfsk.c
+++ b/src/fmfsk.c
@@ -168,7 +168,7 @@ void fmfsk_mod(struct FMFSK *fmfsk, float fmfsk_out[],uint8_t bits_in[]){
  * float fsk_in[] - nin samples of modualted FMFSK from an FM radio
  */
 void fmfsk_demod(struct FMFSK *fmfsk, uint8_t rx_bits[],float fmfsk_in[]){
-    int i,j;
+    int i,j,k;
     int Ts          = fmfsk->Ts;
     int Fs          = fmfsk->Fs;
     int Rs          = fmfsk->Rs;
@@ -187,6 +187,9 @@ void fmfsk_demod(struct FMFSK *fmfsk, uint8_t rx_bits[],float fmfsk_in[]){
     int next_nin;
     float apeven,apodd;     /* Approx. prob of even or odd stream being correct */
     float currv,mdiff,lastv;
+    int neyesamp;
+    int neyeoffset;
+    float eye_max;
     uint8_t mbit;
     float var_signal = 0, var_noise = 0, lastFabsV;
     
@@ -340,11 +343,6 @@ void fmfsk_demod(struct FMFSK *fmfsk, uint8_t rx_bits[],float fmfsk_in[]){
     fmfsk->stats->snr_est = fmfsk->snr_mean;
 
 #ifndef __EMBEDDED__
-    int neyesamp;
-    int neyeoffset;
-    float eye_max;
-    int k;
-
     /* Collect an eye diagram */
     /* Take a sample for the eye diagrams */
     neyesamp = fmfsk->stats->neyesamp = Ts*4;
diff --git a/src/fsk.c b/src/fsk.c
index b04dd6d6..6a48b449 100644
--- a/src/fsk.c
+++ b/src/fsk.c
@@ -640,7 +640,8 @@ void fsk_demod_core(struct FSK *fsk, uint8_t rx_bits[], float rx_filt[], COMP fs
     float rx_timing,norm_rx_timing,old_norm_rx_timing,d_norm_rx_timing,appm;
 
     float fc_avg,fc_tx;
-    float meanebno,stdebno;
+    float meanebno,stdebno,eye_max;
+    int neyesamp,neyeoffset;
     
     #ifdef MODEMPROBE_ENABLE
     #define NMP_NAME 26
@@ -878,8 +879,6 @@ void fsk_demod_core(struct FSK *fsk, uint8_t rx_bits[], float rx_filt[], COMP fs
        trace.  So lets output a decimated version.  We use 2P
        as we want two symbols worth of samples in trace  */
 #ifndef __EMBEDDED__
-    float eye_max;
-    int neyesamp,neyeoffset;
     int neyesamp_dec = ceil(((float)P*2)/MODEM_STATS_EYE_IND_MAX);
     neyesamp = (P*2)/neyesamp_dec;
     assert(neyesamp <= MODEM_STATS_EYE_IND_MAX);
@@ -958,6 +957,11 @@ void fsk_demod_sd(struct FSK *fsk, float rx_filt[], COMP fsk_in[]){
 
 /* make sure stats have known values in case monitoring process reads stats before they are set */
 static void stats_init(struct FSK *fsk) {
+    /* Take a sample for the eye diagrams */
+    int i,j,m;
+    int P = fsk->P;
+    int M = fsk->mode;
+
     /* due to oversample rate P, we have too many samples for eye
        trace.  So lets output a decimated version */
 
@@ -965,11 +969,6 @@ static void stats_init(struct FSK *fsk) {
     
     /* TODO: refactor eye tracing code here and in fsk_demod */
 #ifndef __EMBEDDED__    
-    /* Take a sample for the eye diagrams */
-    int i,j,m;
-    int P = fsk->P;
-    int M = fsk->mode;
-
     int neyesamp_dec = ceil(((float)P*2)/MODEM_STATS_EYE_IND_MAX);
     int neyesamp = (P*2)/neyesamp_dec;
     assert(neyesamp <= MODEM_STATS_EYE_IND_MAX);
diff --git a/src/mbest.c b/src/mbest.c
index 5d0d9a0a..ae786e40 100644
--- a/src/mbest.c
+++ b/src/mbest.c
@@ -75,7 +75,7 @@ void mbest_destroy(struct MBEST *mbest) {
 \*---------------------------------------------------------------------------*/
 
 void mbest_insert(struct MBEST *mbest, int index[], float error) {
-    int                i, found;
+    int                i, j, found;
     struct MBEST_LIST *list    = mbest->list;
     int                entries = mbest->entries;
 
@@ -83,8 +83,10 @@ void mbest_insert(struct MBEST *mbest, int index[], float error) {
     for(i=0; i<entries && !found; i++)
 	if (error < list[i].error) {
 	    found = 1;
-            memmove(&list[i+1], &list[i], sizeof(struct MBEST_LIST) * (entries - i - 1));
-            memcpy(&list[i].index[0], &index[0], sizeof(int) * MBEST_STAGES);
+	    for(j=entries-1; j>i; j--)
+		list[j] = list[j-1];
+	    for(j=0; j<MBEST_STAGES; j++)
+		list[i].index[j] = index[j];
 	    list[i].error = error;
 	}
 }
@@ -122,57 +124,17 @@ void mbest_search(
 )
 {
    float   e;
-   
-   for(int j = 0; j < m; j++) {
-        int i;
-
-        e = 0.0;
-        for(int i = 0; i < k; i++) {
-            float diff = (*cb++) - vec[i];
-            float diff2 = diff * diff;
-            float w2 = w[i] * w[i];
-            e += diff2 * w2;
-        }
-
-        index[0] = j;
-        if (e < mbest->list[mbest->entries - 1].error)
-            mbest_insert(mbest, index, e);
-   }
-}
+   int     i,j;
+   float   diff;
 
-/*---------------------------------------------------------------------------*\
-
-  mbest_search_equalweight
-
-  Searches vec[] to a codebbook of vectors, and maintains a list of the mbest
-  closest matches. Similar to mbest_search() but with w[] = 1.
-
-\*---------------------------------------------------------------------------*/
-
-void mbest_search_equalweight(
-		  const float  *cb,     /* VQ codebook to search         */
-		  float         vec[],  /* target vector                 */
-		  int           k,      /* dimension of vector           */
-		  int           m,      /* number on entries in codebook */
-		  struct MBEST *mbest,  /* list of closest matches       */
-		  int           index[] /* indexes that lead us here     */
-)
-{
-   float   e;
-   
-   for(int j = 0; j < m; j++) {
-        int i;
-
-        e = 0.0;
-        for(int i = 0; i < k; i++) {
-            float diff = (*cb++) - vec[i];
-            float diff2 = diff * diff;
-            e += diff2;
-        }
-
-        index[0] = j;
-        if (e < mbest->list[mbest->entries - 1].error)
-            mbest_insert(mbest, index, e);
+   for(j=0; j<m; j++) {
+	e = 0.0;
+	for(i=0; i<k; i++) {
+	    diff = cb[j*k+i]-vec[i];
+	    e += diff*w[i]*diff*w[i];
+	}
+	index[0] = j;
+	mbest_insert(mbest, index, e);
    }
 }
 
diff --git a/src/mbest.h b/src/mbest.h
index 7565a3f3..43c322f3 100644
--- a/src/mbest.h
+++ b/src/mbest.h
@@ -46,7 +46,6 @@ struct MBEST *mbest_create(int entries);
 void mbest_destroy(struct MBEST *mbest);
 void mbest_insert(struct MBEST *mbest, int index[], float error);
 void mbest_search(const float  *cb, float vec[], float w[], int k, int m, struct MBEST *mbest, int index[]);
-void mbest_search_equalweight(const float  *cb, float vec[], int k, int m, struct MBEST *mbest, int index[]);
 void mbest_search450(const float  *cb, float vec[], float w[], int k,int shorterK, int m, struct MBEST *mbest, int index[]);
 
 void mbest_print(char title[], struct MBEST *mbest);
diff --git a/src/modem_stats.c b/src/modem_stats.c
index f4bc1a01..76214f3c 100644
--- a/src/modem_stats.c
+++ b/src/modem_stats.c
@@ -33,6 +33,8 @@
 
 void modem_stats_open(struct MODEM_STATS *f)
 {
+    int i;
+
     /* zero out all the stats */
 
     memset(f, 0, sizeof(struct MODEM_STATS));
@@ -40,7 +42,7 @@ void modem_stats_open(struct MODEM_STATS *f)
     /* init the FFT */
 
 #ifndef __EMBEDDED__
-    for(int i=0; i<2*MODEM_STATS_NSPEC; i++)
+    for(i=0; i<2*MODEM_STATS_NSPEC; i++)
 	f->fft_buf[i] = 0.0;
     f->fft_cfg = (void*)kiss_fft_alloc (2*MODEM_STATS_NSPEC, 0, NULL, NULL);
     assert(f->fft_cfg != NULL);
diff --git a/src/newamp1.c b/src/newamp1.c
index 006f84fd..e22c224c 100644
--- a/src/newamp1.c
+++ b/src/newamp1.c
@@ -166,6 +166,7 @@ float rate_K_mbest_encode(int *indexes, float *x, float *xq, int ndim, int mbest
   const float *codebook2 = newamp1vq_cb[1].cb;
   struct MBEST *mbest_stage1, *mbest_stage2;
   float target[ndim];
+  float w[ndim];
   int   index[MBEST_STAGES];
   float mse, tmp;
 
@@ -173,7 +174,10 @@ float rate_K_mbest_encode(int *indexes, float *x, float *xq, int ndim, int mbest
 
   assert(ndim == newamp1vq_cb[0].k);
 
-  /* note: using equal weights, could be argued mel freq axis gives freq dep weighting */
+  /* equal weights, could be argued mel freq axis gives freq dep weighting */
+
+  for(i=0; i<ndim; i++)
+      w[i] = 1.0;
 
   mbest_stage1 = mbest_create(mbest_entries);
   mbest_stage2 = mbest_create(mbest_entries);
@@ -182,7 +186,7 @@ float rate_K_mbest_encode(int *indexes, float *x, float *xq, int ndim, int mbest
 
   /* Stage 1 */
 
-  mbest_search_equalweight(codebook1, x, ndim, newamp1vq_cb[0].m, mbest_stage1, index);
+  mbest_search(codebook1, x, w, ndim, newamp1vq_cb[0].m, mbest_stage1, index);
 
   /* Stage 2 */
 
@@ -190,7 +194,7 @@ float rate_K_mbest_encode(int *indexes, float *x, float *xq, int ndim, int mbest
       index[1] = n1 = mbest_stage1->list[j].index[0];
       for(i=0; i<ndim; i++)
 	  target[i] = x[i] - codebook1[ndim*n1+i];
-      mbest_search_equalweight(codebook2, target, ndim, newamp1vq_cb[1].m, mbest_stage2, index);
+      mbest_search(codebook2, target, w, ndim, newamp1vq_cb[1].m, mbest_stage2, index);
   }
 
   n1 = mbest_stage2->list[0].index[1];
diff --git a/src/nlp.c b/src/nlp.c
index d3b11fae..036f6be2 100644
--- a/src/nlp.c
+++ b/src/nlp.c
@@ -126,11 +126,7 @@ typedef struct {
     float         sq[PMAX_M];	     /* squared speech samples       */
     float         mem_x,mem_y;       /* memory for notch filter      */
     float         mem_fir[NLP_NTAP]; /* decimation FIR filter memory */
-#if defined(STM32F40_41xxx)
     codec2_fft_cfg  fft_cfg;         /* kiss FFT config              */
-#else
-    codec2_fftr_cfg fft_cfg;
-#endif // defined(STM32F40_41xxx)
     float        *Sn16k;	     /* Fs=16kHz input speech vector */
     FILE         *f;
 } NLP;
@@ -194,11 +190,7 @@ void *nlp_create(C2CONST *c2const)
     for(i=0; i<NLP_NTAP; i++)
 	nlp->mem_fir[i] = 0.0;
 
-#if defined(STM32F40_41xxx)
     nlp->fft_cfg = codec2_fft_alloc (PE_FFT_SIZE, 0, NULL, NULL);
-#else
-    nlp->fft_cfg = codec2_fftr_alloc (PE_FFT_SIZE, 0, NULL, NULL);
-#endif // defined(STM32F40_41xxx)
     assert(nlp->fft_cfg != NULL);
 
     return (void*)nlp;
@@ -218,11 +210,7 @@ void nlp_destroy(void *nlp_state)
     assert(nlp_state != NULL);
     nlp = (NLP*)nlp_state;
 
-#if defined(STM32F40_41xxx)
     codec2_fft_free(nlp->fft_cfg);
-#else
-    codec2_fftr_free(nlp->fft_cfg);
-#endif // defined(STM32F40_41xxx)
     if (nlp->Fs == 16000) {
         free(nlp->Sn16k);
     }
@@ -363,35 +351,15 @@ float nlp(
     #ifdef DUMP
     dump_dec(Fw);
     #endif
-    
-#if defined(STM32F40_41xxx)
+
     // FIXME: check if this can be converted to a real fft
     // since all imag inputs are 0
     codec2_fft_inplace(nlp->fft_cfg, Fw);
     PROFILE_SAMPLE_AND_LOG(fft, window, "      fft");
 
     for(i=0; i<PE_FFT_SIZE; i++)
-	    Fw[i].real = Fw[i].real*Fw[i].real + Fw[i].imag*Fw[i].imag;
-#else
-    float   Fw_input[PE_FFT_SIZE];
-    for (i = 0; i < PE_FFT_SIZE; i++)
-    {
-        Fw_input[i] = Fw[i].real;
-    }
-    codec2_fftr(nlp->fft_cfg, &Fw_input[0], &Fw[0]);
-    PROFILE_SAMPLE_AND_LOG(fft, window, "      fft");
-    
-    for(i=0; i<PE_FFT_SIZE/2; i++)
-    {
-	    Fw[i].real = Fw[i].real*Fw[i].real + Fw[i].imag*Fw[i].imag;
-        
-        // Set Fw[PE_FFT_SIZE - i - 1] to the same as Fw[i] due to the real FFT's symmetry
-        // (and to avoid having to change anything else further down).
-        Fw[PE_FFT_SIZE - i - 1].real = Fw[i].real;
-    }
-    
-#endif // defined(STM32F40_41xxx)
-    
+	Fw[i].real = Fw[i].real*Fw[i].real + Fw[i].imag*Fw[i].imag;
+
     PROFILE_SAMPLE_AND_LOG(magsq, fft, "      mag sq");
     #ifdef DUMP
     dump_sq(m, nlp->sq);
diff --git a/src/ofdm.c b/src/ofdm.c
index 49f07ba2..a6a404e5 100644
--- a/src/ofdm.c
+++ b/src/ofdm.c
@@ -401,36 +401,6 @@ struct OFDM *ofdm_create(const struct OFDM_CONFIG *config) {
         }
     }
 
-#ifndef STM32F40_41xxx   
-    // Precalculate "c" for use in dft() and idft().
-    ofdm->tx_c = (complex float*)calloc(ofdm->m * (ofdm->nc + 2), sizeof(complex float));
-    ofdm->rx_c = (complex float*)calloc(ofdm->m * (ofdm->nc + 2), sizeof(complex float));
-    assert(ofdm->tx_c != NULL && ofdm->rx_c != NULL);
-
-    complex float* c_ptr = ofdm->tx_c;
-    for (int row = 1; row < ofdm->m; row++) {
-        complex float c = cmplx(ofdm->tx_nlower * ofdm->doc * row);
-        complex float delta = cmplx(ofdm->doc * row);
-
-        for (int col = 0; col < (ofdm->nc + 2); col++) {
-            *c_ptr++ = c;
-            c *= delta;
-        }
-    }
-
-    c_ptr = ofdm->rx_c;
-    for (int col = 0; col < (ofdm->nc + 2); col++) {
-        float tval = (ofdm->rx_nlower + col) * ofdm->doc;
-        complex float c = cmplxconj(tval);
-        complex float delta = c;
-
-        for (int row = 1; row < ofdm->m; row++) {
-            *c_ptr++ = c;
-            c *= delta;
-        }
-    }
-#endif // STM32F40_41xxx
-
     /* default settings of options and states */
 
     ofdm->verbose = 0;
@@ -559,7 +529,7 @@ struct OFDM *ofdm_create(const struct OFDM_CONFIG *config) {
         ofdm_generate_preamble(ofdm, ofdm->tx_postamble, 3);
     }
     ofdm->postambledetectoren = !strcmp(ofdm->data_mode,"burst");
-
+    
     return ofdm; /* Success */
 }
 
@@ -594,11 +564,6 @@ static void deallocate_tx_bpf(struct OFDM *ofdm) {
 void ofdm_destroy(struct OFDM *ofdm) {
     int i;
 
-#ifndef STM32F40_41xxx   
-    free(ofdm->tx_c);
-    free(ofdm->rx_c);
-#endif // STM32F40_41xxx
-
     if (strlen(ofdm->data_mode)) {
         free(ofdm->tx_preamble);
         free(ofdm->tx_postamble);
@@ -641,25 +606,15 @@ static void idft(struct OFDM *ofdm, complex float *result, complex float *vector
 
     result[0] *= ofdm->inv_m;
 
-#ifndef STM32F40_41xxx
-    complex float* c_ptr = ofdm->tx_c;
-#endif // STM32F40_41xxx
-
     for (row = 1; row < ofdm->m; row++) {
-#ifdef STM32F40_41xxx
         complex float c = cmplx(ofdm->tx_nlower * ofdm->doc *row);
         complex float delta = cmplx(ofdm->doc * row);
-#endif // STM32F40_41xxx
 
         result[row] = 0.0f;
 
         for (col = 0; col < (ofdm->nc + 2); col++) {
-#ifdef STM32F40_41xxx
             result[row] += (vector[col] * c);
             c *= delta;
-#else
-            result[row] += vector[col] * (*c_ptr++);
-#endif // STM32F40_41xxx
         }
 
         result[row] *= ofdm->inv_m;
@@ -678,24 +633,14 @@ static void dft(struct OFDM *ofdm, complex float *result, complex float *vector)
         result[col] = vector[0];                 // conj(cexp(j0)) == 1
     }
 
-#ifndef STM32F40_41xxx
-    complex float* c_ptr = ofdm->rx_c;
-#endif // STM32F40_41xxx
-
     for (col = 0; col < (ofdm->nc + 2); col++) {
-#ifdef STM32F40_41xxx
         float tval = (ofdm->rx_nlower + col) * ofdm->doc;
         complex float c = cmplxconj(tval);
         complex float delta = c;
-#endif // STM32F40_41xxx
 
         for (row = 1; row < ofdm->m; row++) {
-#ifdef STM32F40_41xxx
             result[col] += (vector[row] * c);
             c *= delta;
-#else
-            result[col] += vector[row] * (*c_ptr++);
-#endif // STM32F40_41xxx
         }
     }
 }
@@ -1425,16 +1370,6 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
      */
     float woff_est = TAU * ofdm->foff_est_hz / ofdm->fs;
 
-#ifndef STM32F40_41xxx   
-    // Precalculate cmplxconj() of X*woff_est as we use it several
-    // times in this function.
-    complex float woff_est_conj[ofdm->nrxbuf];
-    for (int i = 0; i < ofdm->nrxbuf; i++)
-    {
-        woff_est_conj[i] = cmplxconj(i*woff_est);
-    }
-#endif // STM32F40_41xxx
-
     /* update timing estimate ---------------------------------------------- */
 
     if (ofdm->timing_en == true) {
@@ -1450,11 +1385,7 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
          * using a conjugate multiply
          */
         for (j = 0, i = st; i < en; j++, i++) {
-#ifndef STM32F40_41xxx   
-            work[j] = ofdm->rxbuf[i] * woff_est_conj[i];
-#else
             work[j] = ofdm->rxbuf[i] * cmplxconj(woff_est * i);
-#endif // STM32F40_41xxx
         }
 
         int ft_est = est_timing(ofdm, work, (en - st), 0.0f, &ofdm->timing_mx, &ofdm->timing_valid, 1);
@@ -1527,11 +1458,7 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
     /* down-convert at current timing instant------------------------------- */
 
     for (k = 0, j = st; j < en; k++, j++) {
-#ifndef STM32F40_41xxx   
-        work[k] = ofdm->rxbuf[j] * woff_est_conj[j];
-#else
         work[k] = ofdm->rxbuf[j] * cmplxconj(woff_est * j);
-#endif // STM32F40_41xxx
     }
 
     /*
@@ -1567,11 +1494,7 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
         /* down-convert at current timing instant---------------------------------- */
 
         for (k = 0, j = st; j < en; k++, j++) {
-#ifndef STM32F40_41xxx   
-            work[k] = ofdm->rxbuf[j] * woff_est_conj[j];
-#else
             work[k] = ofdm->rxbuf[j] * cmplxconj(woff_est * j);
-#endif // STM32F40_41xxx
         }
 
         /*
@@ -1616,11 +1539,7 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
     /* down-convert at current timing instant------------------------------- */
 
     for (k = 0, j = st; j < en; k++, j++) {
-#ifndef STM32F40_41xxx   
-        work[k] = ofdm->rxbuf[j] * woff_est_conj[j];
-#else
         work[k] = ofdm->rxbuf[j] * cmplxconj(woff_est * j);
-#endif // STM32F40_41xxx
     }
 
     /*
@@ -1677,15 +1596,6 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
         aamp_est_pilot[i] = 0.0f;
     }
 
-#ifndef STM32F40_41xxx   
-    // Precompute pilot conjugates as they're repeatedly used below.
-    complex float pilot_conjf[ofdm->nc + 2];
-    for (i = 0; i < (ofdm->nc + 2); i++)
-    {
-        pilot_conjf[i] = conjf(ofdm->pilots[i]);
-    }
-#endif // STM32F40_41xxx
-
     for (i = 1; i < (ofdm->nc + 1); i++) { /* ignore first and last carrier for count */
         if (ofdm->phase_est_bandwidth == low_bw) {
             complex float symbol[3];
@@ -1698,21 +1608,13 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
              * Then average the phase surrounding each of the data symbols.
              */
             for (k = 0, j = (i - 1); k < 3; k++, j++) {
-#ifndef STM32F40_41xxx   
-                symbol[k] = ofdm->rx_sym[1][j] * pilot_conjf[j]; /* this pilot conjugate */
-#else
                 symbol[k] = ofdm->rx_sym[1][j] * conjf(ofdm->pilots[j]); /* this pilot conjugate */
-#endif // STM32F40_41xxx
             }
 
             aphase_est_pilot_rect = vector_sum(symbol, 3);
 
             for (k = 0, j = (i - 1); k < 3; k++, j++) {
-#ifndef STM32F40_41xxx   
-                symbol[k] = ofdm->rx_sym[ofdm->ns + 1][j] * pilot_conjf[j]; /* next pilot conjugate */
-#else
                 symbol[k] = ofdm->rx_sym[ofdm->ns + 1][j] * conjf(ofdm->pilots[j]); /* next pilot conjugate */
-#endif // STM32F40_41xxx
             }
 
             aphase_est_pilot_rect += vector_sum(symbol, 3);
@@ -1720,21 +1622,13 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
             /* use pilots in past and future */
 
             for (k = 0, j = (i - 1); k < 3; k++, j++) {
-#ifndef STM32F40_41xxx   
-                symbol[k] = ofdm->rx_sym[0][j] * pilot_conjf[j]; /* previous pilot */
-#else
                 symbol[k] = ofdm->rx_sym[0][j] * conjf(ofdm->pilots[j]); /* previous pilot */
-#endif // STM32F40_41xxx
             }
 
             aphase_est_pilot_rect += vector_sum(symbol, 3);
 
             for (k = 0, j = (i - 1); k < 3; k++, j++) {
-#ifndef STM32F40_41xxx   
-                symbol[k] = ofdm->rx_sym[ofdm->ns + 2][j] * pilot_conjf[j]; /* future pilot */
-#else
                 symbol[k] = ofdm->rx_sym[ofdm->ns + 2][j] * conjf(ofdm->pilots[j]); /* future pilot */
-#endif // STM32F40_41xxx
             }
 
             aphase_est_pilot_rect += vector_sum(symbol, 3);
@@ -1753,13 +1647,8 @@ static void ofdm_demod_core(struct OFDM *ofdm, int *rx_bits) {
              *
              * As less pilots are averaged, low SNR performance will be poorer
              */
-#ifndef STM32F40_41xxx   
-            aphase_est_pilot_rect = ofdm->rx_sym[1][i] * pilot_conjf[i];             /* "this" pilot conjugate */
-            aphase_est_pilot_rect += ofdm->rx_sym[ofdm->ns + 1][i] * pilot_conjf[i]; /* "next" pilot conjugate */
-#else
             aphase_est_pilot_rect = ofdm->rx_sym[1][i] * conjf(ofdm->pilots[i]);             /* "this" pilot conjugate */
             aphase_est_pilot_rect += ofdm->rx_sym[ofdm->ns + 1][i] * conjf(ofdm->pilots[i]); /* "next" pilot conjugate */
-#endif // STM32F40_41xxx
 
             /* we estimate over 2 pilots */
             aphase_est_pilot_rect /= 2.0f;
diff --git a/src/ofdm_internal.h b/src/ofdm_internal.h
index 8686ccd5..0b54a33b 100644
--- a/src/ofdm_internal.h
+++ b/src/ofdm_internal.h
@@ -236,14 +236,6 @@ struct OFDM {
     
     char *codename;
     char *state_machine;
-
-#ifndef STM32F40_41xxx
-    // On non-SM1000 platforms, we precompute c for dft and idft to make it easier
-    // to use SIMD instructions to optimize those functions. This isn't done on SM1000
-    // due to memory constraints. Each is (ofdm->m * (ofdm->nc + 2)) in size.
-    complex float* tx_c;
-    complex float* rx_c;
-#endif // STM32F40_41xxx
 };
 
 /* Prototypes */
diff --git a/src/phase.c b/src/phase.c
index ad78b434..e486613d 100644
--- a/src/phase.c
+++ b/src/phase.c
@@ -251,18 +251,12 @@ void mag_to_phase(float phase[],             /* Nfft/2+1 output phase samples in
         Sdb[i].imag = Sdb[Nfft-i].imag = 0.0;
     }
 
-    /* Division takes far more cycles than multiplication on some
-       architectures (e.g. ARM), so we multiply by 1/Nfft instead. */
-    float Nfft_float = 1.0/((float)Nfft);
-    float* c_ptr = (float*)&c[0];
-    int numCFloats = Nfft*2;
-
     /* compute real cepstrum from log magnitude spectrum */
 
     codec2_fft(fft_inv_cfg, Sdb, c);
-    for(i=0; i<numCFloats; i++) {
-        *c_ptr *= Nfft_float;
-        c_ptr++;
+    for(i=0; i<Nfft; i++) {
+        c[i].real /= (float)Nfft;
+        c[i].imag /= (float)Nfft;
     }
 
     /* Fold cepstrum to reflect non-min-phase zeros inside unit circle */
diff --git a/src/sine.c b/src/sine.c
index 4c3c5659..750e2628 100644
--- a/src/sine.c
+++ b/src/sine.c
@@ -231,7 +231,7 @@ float hpf(float x, float states[])
 
 // TODO: we can either go for a faster FFT using fftr and some stack usage
 // or we can reduce stack usage to almost zero on STM32 by switching to fft_inplace
-#if defined(STM32F40_41xxx)
+#if 1
 void dft_speech(C2CONST *c2const, codec2_fft_cfg fft_fwd_cfg, COMP Sw[], float Sn[], float w[])
 {
     int  i;
@@ -259,12 +259,10 @@ void dft_speech(C2CONST *c2const, codec2_fft_cfg fft_fwd_cfg, COMP Sw[], float S
     codec2_fft_inplace(fft_fwd_cfg, Sw);
 }
 #else
-void dft_speech(C2CONST* c2const, codec2_fftr_cfg fftr_fwd_cfg, COMP Sw[], float Sn[], float w[])
+void dft_speech(codec2_fftr_cfg fftr_fwd_cfg, COMP Sw[], float Sn[], float w[])
 {
     int  i;
   float sw[FFT_ENC];
-    int  m_pitch = c2const->m_pitch;
-    int   nw      = c2const->nw;
 
   for(i=0; i<FFT_ENC; i++) {
     sw[i] = 0.0;
@@ -374,15 +372,11 @@ void hs_pitch_refinement(MODEL *model, COMP Sw[], float pmin, float pmax, float
   for(p=pmin; p<=pmax; p+=pstep) {
     E = 0.0;
     Wo = TWO_PI/p;
-    
-    float bFloat = Wo * one_on_r;
-    float currentBFloat = bFloat;
 
     /* Sum harmonic magnitudes */
     for(m=1; m<=model->L; m++) {
-        b = (int)(currentBFloat + 0.5);
+        b = (int)(m*Wo*one_on_r + 0.5);
         E += Sw[b].real*Sw[b].real + Sw[b].imag*Sw[b].imag;
-        currentBFloat += bFloat;
     }
     /* Compare to see if this is a maximum */
 
diff --git a/src/sine.h b/src/sine.h
index a51ce4f6..21d21fbc 100644
--- a/src/sine.h
+++ b/src/sine.h
@@ -36,11 +36,7 @@ C2CONST c2const_create(int Fs, float framelength_ms);
 
 void make_analysis_window(C2CONST *c2const, codec2_fft_cfg fft_fwd_cfg, float w[], float W[]);
 float hpf(float x, float states[]);
-#if defined(STM32F40_41xxx)
 void dft_speech(C2CONST *c2const, codec2_fft_cfg fft_fwd_cfg, COMP Sw[], float Sn[], float w[]);
-#else
-void dft_speech(C2CONST* c2const, codec2_fftr_cfg fftr_fwd_cfg, COMP Sw[], float Sn[], float w[]);
-#endif
 void two_stage_pitch_refinement(C2CONST *c2const, MODEL *model, COMP Sw[]);
 void estimate_amplitudes(MODEL *model, COMP Sw[], float W[], int est_phase);
 float est_voicing_mbe(C2CONST *c2const, MODEL *model, COMP Sw[], float W[]);
-- 
2.30.2

