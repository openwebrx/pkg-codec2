From 2db45b08978a5ed2ee318a7d7eae66ac53dbf6ee Mon Sep 17 00:00:00 2001
From: David Rowe <david@rowetel.com>
Date: Sun, 31 Oct 2021 07:27:15 +1030
Subject: [PATCH 36/53] rm-ed some more unused stm32 source files, building OK

---
 stm32/CMakeLists.txt              |   9 -
 stm32/inc/gdb_stdio.h             |  47 ---
 stm32/inc/iir_duc.h               |  37 --
 stm32/inc/iir_tuner.h             |  36 --
 stm32/inc/new_i2c.h               | 107 -----
 stm32/inc/si53xx.h                | 315 ---------------
 stm32/inc/sine.h                  |  48 ---
 stm32/inc/stm32f4_adc_tuner.h     |  40 --
 stm32/inc/stm32f4_dacduc.h        |  42 --
 stm32/inc/tm_stm32f4_gpio.h       | 429 --------------------
 stm32/inc/tm_stm32f4_mco_output.h | 188 ---------
 stm32/src/codec2_profile.c        | 181 ---------
 stm32/src/dac_it.c                | 205 ----------
 stm32/src/fast_dac_ut.c           | 116 ------
 stm32/src/fdmdv_profile.c         | 149 -------
 stm32/src/init.c                  |  10 -
 stm32/src/mco_ut.c                |  39 --
 stm32/src/new_i2c.c               | 430 --------------------
 stm32/src/sine.c                  | 648 ------------------------------
 stm32/src/stm32f4_dacduc.c        | 416 -------------------
 stm32/src/stm32f4_dacloduc.c      | 276 -------------
 stm32/src/stm32f4_pwm.c           | 236 -----------
 stm32/src/timer_ut.c              | 179 ---------
 stm32/src/tm_stm32f4_gpio.c       | 238 -----------
 stm32/src/tm_stm32f4_mco_output.c | 128 ------
 25 files changed, 4549 deletions(-)
 delete mode 100644 stm32/inc/gdb_stdio.h
 delete mode 100644 stm32/inc/iir_duc.h
 delete mode 100644 stm32/inc/iir_tuner.h
 delete mode 100644 stm32/inc/new_i2c.h
 delete mode 100644 stm32/inc/si53xx.h
 delete mode 100644 stm32/inc/sine.h
 delete mode 100644 stm32/inc/stm32f4_adc_tuner.h
 delete mode 100644 stm32/inc/stm32f4_dacduc.h
 delete mode 100644 stm32/inc/tm_stm32f4_gpio.h
 delete mode 100644 stm32/inc/tm_stm32f4_mco_output.h
 delete mode 100644 stm32/src/codec2_profile.c
 delete mode 100644 stm32/src/dac_it.c
 delete mode 100644 stm32/src/fast_dac_ut.c
 delete mode 100644 stm32/src/fdmdv_profile.c
 delete mode 100644 stm32/src/init.c
 delete mode 100644 stm32/src/mco_ut.c
 delete mode 100644 stm32/src/new_i2c.c
 delete mode 100644 stm32/src/sine.c
 delete mode 100644 stm32/src/stm32f4_dacduc.c
 delete mode 100644 stm32/src/stm32f4_dacloduc.c
 delete mode 100644 stm32/src/stm32f4_pwm.c
 delete mode 100644 stm32/src/timer_ut.c
 delete mode 100644 stm32/src/tm_stm32f4_gpio.c
 delete mode 100644 stm32/src/tm_stm32f4_mco_output.c

diff --git a/stm32/CMakeLists.txt b/stm32/CMakeLists.txt
index f937e51b..10c821ec 100644
--- a/stm32/CMakeLists.txt
+++ b/stm32/CMakeLists.txt
@@ -251,15 +251,6 @@ elf2bin(dac_ut)
 
 #----------------------------
 
-set(PWM_UT_SRCS
-src/stm32f4_pwm.c
-)
-add_mapped_executable(pwm_ut ${PWM_UT_SRCS})
-target_link_libraries(pwm_ut stm32f4 sm1000base)
-elf2bin(pwm_ut)
-
-#----------------------------
-
 set(USART_UT_SRCS
 src/stm32f4_usart.c
 src/usart_ut.c
diff --git a/stm32/inc/gdb_stdio.h b/stm32/inc/gdb_stdio.h
deleted file mode 100644
index eafabca4..00000000
--- a/stm32/inc/gdb_stdio.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: gdb_stdio.h
-  AUTHOR......: David Rowe
-  DATE CREATED: April 23 2013
-
-  Some stdio I/O functions that perform I/O on the host using gdb.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2013 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef __GDB_STDIO__
-#define __GDB_STDIO__
-
-#include <stdio.h>
-#include <stdarg.h>
-
-void gdb_stdio_fprintf(FILE *file, const char *format, ...);
-void gdb_stdio_printf(const char *format, ...);
-FILE *gdb_stdio_fopen(char file_name[], char mode[]);
-void gdb_stdio_fclose(FILE *file);
-int gdb_stdio_fwrite(void *ptr, int size, int nmemb, FILE *file);
-int gdb_stdio_fread(void *ptr, int size, int nmemb, FILE *file);
-
-#define printf gdb_stdio_printf
-#define fopen gdb_stdio_fopen
-#define fclose gdb_stdio_fclose
-#define fread gdb_stdio_fread
-#define fwrite gdb_stdio_fwrite
-
-#endif
diff --git a/stm32/inc/iir_duc.h b/stm32/inc/iir_duc.h
deleted file mode 100644
index b20b0b5e..00000000
--- a/stm32/inc/iir_duc.h
+++ /dev/null
@@ -1,37 +0,0 @@
- /*---------------------------------------------------------------------------*\
-
-  FILE........: iir_duc.h
-  AUTHOR......: Brady O'Brien
-  DATE CREATED: 6 Mar 2015
-
-  Interapolator/Filter for IF upconversion
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2015 Brady O'Brien
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef __IIR_DUC_H
-#define __IIR_DUC_H
-#include "comp.h"
-
-void iir_upconv(float modin[],unsigned short dac_out[]);
-void iir_upconv_fixp(int modin[], unsigned short dac_out[]);
-void upconv_48c_80r(COMP comp_8[],int real_80[],int count);
-void upconv_8c_80r(COMP comp_8[],float real_80[],int count);
-
-#endif
diff --git a/stm32/inc/iir_tuner.h b/stm32/inc/iir_tuner.h
deleted file mode 100644
index 7788a8d8..00000000
--- a/stm32/inc/iir_tuner.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: iir_tuner.h
-  AUTHOR......: David Rowe
-  DATE CREATED: 20 Feb 2015
-
-  Header file for IIR tuner function.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2015 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef __IIR_TUNER__
-#define __IIR_TUNER__
-
-#define IIR_TUNER_DEC_50_10_FILT_MEM 100
-
-void iir_tuner(float dec_50[], unsigned short adc_buf[]);
-void iir_tuner_dec_50_to_10(float dec_10[], float dec_50[], int n);
-
-#endif
diff --git a/stm32/inc/new_i2c.h b/stm32/inc/new_i2c.h
deleted file mode 100644
index a37444d2..00000000
--- a/stm32/inc/new_i2c.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/* 
- * File:   new_i2c.h
- * Author: leon (zs6lmg@gmail.com or leon@lrlabs.com)
- *
- * Created on March 17, 2016, 6:09 PM
- * 
- * GNU license apply.
- * 
- */
-
-/*
-  Copyright (C) 2016 Leon
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef NEWI2C_H
-#define	NEWI2C_H
-
-#include <stdint.h>
-
-//
-// I2C1 device Enable
-//
-#define I2C_D1 0
-// I2C1 only PORTB
-// SCL - B6 or B8
-// SDA - B7 or B9
-#if I2C_D1
-#define I2C_DEVICE I2C1
-#define I2C_DX_P_SCK GPIOB
-#define I2C_DX_P_SDA GPIOB
-#define I2C_DX_SCK 6
-#define I2C_DX_SDA 9
-// could not get macro expansion in gcc to play with us
-#define I2C_DX_CLK_SCK RCC_AHB1Periph_GPIOB
-#define I2C_DX_CLK_SDA RCC_AHB1Periph_GPIOB
-#endif
-
-//
-// I2C2 device Enable
-//
-#define I2C_D2 0
-// I2C2 on PORTB, PORTF and PORTH
-// SCL - B10 F1 H4
-// SDA - B11 F0 H5
-#if I2C_D2
-#define I2C_DEVICE I2C2
-#define I2C_DX_P_SCK GPIOB
-#define I2C_DX_P_SDA GPIOB
-#define I2C_DX_SCK 10
-#define I2C_DX_SDA 11
-// could not get macro expansion in gcc to play with us
-#define I2C_DX_CLK_SCK RCC_AHB1Periph_GPIOB
-#define I2C_DX_CLK_SDA RCC_AHB1Periph_GPIOB
-#endif
-
-//
-// I2C3 device Enable
-//
-#define I2C_D3 1
-// I2C2 on PORTA and PORTH
-// SCL - A8 H7
-// SDA - C9 H8
-#if I2C_D3
-#define I2C_DEVICE I2C3
-#define I2C_DX_P_SCK GPIOA
-#define I2C_DX_P_SDA GPIOC
-#define I2C_DX_SCK 8
-#define I2C_DX_SDA 9
-// could not get macro expansion in gcc to play with us
-#define I2C_DX_CLK_SCK RCC_AHB1Periph_GPIOA
-#define I2C_DX_CLK_SDA RCC_AHB1Periph_GPIOC
-#endif
-
-
-
-
-#define I2C_SPEED                100000
-#define I2C_STIMEOUT             ((uint32_t)0x1000)
-#define I2C_LTIMEOUT             ((uint32_t)(300 * 0x1000))
-
-// software I2C model for testing
-// 
-#define I2Cmodel 1
-
-//void I2C_GPIO_Init(void);
-void I2C_Setup(void);
-
-uint32_t I2C_NewWriteRegister(uint8_t Addr,uint8_t Register,uint8_t Value);
-uint32_t I2C_NewWriteRegisterN(uint8_t Addr,uint8_t Register,uint8_t *Value,uint8_t N);
-uint32_t I2C_NewReadRegister(uint8_t Addr,uint8_t Register);
-uint32_t I2C_NewReadRegisterN(uint8_t Addr,uint8_t Register,uint8_t *buffer, uint8_t N);
-
-#endif	/* NEWI2C_H */
-
diff --git a/stm32/inc/si53xx.h b/stm32/inc/si53xx.h
deleted file mode 100644
index b43af795..00000000
--- a/stm32/inc/si53xx.h
+++ /dev/null
@@ -1,315 +0,0 @@
-/*------------------------------------------------------------------------------
- * 
- * Ported to stm32F4xx non c++ by Leon Lessing leon@lrlabs.com or zs6lmg@gmail.com
- * 
- * 
- * Copyright (C) 2015-2016 Jason Milldrum <milldrum@gmail.com>
- *                         Dana H. Myers <k6jq@comcast.net>
- *
- * Many defines derived from clk-si5351.h in the Linux kernel.
- * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
- * Rabeeh Khoury <rabeeh@solid-run.com>
- *
- * do_div() macro derived from /include/asm-generic/div64.h in
- * the Linux kernel.
- * Copyright (C) 2003 Bernardo Innocenti <bernie@develer.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * 
- * 
- *------------------------------------------------------------------------------
-*/
-
-
-#ifndef SI53XX_H_
-#define SI53XX_H_
-
-#include <stdint.h>
-
-
-#define SI5351_BUS_BASE_ADDR			0x60
-#define SI5351_XTAL_FREQ			25000000
-#define SI5351_PLL_FIXED			90000000000ULL
-#define SI5351_FREQ_MULT			100ULL
-#define SI5351_DEFAULT_CLK			1000000000ULL
-
-#define SI5351_PLL_VCO_MIN			600000000
-#define SI5351_PLL_VCO_MAX			900000000
-#define SI5351_MULTISYNTH_MIN_FREQ		1000000
-#define SI5351_MULTISYNTH_DIVBY4_FREQ	 	150000000
-#define SI5351_MULTISYNTH_MAX_FREQ		160000000
-#define SI5351_MULTISYNTH_SHARE_MAX		112500000
-#define SI5351_MULTISYNTH67_MAX_FREQ	  	SI5351_MULTISYNTH_DIVBY4_FREQ
-#define SI5351_CLKOUT_MIN_FREQ			8000
-#define SI5351_CLKOUT_MAX_FREQ			SI5351_MULTISYNTH_MAX_FREQ
-#define SI5351_CLKOUT67_MAX_FREQ		SI5351_MULTISYNTH67_MAX_FREQ
-
-#define SI5351_PLL_A_MIN			15
-#define SI5351_PLL_A_MAX			90
-#define SI5351_PLL_B_MAX			(SI5351_PLL_C_MAX-1)
-#define SI5351_PLL_C_MAX			1048575
-#define SI5351_MULTISYNTH_A_MIN			6
-#define SI5351_MULTISYNTH_A_MAX		   	1800
-#define SI5351_MULTISYNTH67_A_MAX	   	254
-#define SI5351_MULTISYNTH_B_MAX			(SI5351_MULTISYNTH_C_MAX-1)
-#define SI5351_MULTISYNTH_C_MAX			1048575
-#define SI5351_MULTISYNTH_P1_MAX		((1<<18)-1)
-#define SI5351_MULTISYNTH_P2_MAX		((1<<20)-1)
-#define SI5351_MULTISYNTH_P3_MAX		((1<<20)-1)
-
-#define SI5351_DEVICE_STATUS			0
-#define SI5351_INTERRUPT_STATUS		   	1
-#define SI5351_INTERRUPT_MASK		     	2
-#define SI5351_STATUS_SYS_INIT		    	(1<<7)
-#define SI5351_STATUS_LOL_B			(1<<6)
-#define SI5351_STATUS_LOL_A			(1<<5)
-#define SI5351_STATUS_LOS			(1<<4)
-#define SI5351_OUTPUT_ENABLE_CTRL		3
-#define SI5351_OEB_PIN_ENABLE_CTRL		9
-#define SI5351_PLL_INPUT_SOURCE		   	15
-#define SI5351_CLKIN_DIV_MASK			(3<<6)
-#define SI5351_CLKIN_DIV_1			(0<<6)
-#define SI5351_CLKIN_DIV_2			(1<<6)
-#define SI5351_CLKIN_DIV_4			(2<<6)
-#define SI5351_CLKIN_DIV_8			(3<<6)
-#define SI5351_PLLB_SOURCE			(1<<3)
-#define SI5351_PLLA_SOURCE			(1<<2)
-
-#define SI5351_CLK0_CTRL			16
-#define SI5351_CLK1_CTRL			17
-#define SI5351_CLK2_CTRL			18
-#define SI5351_CLK3_CTRL			19
-#define SI5351_CLK4_CTRL			20
-#define SI5351_CLK5_CTRL			21
-#define SI5351_CLK6_CTRL			22
-#define SI5351_CLK7_CTRL			23
-#define SI5351_CLK_POWERDOWN			(1<<7)
-#define SI5351_CLK_INTEGER_MODE		     	(1<<6)
-#define SI5351_CLK_PLL_SELECT		     	(1<<5)
-#define SI5351_CLK_INVERT			(1<<4)
-#define SI5351_CLK_INPUT_MASK			(3<<2)
-#define SI5351_CLK_INPUT_XTAL			(0<<2)
-#define SI5351_CLK_INPUT_CLKIN			(1<<2)
-#define SI5351_CLK_INPUT_MULTISYNTH_0_4 	(2<<2)
-#define SI5351_CLK_INPUT_MULTISYNTH_N	 	(3<<2)
-#define SI5351_CLK_DRIVE_STRENGTH_MASK		(3<<0)
-#define SI5351_CLK_DRIVE_STRENGTH_2MA		(0<<0)
-#define SI5351_CLK_DRIVE_STRENGTH_4MA		(1<<0)
-#define SI5351_CLK_DRIVE_STRENGTH_6MA	 	(2<<0)
-#define SI5351_CLK_DRIVE_STRENGTH_8MA		(3<<0)
-
-#define SI5351_CLK3_0_DISABLE_STATE		24
-#define SI5351_CLK7_4_DISABLE_STATE		25
-#define SI5351_CLK_DISABLE_STATE_MASK	 	3
-#define SI5351_CLK_DISABLE_STATE_LOW	  	0
-#define SI5351_CLK_DISABLE_STATE_HIGH	 	1
-#define SI5351_CLK_DISABLE_STATE_FLOAT		2
-#define SI5351_CLK_DISABLE_STATE_NEVER		3
-
-#define SI5351_PARAMETERS_LENGTH	    	8
-#define SI5351_PLLA_PARAMETERS		  	26
-#define SI5351_PLLB_PARAMETERS		   	34
-#define SI5351_CLK0_PARAMETERS		   	42
-#define SI5351_CLK1_PARAMETERS		   	50
-#define SI5351_CLK2_PARAMETERS		   	58
-#define SI5351_CLK3_PARAMETERS		   	66
-#define SI5351_CLK4_PARAMETERS			74
-#define SI5351_CLK5_PARAMETERS			82
-#define SI5351_CLK6_PARAMETERS			90
-#define SI5351_CLK7_PARAMETERS			91
-#define SI5351_CLK6_7_OUTPUT_DIVIDER	 	92
-#define SI5351_OUTPUT_CLK_DIV_MASK		(7 << 4)
-#define SI5351_OUTPUT_CLK6_DIV_MASK	  	(7 << 0)
-#define SI5351_OUTPUT_CLK_DIV_SHIFT	  	4
-#define SI5351_OUTPUT_CLK_DIV6_SHIFT	 	0
-#define SI5351_OUTPUT_CLK_DIV_1		    	0
-#define SI5351_OUTPUT_CLK_DIV_2		    	1
-#define SI5351_OUTPUT_CLK_DIV_4		    	2
-#define SI5351_OUTPUT_CLK_DIV_8		    	3
-#define SI5351_OUTPUT_CLK_DIV_16	  	4
-#define SI5351_OUTPUT_CLK_DIV_32		5
-#define SI5351_OUTPUT_CLK_DIV_64		46
-#define SI5351_OUTPUT_CLK_DIV_128		7
-#define SI5351_OUTPUT_CLK_DIVBY4		(3<<2)
-
-#define SI5351_SSC_PARAM0			149
-#define SI5351_SSC_PARAM1			150
-#define SI5351_SSC_PARAM2			151
-#define SI5351_SSC_PARAM3			152
-#define SI5351_SSC_PARAM4			153
-#define SI5351_SSC_PARAM5			154
-#define SI5351_SSC_PARAM6			155
-#define SI5351_SSC_PARAM7			156
-#define SI5351_SSC_PARAM8		    	157
-#define SI5351_SSC_PARAM9			158
-#define SI5351_SSC_PARAM10			159
-#define SI5351_SSC_PARAM11			160
-#define SI5351_SSC_PARAM12			161
-
-#define SI5351_VXCO_PARAMETERS_LOW	 	162
-#define SI5351_VXCO_PARAMETERS_MID              163
-#define SI5351_VXCO_PARAMETERS_HIGH             164
-
-#define SI5351_CLK0_PHASE_OFFSET		165
-#define SI5351_CLK1_PHASE_OFFSET		166
-#define SI5351_CLK2_PHASE_OFFSET	   	167
-#define SI5351_CLK3_PHASE_OFFSET	   	168
-#define SI5351_CLK4_PHASE_OFFSET	   	169
-#define SI5351_CLK5_PHASE_OFFSET	   	170
-
-#define SI5351_PLL_RESET			177
-#define SI5351_PLL_RESET_B		       	(1<<7)
-#define SI5351_PLL_RESET_A		       	(1<<5)
-
-#define SI5351_CRYSTAL_LOAD	      		183
-#define SI5351_CRYSTAL_LOAD_MASK	     	(3<<6)
-#define SI5351_CRYSTAL_LOAD_0PF                 (0<<6) 
-#define SI5351_CRYSTAL_LOAD_6PF                 (1<<6)
-#define SI5351_CRYSTAL_LOAD_8PF      		(2<<6)
-#define SI5351_CRYSTAL_LOAD_10PF     		(3<<6)
-
-#define SI5351_FANOUT_ENABLE	       		187
-#define SI5351_CLKIN_ENABLE		        (1<<7)
-#define SI5351_XTAL_ENABLE		       	(1<<6)
-#define SI5351_MULTISYNTH_ENABLE	     	(1<<4)
-
-/* Macro definitions */
-
-#define RFRAC_DENOM ((1L << 20) - 1)
-
-/*
- * Based on former asm-ppc/div64.h and asm-m68knommu/div64.h
- *
- * The semantics of do_div() are:
- *
- * uint32_t do_div(uint64_t *n, uint32_t base)
- * {
- *      uint32_t remainder = *n % base;
- *      *n = *n / base;
- *      return remainder;
- * }
- *
- * NOTE: macro parameter n is evaluated multiple times,
- *       beware of side effects!
- */
-
-# define do_div(n,base) ({                                      \
-        uint64_t __base = (base);                               \
-        uint64_t __rem;                                         \
-        __rem = ((uint64_t)(n)) % __base;                       \
-        (n) = ((uint64_t)(n)) / __base;                         \
-        __rem;                                                  \
- })
-
-/* Enum definitions */
-
-/*
- * enum si5351_variant - SiLabs Si5351 chip variant
- * @SI5351_VARIANT_A: Si5351A (8 output clocks, XTAL input)
- * @SI5351_VARIANT_A3: Si5351A MSOP10 (3 output clocks, XTAL input)
- * @SI5351_VARIANT_B: Si5351B (8 output clocks, XTAL/VXCO input)
- * @SI5351_VARIANT_C: Si5351C (8 output clocks, XTAL/CLKIN input)
- */
- enum si5351_variant {SI5351_VARIANT_A, SI5351_VARIANT_A3,	SI5351_VARIANT_B,
-   SI5351_VARIANT_C};
-
- enum si5351_clock {SI5351_CLK0, SI5351_CLK1, SI5351_CLK2, SI5351_CLK3,
- 	SI5351_CLK4, SI5351_CLK5, SI5351_CLK6, SI5351_CLK7, SI5351_CLKNONE};
-
- enum si5351_pll {SI5351_PLLA, SI5351_PLLB};
-
- enum si5351_drive {SI5351_DRIVE_2MA, SI5351_DRIVE_4MA, SI5351_DRIVE_6MA,
-   SI5351_DRIVE_8MA};
-
- enum si5351_clock_source {SI5351_CLK_SRC_XTAL, SI5351_CLK_SRC_CLKIN,
-   SI5351_CLK_SRC_MS0, SI5351_CLK_SRC_MS};
-
- enum si5351_clock_disable {SI5351_CLK_DISABLE_LOW, SI5351_CLK_DISABLE_HIGH,
-   SI5351_CLK_DISABLE_HI_Z, SI5351_CLK_DISABLE_NEVER};
-
- enum si5351_clock_fanout {SI5351_FANOUT_CLKIN, SI5351_FANOUT_XO,
-   SI5351_FANOUT_MS};
-
- enum si5351_pll_input{SI5351_PLL_INPUT_XO, SI5351_PLL_INPUT_CLKIN};
-
-/* Struct definitions */
-
-struct Si5351RegSet {
-    uint32_t p1;
-    uint32_t p2;
-    uint32_t p3;
-};
-
-struct Si5351Status {
-    uint8_t SYS_INIT;
-    uint8_t LOL_B;
-    uint8_t LOL_A;
-    uint8_t LOS;
-    uint8_t REVID;
-};
-
-struct Si5351IntStatus {
-    uint8_t SYS_INIT_STKY;
-    uint8_t LOL_B_STKY;
-    uint8_t LOL_A_STKY;
-    uint8_t LOS_STKY;
-};
-
-typedef struct {
-    struct Si5351Status dev_status;
-    struct Si5351IntStatus dev_int_status;
-    uint64_t plla_freq;
-    uint64_t pllb_freq;
-    uint64_t clk0_freq;
-    uint64_t clk1_freq;
-    uint64_t clk2_freq;
-    uint8_t clk0_int_mode, clk1_int_mode, clk2_int_mode;
-    int32_t ref_correction;
-    uint8_t lock_plla, lock_pllb;
-    uint32_t xtal_freq;
-    uint32_t I2C_ErrorCode;
-    uint8_t I2C_add;
-} T_Si5351_data;
-
-
-
-T_Si5351_data   Si5351_Config;
-
-/* private routines */
-
-
-void si5351_write(uint8_t REGaddr, uint8_t data);
-void si5351_write_bulk(uint8_t REGaddr, uint8_t bytes, uint8_t *data);
-uint8_t si5351_read(uint8_t REGaddr);
-uint64_t si5351_multisynth_calc(uint64_t freq, uint64_t pll_freq, struct Si5351RegSet *reg);
-void si5351_set_ms_source(enum si5351_clock clk, enum si5351_pll pll);
-void si5351_set_ms(enum si5351_clock clk, struct Si5351RegSet ms_reg, uint8_t int_mode, uint8_t r_div, uint8_t div_by_4);
-void si5351_set_pll(uint64_t pll_freq, enum si5351_pll target_pll);
-void si5351_ms_div(enum si5351_clock clk, uint8_t r_div, uint8_t div_by_4);
-void si5351_set_int(enum si5351_clock clk, uint8_t enable);
-uint64_t si5351_pll_calc(uint64_t freq, struct Si5351RegSet *reg, int32_t correction);
-uint8_t si5351_select_r_div(uint64_t *freq);
-
-
-/* public routines */
-
-
-
-void si5351_init(uint8_t I2C_Address,  uint8_t xtal_load_c, uint32_t ref_osc_freq);
-void si5351_pll_reset(enum si5351_pll target_pll);
-void si5351_set_clock_pwr(enum si5351_clock clk, uint8_t pwr);
-void si5351_set_clock_invert(enum si5351_clock clk, uint8_t inv);
-uint8_t si5351_set_freq(uint64_t freq_in_Hz_times_100, uint64_t pll_freq, enum si5351_clock clk);
-
-#endif
diff --git a/stm32/inc/sine.h b/stm32/inc/sine.h
deleted file mode 100644
index 3a3ce46d..00000000
--- a/stm32/inc/sine.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: sine.h
-  AUTHOR......: David Rowe
-  DATE CREATED: 1/11/94
-
-  Header file for sinusoidal analysis and synthesis functions.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2009 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef __SINE__
-#define __SINE__
-
-#include "defines.h"
-#include "comp.h"
-#include "kiss_fft.h"
-
-void make_analysis_window(kiss_fft_cfg fft_fwd_cfg, float w[], COMP W[]);
-float hpf(float x, float states[]);
-void dft_speech(kiss_fft_cfg fft_fwd_cfg, COMP Sw[], float Sn[], float w[]);
-void two_stage_pitch_refinement(MODEL *model, COMP Sw[]);
-void estimate_amplitudes(MODEL *model, COMP Sw[], COMP W[], int est_phase);
-float est_voicing_mbe(MODEL *model, COMP Sw[], COMP W[], COMP Sw_[],COMP Ew[],
-		      float prev_Wo);
-void make_synthesis_window(float Pn[]);
-void synthesise(kiss_fft_cfg fft_inv_cfg, float Sn_[], MODEL *model, float Pn[], int shift);
-
-#define CODEC2_RAND_MAX 32767
-int codec2_rand(void);
-
-#endif
diff --git a/stm32/inc/stm32f4_adc_tuner.h b/stm32/inc/stm32f4_adc_tuner.h
deleted file mode 100644
index a258b9d8..00000000
--- a/stm32/inc/stm32f4_adc_tuner.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: stm32f4_adc_tuner.h
-  AUTHOR......: David Rowe
-  DATE CREATED: 19 Feb 2015
-
-  Single channel ADC driver module for STM32F4 that samples pin PA1 at
-  2 MHz and down converts to 50 kHz, with "tuning" centred at 500 kHz.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2015 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef __STM32F4_ADC_TUNER__
-#define __STM32F4_ADC_TUNER__
-
-#define ADC_TUNER_M  45   /* decimation rate */
-#define ADC_TUNER_N  160
-#define ADC_TUNER_BUF_SZ  (ADC_TUNER_M*ADC_TUNER_N)
-
-void adc_open(int fifo_sz);
-int adc1_read(short buf[], int n); /* ADC1 Pin PA1 */
-void adc_set_tuner_en(short flag); /* disable tuner to get raw ADC samples written to fifo */
-
-#endif
diff --git a/stm32/inc/stm32f4_dacduc.h b/stm32/inc/stm32f4_dacduc.h
deleted file mode 100644
index 6a1ba20c..00000000
--- a/stm32/inc/stm32f4_dacduc.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: stm32f4_dac.h
-  AUTHOR......: David Rowe
-  DATE CREATED: 1 June 2013
-
-  Two channel FIFO buffered DAC driver module for STM32F4. DAC1 is fixed at
-  Fs=2Mhz
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2013 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef __STM32F4_DAC__
-#define __STM32F4_DAC__
-
-#define DUC_N 160
-#define DUC_M  25
-#define DUC_48N 96                     //This is 3/5th DUC_N
-#define DAC_DUC_BUF_SZ DUC_M*DUC_N
-#define DAC_BUF_SZ 2048
-
-void fast_dac_open(int dac1_fifo_size,int dac2_fifo_size);
-int dac1_write(short buf[], int n); /* DAC1 pin PA4 */
-int dac2_write(short buf[], int n); /* DAC2 pin PA5 */
-
-#endif
diff --git a/stm32/inc/tm_stm32f4_gpio.h b/stm32/inc/tm_stm32f4_gpio.h
deleted file mode 100644
index d9733507..00000000
--- a/stm32/inc/tm_stm32f4_gpio.h
+++ /dev/null
@@ -1,429 +0,0 @@
-/** 
- * @author  Tilen Majerle
- * @email   tilen@majerle.eu
- * @website http://stm32f4-discovery.com
- * @link    http://stm32f4-discovery.com/2015/03/library-53-gpio-for-stm32f4
- * @version v1.5
- * @ide     Keil uVision
- * @license GNU GPL v3
- * @brief   GPIO Library for STM32F4xx devices
- *
-@verbatim
-   ----------------------------------------------------------------------
-    Copyright (C) Tilen Majerle, 2015
-    
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    any later version.
-     
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-   ----------------------------------------------------------------------
-@endverbatim
- */
-#ifndef TM_GPIO_H
-#define TM_GPIO_H 150
-
-/**
- * @addtogroup TM_STM32F4xx_Libraries
- * @{
- */
-
-/**
- * @defgroup TM_GPIO
- * @brief    TM GPIO Library for STM32F4xx - http://stm32f4-discovery.com/2015/03/library-53-gpio-for-stm32f4
- * @{
- *
- * GPIO library can be used for GPIO pins. 
- *
- * It features fast initialization methods as well pin input/output methods.
- *
- * It can be used as replacement for STD/HAL drivers GPIO library.
- *
- * \par Changelog
- *
-@verbatim
- Version 1.5
-  - June 10 2015
-  - Added 2 new functions for getting used GPIO pins
-  
- Version 1.4
-  - April 28, 2015
-  - Added support for PORT locking
-  
- Version 1.3
-  - March 23, 2015
-  - Totally independent from HAL / SPD drivers
-  - Library can be used with any drivers or totally itself
-  
- Version 1.2
-  - March 10, 2015
-  - Added functions TM_GPIO_SetPinAsInput and TM_GPIO_SetPinAsOutput
-  - Added functions TM_GPIO_GetPortSource and TM_GPIO_GetPinSource
-0
- Version 1.1
-  - March 09, 2015
-  - Added function to deinit pin. Pin is set to analog input which allows lowest current consumption
-  
- Version 1.0
-  - March 08, 2015
-  - Initial release
-@endverbatim
- *
- * \par Dependencies
- *
-@verbatim
- - STM32F4xx
- - STM32F4xx GPIO
- - defines.h
-@endverbatim
- */
-
-#include "stm32f4xx.h"
-#include "stm32f4xx_gpio.h"
-#include "defines.h"
-
-/* C++ detection */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @defgroup TM_GPIO_Macros
- * @brief    GPIO Library macros
- * @{
- */
-
-/**
- * @brief GPIO Pins declarations 
- * @note  For HAL drivers compatibility
- */
-  
-#ifndef GPIO_PIN_0
-#define GPIO_PIN_0		((uint16_t)0x0001)
-#define GPIO_PIN_1		((uint16_t)0x0002)
-#define GPIO_PIN_2		((uint16_t)0x0004)
-#define GPIO_PIN_3		((uint16_t)0x0008)
-#define GPIO_PIN_4		((uint16_t)0x0010)
-#define GPIO_PIN_5		((uint16_t)0x0020)
-#define GPIO_PIN_6		((uint16_t)0x0040)
-#define GPIO_PIN_7		((uint16_t)0x0080)
-#define GPIO_PIN_8		((uint16_t)0x0100)
-#define GPIO_PIN_9		((uint16_t)0x0200)
-#define GPIO_PIN_10		((uint16_t)0x0400)
-#define GPIO_PIN_11		((uint16_t)0x0800)
-#define GPIO_PIN_12		((uint16_t)0x1000)
-#define GPIO_PIN_13		((uint16_t)0x2000)
-#define GPIO_PIN_14		((uint16_t)0x4000)
-#define GPIO_PIN_15		((uint16_t)0x8000)
-#define GPIO_PIN_ALL	((uint16_t)0xFFFF)
-#endif
-
-/**
- * @brief GPIO Pins declarations 
- * @note  For STD Periph drivers compatibility
- */
-
-#ifndef GPIO_Pin_0
-#define GPIO_Pin_0		((uint16_t)0x0001)
-#define GPIO_Pin_1		((uint16_t)0x0002)
-#define GPIO_Pin_2		((uint16_t)0x0004)
-#define GPIO_Pin_3		((uint16_t)0x0008)
-#define GPIO_Pin_4		((uint16_t)0x0010)
-#define GPIO_Pin_5		((uint16_t)0x0020)
-#define GPIO_Pin_6		((uint16_t)0x0040)
-#define GPIO_Pin_7		((uint16_t)0x0080)
-#define GPIO_Pin_8		((uint16_t)0x0100)
-#define GPIO_Pin_9		((uint16_t)0x0200)
-#define GPIO_Pin_10		((uint16_t)0x0400)
-#define GPIO_Pin_11		((uint16_t)0x0800)
-#define GPIO_Pin_12		((uint16_t)0x1000)
-#define GPIO_Pin_13		((uint16_t)0x2000)
-#define GPIO_Pin_14		((uint16_t)0x4000)
-#define GPIO_Pin_15		((uint16_t)0x8000)
-#define GPIO_Pin_All	((uint16_t)0xFFFF)
-#endif
-
-/**
- * @}
- */
-
-/**
- * @defgroup TM_GPIO_Typedefs
- * @brief    GPIO Typedefs used for GPIO library for initialization purposes
- * @{
- */
-
-/**
- * @brief GPIO Mode enumeration
- */
-typedef enum {
-	TM_GPIO_Mode_IN = 0x00,  /*!< GPIO Pin as General Purpose Input */
-	TM_GPIO_Mode_OUT = 0x01, /*!< GPIO Pin as General Purpose Output */
-	TM_GPIO_Mode_AF = 0x02,  /*!< GPIO Pin as Alternate Function */
-	TM_GPIO_Mode_AN = 0x03,  /*!< GPIO Pin as Analog */
-} TM_GPIO_Mode_t;
-
-/**
- * @brief GPIO Output type enumeration
- */
-typedef enum {
-	TM_GPIO_OType_PP = 0x00, /*!< GPIO Output Type Push-Pull */
-	TM_GPIO_OType_OD = 0x01  /*!< GPIO Output Type Open-Drain */
-} TM_GPIO_OType_t;
-
-/**
- * @brief  GPIO Speed enumeration
- */
-typedef enum {
-	TM_GPIO_Speed_Low = 0x00,    /*!< GPIO Speed Low */
-	TM_GPIO_Speed_Medium = 0x01, /*!< GPIO Speed Medium */
-	TM_GPIO_Speed_Fast = 0x02,   /*!< GPIO Speed Fast */
-	TM_GPIO_Speed_High = 0x03    /*!< GPIO Speed High */
-} TM_GPIO_Speed_t;
-
-/**
- * @brief GPIO pull resistors enumeration
- */
-typedef enum {
-	TM_GPIO_PuPd_NOPULL = 0x00, /*!< No pull resistor */
-	TM_GPIO_PuPd_UP = 0x01,     /*!< Pull up resistor enabled */
-	TM_GPIO_PuPd_DOWN = 0x02    /*!< Pull down resistor enabled */
-} TM_GPIO_PuPd_t;
-
-/**
- * @} TM_GPIO_Typedefs
- */
-
-/**
- * @defgroup TM_GPIO_Functions
- * @brief    GPIO Functions
- * @{
- */
- 
-/**
- * @brief  Initializes GPIO pins(s)
- * @note   This function also enables clock for GPIO port
- * @param  GPIOx: Pointer to GPIOx port you will use for initialization
- * @param  GPIO_Pin: GPIO pin(s) you will use for initialization
- * @param  GPIO_Mode: Select GPIO mode. This parameter can be a value of @ref TM_GPIO_Mode_t enumeration
- * @param  GPIO_OType: Select GPIO Output type. This parameter can be a value of @ref TM_GPIO_OType_t enumeration
- * @param  GPIO_PuPd: Select GPIO pull resistor. This parameter can be a value of @ref TM_GPIO_PuPd_t enumeration
- * @param  GPIO_Speed: Select GPIO speed. This parameter can be a value of @ref TM_GPIO_Speed_t enumeration
- * @retval None
- */
-void TM_GPIO_Init(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_Mode_t GPIO_Mode, TM_GPIO_OType_t GPIO_OType, TM_GPIO_PuPd_t GPIO_PuPd, TM_GPIO_Speed_t GPIO_Speed);
-
-/**
- * @brief  Initializes GPIO pins(s) as alternate function
- * @note   This function also enables clock for GPIO port
- * @param  GPIOx: Pointer to GPIOx port you will use for initialization
- * @param  GPIO_Pin: GPIO pin(s) you will use for initialization
- * @param  GPIO_OType: Select GPIO Output type. This parameter can be a value of @ref TM_GPIO_OType_t enumeration
- * @param  GPIO_PuPd: Select GPIO pull resistor. This parameter can be a value of @ref TM_GPIO_PuPd_t enumeration
- * @param  GPIO_Speed: Select GPIO speed. This parameter can be a value of @ref TM_GPIO_Speed_t enumeration
- * @param  Alternate: Alternate function you will use
- * @retval None
- */
-void TM_GPIO_InitAlternate(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_OType_t GPIO_OType, TM_GPIO_PuPd_t GPIO_PuPd, TM_GPIO_Speed_t GPIO_Speed, uint8_t Alternate);
-
-/**
- * @brief  Deinitializes pin(s)
- * @note   Pins(s) will be set as analog mode to get low power consumption
- * @param  GPIOx: GPIOx PORT where you want to set pin as input
- * @param  GPIO_Pin: Select GPIO pin(s). You can select more pins with | (OR) operator to set them as input
- * @retval None
- */
-void TM_GPIO_DeInit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
-
-/**
- * @brief  Sets pin(s) as input 
- * @note   Pins HAVE to be initialized first using @ref TM_GPIO_Init() or @ref TM_GPIO_InitAlternate() function
- * @note   This is just an option for fast input mode
- * @param  GPIOx: GPIOx PORT where you want to set pin as input
- * @param  GPIO_Pin: Select GPIO pin(s). You can select more pins with | (OR) operator to set them as input
- * @retval None
- */
-void TM_GPIO_SetPinAsInput(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
-
-/**
- * @brief  Sets pin(s) as output
- * @note   Pins HAVE to be initialized first using @ref TM_GPIO_Init() or @ref TM_GPIO_InitAlternate() function
- * @note   This is just an option for fast output mode 
- * @param  GPIOx: GPIOx PORT where you want to set pin as output
- * @param  GPIO_Pin: Select GPIO pin(s). You can select more pins with | (OR) operator to set them as output
- * @retval None
- */
-void TM_GPIO_SetPinAsOutput(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
-
-/**
- * @brief  Sets pin(s) as analog
- * @note   Pins HAVE to be initialized first using @ref TM_GPIO_Init() or @ref TM_GPIO_InitAlternate() function
- * @note   This is just an option for fast analog mode 
- * @param  GPIOx: GPIOx PORT where you want to set pin as analog
- * @param  GPIO_Pin: Select GPIO pin(s). You can select more pins with | (OR) operator to set them as analog
- * @retval None
- */
-void TM_GPIO_SetPinAsAnalog(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
-
-/** 
- * @brief  Sets pin(s) as alternate function
- * @note   For proper alternate function, you should first init pin using @ref TM_GPIO_InitAlternate() function.
- *            This functions is only used for changing GPIO mode
- * @param  GPIOx: GPIOx PORT where you want to set pin as alternate
- * @param  GPIO_Pin: Select GPIO pin(s). You can select more pins with | (OR) operator to set them as alternate
- * @retval None
- */
-void TM_GPIO_SetPinAsAlternate(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
-
-/**
- * @brief  Sets pull resistor settings to GPIO pin(s)
- * @note   Pins HAVE to be initialized first using @ref TM_GPIO_Init() or @ref TM_GPIO_InitAlternate() function
- * @param  *GPIOx: GPIOx PORT where you want to select pull resistor
- * @param  GPIO_Pin: Select GPIO pin(s). You can select more pins with | (OR) operator to set them as output
- * @param  GPIO_PuPd: Pull resistor option. This parameter can be a value of @ref TM_GPIO_PuPd_t enumeration
- * @retval None
- */
-void TM_GPIO_SetPullResistor(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_PuPd_t GPIO_PuPd);
-
-/**
- * @brief  Sets pin(s) low
- * @note   Defined as macro to get maximum speed using register access
- * @param  GPIOx: GPIOx PORT where you want to set pin low
- * @param  GPIO_Pin: Select GPIO pin(s). You can select more pins with | (OR) operator to set them low
- * @retval None
- */
-#define TM_GPIO_SetPinLow(GPIOx, GPIO_Pin)			((GPIOx)->BSRRH = (GPIO_Pin))
-
-/**
- * @brief  Sets pin(s) high
- * @note   Defined as macro to get maximum speed using register access
- * @param  GPIOx: GPIOx PORT where you want to set pin high
- * @param  GPIO_Pin: Select GPIO pin(s). You can select more pins with | (OR) operator to set them high
- * @retval None
- */
-#define TM_GPIO_SetPinHigh(GPIOx, GPIO_Pin) 		((GPIOx)->BSRRL = (GPIO_Pin))
-
-/**
- * @brief  Sets pin(s) value
- * @note   Defined as macro to get maximum speed using register access
- * @param  GPIOx: GPIOx PORT where you want to set pin value
- * @param  GPIO_Pin: Select GPIO pin(s). You can select more pins with | (OR) operator to set them value
- * @param  val: If parameter is 0 then pin will be low, otherwise high
- * @retval None
- */
-#define TM_GPIO_SetPinValue(GPIOx, GPIO_Pin, val)	((val) ? TM_GPIO_SetPinHigh(GPIOx, GPIO_Pin) : TM_GPIO_SetPinLow(GPIOx, GPIO_Pin))
-
-/**
- * @brief  Toggles pin(s)
- * @note   Defined as macro to get maximum speed using register access
- * @param  GPIOx: GPIOx PORT where you want to toggle pin value
- * @param  GPIO_Pin: Select GPIO pin(s). You can select more pins with | (OR) operator to toggle them all at a time
- * @retval None
- */
-#define TM_GPIO_TogglePinValue(GPIOx, GPIO_Pin)		((GPIOx)->ODR ^= (GPIO_Pin))
-
-/**
- * @brief  Sets value to entire GPIO PORT
- * @note   Defined as macro to get maximum speed using register access
- * @param  GPIOx: GPIOx PORT where you want to set value
- * @param  value: Value for GPIO OUTPUT data
- * @retval None
- */
-#define TM_GPIO_SetPortValue(GPIOx, value)			((GPIOx)->ODR = (value))
-
-/**
- * @brief  Gets input data bit
- * @note   Defined as macro to get maximum speed using register access
- * @param  GPIOx: GPIOx PORT where you want to read input bit value
- * @param  GPIO_Pin: GPIO pin where you want to read value
- * @retval 1 in case pin is high, or 0 if low
- */
-#define TM_GPIO_GetInputPinValue(GPIOx, GPIO_Pin)	(((GPIOx)->IDR & (GPIO_Pin)) == 0 ? 0 : 1)
-
-/**
- * @brief  Gets output data bit
- * @note   Defined as macro to get maximum speed using register access
- * @param  GPIOx: GPIOx PORT where you want to read output bit value
- * @param  GPIO_Pin: GPIO pin where you want to read value
- * @retval 1 in case pin is high, or 0 if low
- */
-#define TM_GPIO_GetOutputPinValue(GPIOx, GPIO_Pin)	(((GPIOx)->ODR & (GPIO_Pin)) == 0 ? 0 : 1)
-
-/**
- * @brief  Gets input value from entire GPIO PORT
- * @note   Defined as macro to get maximum speed using register access
- * @param  GPIOx: GPIOx PORT where you want to read input data value
- * @retval Entire PORT INPUT register
- */
-#define TM_GPIO_GetPortInputValue(GPIOx)			((GPIOx)->IDR)
-
-/**
- * @brief  Gets output value from entire GPIO PORT
- * @note   Defined as macro to get maximum speed using register access
- * @param  GPIOx: GPIOx PORT where you want to read output data value
- * @retval Entire PORT OUTPUT register
- */
-#define TM_GPIO_GetPortOutputValue(GPIOx)			((GPIOx)->ODR)
-
-/**
- * @brief  Gets port source from desired GPIOx PORT
- * @note   Meant for private use, unless you know what are you doing
- * @param  GPIOx: GPIO PORT for calculating port source
- * @retval Calculated port source for GPIO
- */
-uint16_t TM_GPIO_GetPortSource(GPIO_TypeDef* GPIOx);
-
-/**
- * @brief  Gets pin source from desired GPIO pin
- * @note   Meant for private use, unless you know what are you doing
- * @param  GPIO_Pin: GPIO pin for calculating port source
- * @retval Calculated pin source for GPIO pin
- */
-uint16_t TM_GPIO_GetPinSource(uint16_t GPIO_Pin);
-
-/**
- * @brief  Locks GPIOx register for future changes
- * @note   You are not able to config GPIO registers until new MCU reset occurs
- * @param  *GPIOx: GPIOx PORT where you want to lock config registers
- * @param  GPIO_Pin: GPIO pin(s) where you want to lock config registers
- * @retval None
- */
-void TM_GPIO_Lock(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
-
-/** 
- * @brief  Gets bit separated pins which were used at least once in library and were not deinitialized
- * @param  *GPIOx: Pointer to GPIOx peripheral where to check used GPIO pins
- * @retval Bit values for used pins
- */
-uint16_t TM_GPIO_GetUsedPins(GPIO_TypeDef* GPIOx);
-
-/** 
- * @brief  Gets bit separated pins which were not used at in library or were deinitialized
- * @param  *GPIOx: Pointer to GPIOx peripheral where to check used GPIO pins
- * @retval Bit values for free pins
- */
-uint16_t TM_GPIO_GetFreePins(GPIO_TypeDef* GPIOx);
-
-/**
- * @}
- */
-/**
- * @}
- */
-/**
- * @}
- */
-
-/* C++ detection */
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/stm32/inc/tm_stm32f4_mco_output.h b/stm32/inc/tm_stm32f4_mco_output.h
deleted file mode 100644
index 820e5649..00000000
--- a/stm32/inc/tm_stm32f4_mco_output.h
+++ /dev/null
@@ -1,188 +0,0 @@
-/**
- * @author  Tilen Majerle
- * @email   tilen@majerle.eu
- * @website http://stm32f4-discovery.com
- * @link    http://stm32f4-discovery.com/2014/10/library-40-output-clocks-stm32f4/
- * @version v1.1
- * @ide     Keil uVision
- * @license GNU GPL v3
- * @brief   MCO Output for STM32F4xx
- *	
-@verbatim
-   ----------------------------------------------------------------------
-    Copyright (C) Tilen Majerle, 2015
-    
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    any later version.
-     
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-    
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-   ----------------------------------------------------------------------
-@endverbatim
- */
-#ifndef TM_MCOOUTPUT_H
-#define TM_MCOOUTPUT_H 110
-
-/**
- * @addtogroup TM_STM32F4xx_Libraries
- * @{
- */
-
-/**
- * @defgroup TM_MCO
- * @brief    MCO Output clock for STM32F4xx - http://stm32f4-discovery.com/2014/10/library-40-output-clocks-stm32f4/
- * @{
- *
- * This library allows you to output different frequencies. They are split into 2 different output sections.
- *
- * \par MCO1 output = PA8
- *
- * MCO1 output
- * 	- Pin PA8
- * 	- HSI: High Speed Internal clock, 16MHz RC oscillator
- * 	- HSE: High Speed External clock, external crystal or user clock
- * 	- LSE: External 32738Hz low-speed oscillator or ceramic resonator
- * 	- PLLCLK: Output from PLL
- *
- * \par MCO2 output = PC9
- *
- * MCO2 output
- * 	- Pin PC9
- * 	- SYSCLK: Output system core clock
- * 	- PLLI2SCLK: Accurate clock for high-quality audio performance in I2S and SAI interfaces
- * 	- HSE: High Speed External clock, external crystal or user clock
- * 	- PLLCLK: Output from PLL
- *
- * \par Changelog
- *
-@verbatim
- Version 1.1
-  - March 11, 2015
-  - Support for my new GPIO library
-
- Version 1.0
-  - First release
-@endverbatim
- *
- * \par Dependencies
- *
-@verbatim
- - STM32F4xx
- - STM32F4xx RCC
- - defines.h
- - TM GPIO
-@endverbatim
- */
-
-#include "stm32f4xx.h"
-#include "stm32f4xx_rcc.h"
-#include "defines.h"
-#include "tm_stm32f4_gpio.h"
-
-/* C++ detection */
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**
- * @defgroup TM_MCO_Typedefs
- * @brief    Library Typedefs
- * @{
- */
-
-/**
- * @brief  Prescaler values for output clock
- */
-typedef enum {
-	TM_MCOOUTPUT_Prescaler_1, /*!< Output original value of clock on MCO pin */
-	TM_MCOOUTPUT_Prescaler_2, /*!< Output clock is original / 2 */
-	TM_MCOOUTPUT_Prescaler_3, /*!< Output clock is original / 3 */
-	TM_MCOOUTPUT_Prescaler_4, /*!< Output clock is original / 4 */
-	TM_MCOOUTPUT_Prescaler_5  /*!< Output clock is original / 5 */
-} TM_MCOOUTPUT_Prescaler_t;
-
-/**
- * @brief  Possible output clocks on MCO1 pin
- */
-typedef enum {
-	TM_MCOOUTPUT1_Source_HSI,   /*!< High Speed Internal clock, 16MHz RC oscillator */
-	TM_MCOOUTPUT1_Source_HSE,   /*!< High Speed External clock, external crystal or user clock */
-	TM_MCOOUTPUT1_Source_LSE,   /*!< External 32738Hz low-speed oscillator or ceramic resonator */
-	TM_MCOOUTPUT1_Source_PLLCLK /*!< Output from PLL */
-} TM_MCOOUTPUT1_Source_t;
-
-/**
- * @brief  Possible output clocks on MCO2 pin
- */
-typedef enum {
-	TM_MCOOUTPUT2_Source_SYSCLK,    /*!< System core clock */
-	TM_MCOOUTPUT2_Source_PLLI2SCLK, /*!< Accurate clock for high-quality audio performance in I2S and SAI interfaces */
-	TM_MCOOUTPUT2_Source_HSE,       /*!< High Speed External clock, external crystal or user clock */
-	TM_MCOOUTPUT2_Source_PLLCLK     /*!< Output from PLL */
-} TM_MCOOUTPUT2_Source_t;
-
-/**
- * @}
- */
-
-/**
- * @defgroup TM_MCO_Functions
- * @brief    Library Functions
- * @{
- */
-
-/**
- * @brief  Initializes and prepares MCO1 pin to output clock
- * @param  None
- * @retval None
- */
-void TM_MCOOUTPUT_InitMCO1(void);
-
-/**
- * @brief  Sets output for MCO1 pin
- * @param  Source: Clock source to output. This parameter can be a value of @ref TM_MCOOUTPUT1_Source_t enumeration.
- * @param  Prescaler: Prescaler used for clock. This parameter can be a value of @ref TM_MCOOUTPUT_Prescaler_t enumeration.
- * @retval None
- */
-void TM_MCOOUTPUT_SetOutput1(TM_MCOOUTPUT1_Source_t Source, TM_MCOOUTPUT_Prescaler_t Prescaler);
-
-/**
- * @brief  Initializes and prepares MCO2 pin to output clock
- * @param  None
- * @retval None
- */
-void TM_MCOOUTPUT_InitMCO2(void);
- 
-/**
- * @brief  Sets output for MCO2 pin
- * @param  Source: Clock source to output. This parameter can be a value of @ref TM_MCOOUTPUT2_Source_t enumeration.
- * @param  Prescaler: Prescaler used for clock. This parameter can be a value of @ref TM_MCOOUTPUT_Prescaler_t enumeration.
- * @retval None
- */
-void TM_MCOOUTPUT_SetOutput2(TM_MCOOUTPUT2_Source_t Source, TM_MCOOUTPUT_Prescaler_t Prescaler);
-
-/**
- * @}
- */
- 
-/**
- * @}
- */
- 
-/**
- * @}
- */
-
-/* C++ detection */
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/stm32/src/codec2_profile.c b/stm32/src/codec2_profile.c
deleted file mode 100644
index 5537bad5..00000000
--- a/stm32/src/codec2_profile.c
+++ /dev/null
@@ -1,181 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: codec2_profile.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 30 May 2013
-
-  Profiling Codec 2 operation on the STM32F4.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2014 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <math.h>
-
-#include "stm32f4xx_conf.h"
-#include "stm32f4xx.h"
-#include "gdb_stdio.h"
-#include "codec2.h"
-#include "dump.h"
-#include "sine.h"
-#include "machdep.h"
-
-#ifdef __EMBEDDED__
-#define printf gdb_stdio_printf
-#define fopen gdb_stdio_fopen
-#define fclose gdb_stdio_fclose
-#define fread gdb_stdio_fread
-#define fwrite gdb_stdio_fwrite
-#endif
-
-static void c2demo(int mode, char inputfile[], char outputfile[])
-{
-    struct CODEC2 *codec2;
-    short         *inbuf, *outbuf;
-    unsigned char *bits;
-    int            nsam, nbit;
-    FILE          *fin, *fout;
-    int            frame;
-    PROFILE_VAR(enc_start, dec_start);
-
-    codec2 = codec2_create(mode);
-    nsam = codec2_samples_per_frame(codec2);
-    outbuf = (short*)malloc(nsam*sizeof(short));
-    inbuf = (short*)malloc(nsam*sizeof(short));
-    nbit = codec2_bits_per_frame(codec2);
-    bits = (unsigned char*)malloc(nbit*sizeof(char));
-
-    fin = fopen(inputfile, "rb");
-    if (fin == NULL) {
-        printf("Error opening input file: %s\n\nTerminating....\n",inputfile);
-        exit(1);
-    }
-
-    fout = fopen(outputfile, "wb");
-    if (fout == NULL) {
-        printf("Error opening output file: %s\n\nTerminating....\n",outputfile);
-        exit(1);
-    }
-
-    #ifdef DUMP
-    dump_on("stm32f4");
-    #endif
-    frame = 0;
-
-    while (fread(inbuf, sizeof(short), nsam, fin) == nsam) {
-        PROFILE_SAMPLE(enc_start);
-        codec2_encode(codec2, bits, inbuf);
-        PROFILE_SAMPLE_AND_LOG(dec_start, enc_start, "  enc");
-	codec2_decode(codec2, outbuf, bits);
-        PROFILE_SAMPLE_AND_LOG2(dec_start, "  dec");
-        PROFILE_SAMPLE_AND_LOG2(enc_start, "  enc & dec");
-        fwrite((char*)outbuf, sizeof(short), nsam, fout);
-        printf("frame: %d\n", ++frame);
-        machdep_profile_print_logged_samples();
-    }
-
-    #ifdef DUMP
-    dump_off("sm32f4");
-    #endif
-
-    fclose(fin);
-    fclose(fout);
-    free(inbuf);
-    free(outbuf);
-    free(bits);
-    codec2_destroy(codec2);
-}
-
-#define SPEED_TEST_SAMPLES 24000
-
-static void c2speedtest(int mode, char inputfile[])
-{
-    struct CODEC2 *codec2;
-    short         *inbuf, *outbuf, *pinbuf;
-    unsigned char *bits;
-    int            nsam, nbit, nframes;
-    FILE          *fin;
-    int            f, nread;
-
-    codec2 = codec2_create(mode);
-    nsam = codec2_samples_per_frame(codec2);
-    nframes = SPEED_TEST_SAMPLES/nsam;
-    outbuf = (short*)malloc(nsam*sizeof(short));
-    inbuf = (short*)malloc(SPEED_TEST_SAMPLES*sizeof(short));
-    nbit = codec2_bits_per_frame(codec2);
-    bits = (unsigned char*)malloc(nbit*sizeof(char));
-
-    fin = fopen(inputfile, "rb");
-    if (fin == NULL) {
-        printf("Error opening input file: %s\nTerminating....\n",inputfile);
-        exit(1);
-    }
-
-    nread = fread(inbuf, sizeof(short), SPEED_TEST_SAMPLES, fin);
-    if (nread != SPEED_TEST_SAMPLES) {
-        printf("error reading %s, %d samples reqd, %d read\n",
-               inputfile, SPEED_TEST_SAMPLES, nread);
-    }
-    fclose(fin);
-
-    pinbuf = inbuf;
-    for(f=0; f<nframes; f++) {
-	GPIOD->ODR = (1 << 13);
-        codec2_encode(codec2, bits, pinbuf);
-        pinbuf += nsam;
-	GPIOD->ODR &= ~(1 << 13);
-	codec2_decode(codec2, outbuf, bits);
-    }
-
-    free(inbuf);
-    free(outbuf);
-    free(bits);
-    codec2_destroy(codec2);
-}
-
-void gpio_init() {
-    RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN; // enable the clock to GPIOD
-    GPIOD->MODER = (1 << 26);            // set pin 13 to be general
-                                         // purpose output
-}
-
-int main(int argc, char *argv[]) {
-    gpio_init();
-    machdep_profile_init ();
-
-    printf("Starting c2demo\n");
-
-    /* File I/O test for profiling or (with #define DUMP)
-       dumping states for optimisation and tiuning */
-
-    c2demo(CODEC2_MODE_1600, "stm_in.raw", "stm_out.raw");
-
-    printf("Starting c2 speed test\n");
-
-    /* Another test of execution speed. Look at PD13 with a
-       oscilliscope.  On time is enc, off is dec */
-
-    c2speedtest(CODEC2_MODE_1600, "stm_in.raw");
-
-    printf("Finished\n");
-
-    return 0;
-}
diff --git a/stm32/src/dac_it.c b/stm32/src/dac_it.c
deleted file mode 100644
index 7f43e2d4..00000000
--- a/stm32/src/dac_it.c
+++ /dev/null
@@ -1,205 +0,0 @@
-/**
-  ******************************************************************************
-  * @file    DMA/DMA_FLASHToRAM/stm32f4xx_it.c
-  * @author  MCD Application Team
-  * @version V1.1.0
-  * @date    18-January-2013
-  * @brief   Main Interrupt Service Routines.
-  *          This file provides template for all exceptions handler and
-  *          peripherals interrupt service routine.
-  ******************************************************************************
-  * @attention
-  *
-  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
-  *
-  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
-  * You may not use this file except in compliance with the License.
-  * You may obtain a copy of the License at:
-  *
-  *        http://www.st.com/software_license_agreement_liberty_v2
-  *
-  * Unless required by applicable law or agreed to in writing, software
-  * distributed under the License is distributed on an "AS IS" BASIS,
-  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  * See the License for the specific language governing permissions and
-  * limitations under the License.
-  *
-  ******************************************************************************
-  */
-int interrupts;
-
-
-/* Includes ------------------------------------------------------------------*/
-#include "dac_it.h"
-
-/** @addtogroup STM32F4xx_StdPeriph_Examples
-  * @{
-  */
-
-/** @addtogroup DMA_FLASHToRAM
-  * @{
-  */
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/******************************************************************************/
-/*            Cortex-M4 Processor Exceptions Handlers                         */
-/******************************************************************************/
-
-/**
-  * @brief   This function handles NMI exception.
-  * @param  None
-  * @retval None
-  */
-void NMI_Handler(void)
-{
-}
-
-/**
-  * @brief  This function handles Hard Fault exception.
-  * @param  None
-  * @retval None
-  */
-void HardFault_Handler(void)
-{
-  /* Go to infinite loop when Hard Fault exception occurs */
-  while (1)
-  {
-  }
-}
-
-/**
-  * @brief  This function handles Memory Manage exception.
-  * @param  None
-  * @retval None
-  */
-void MemManage_Handler(void)
-{
-  /* Go to infinite loop when Memory Manage exception occurs */
-  while (1)
-  {
-  }
-}
-
-/**
-  * @brief  This function handles Bus Fault exception.
-  * @param  None
-  * @retval None
-  */
-void BusFault_Handler(void)
-{
-  /* Go to infinite loop when Bus Fault exception occurs */
-  while (1)
-  {
-  }
-}
-
-/**
-  * @brief  This function handles Usage Fault exception.
-  * @param  None
-  * @retval None
-  */
-void UsageFault_Handler(void)
-{
-  /* Go to infinite loop when Usage Fault exception occurs */
-  while (1)
-  {
-  }
-}
-
-/**
-  * @brief  This function handles SVCall exception.
-  * @param  None
-  * @retval None
-  */
-void SVC_Handler(void)
-{
-}
-
-/**
-  * @brief  This function handles Debug Monitor exception.
-  * @param  None
-  * @retval None
-  */
-void DebugMon_Handler(void)
-{
-}
-
-/**
-  * @brief  This function handles PendSVC exception.
-  * @param  None
-  * @retval None
-  */
-void PendSV_Handler(void)
-{
-}
-
-/**
-  * @brief  This function handles SysTick Handler.
-  * @param  None
-  * @retval None
-  */
-void SysTick_Handler(void)
-{
-}
-
-/******************************************************************************/
-/*                 STM32F4xx Peripherals Interrupt Handlers                   */
-/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
-/*  available peripheral interrupt handler's name please refer to the startup */
-/*  file (startup_stm32f40xx.s/startup_stm32f427x.s).                         */
-/******************************************************************************/
-
-/**
-  * @brief  This function handles DMA Stream interrupt request.
-  * @param  None
-  * @retval None
-  */
-void DMA1_Stream6_IRQHandler(void)
-{
-
-  /* Transfer half empty interrupt */
-
-  if(DMA_GetITStatus(DMA1_Stream6, DMA_IT_HTIF6) != RESET)
-  {
-      /* fill first half from fifo */
-
-      fifo_read(DMA1_Stream6_fifo, dac_buf, DAC_BUF_SZ/2);
-
-      /* Clear DMA Stream Transfer Complete interrupt pending bit */
-
-      DMA_ClearITPendingBit(DMA1_Stream6, DMA_IT_HTIF6);
-
-      interrupts++;
-  }
-
-  /* Transfer complete interrupt */
-
-  if(DMA_GetITStatus(DMA1_Stream6, DMA_IT_TCIF6) != RESET)
-  {
-      /* fill second half from fifo */
-
-      fifo_read(DMA1_Stream6_fifo, &dac_buf[DAC_BUF_SZ/2], DAC_BUF_SZ/2);
-
-      /* Clear DMA Stream Transfer Complete interrupt pending bit */
-
-      DMA_ClearITPendingBit(DMA1_Stream6, DMA_IT_TCIF6);
-
-      interrupts++;
-  }
-}
-
-/**
-  * @}
-  */
-
-/**
-  * @}
-  */
-
-/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
diff --git a/stm32/src/fast_dac_ut.c b/stm32/src/fast_dac_ut.c
deleted file mode 100644
index cce4edbc..00000000
--- a/stm32/src/fast_dac_ut.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: dac_ut.c
-  AUTHOR......: David Rowe
-  DATE CREATED: May 31 2013
-
-  Plays a 500 Hz sine wave sampled at 16 kHz out of PA5 on a Discovery board,
-  or the speaker output of the SM1000.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2013 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <assert.h>
-#include <stdlib.h>
-#include "stm32f4_dacduc.h"
-#include "iir_duc.h"
-#include "stm32f4xx.h"
-#include <stm32f4xx_tim.h>
-#include <stm32f4xx_rcc.h>
-#include "gdb_stdio.h"
-#include "comp.h"
-#include <string.h> 
-//#include "gmsk_test_dat_m4.h"
-#define SINE_SAMPLES  32
-
-
-/* 32 sample sine wave which at Fs=16kHz will be 500Hz.  Note samples
-   are 16 bit 2's complement, the DAC driver convertsto 12 bit
-   unsigned. */
-
-short aWave[] = {4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,
-	4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,4095,0,};
-
-short aSine[] = {1600, 3200, 1601, 0, 1600, 3200, 1601, 0, 1600, 3200, 1601, 0, 1600, 3200, 1601, 0, 1600, 3200, 1601, 0, 1600, 3200, 1601, 0, 1600, 3200, 1600, 0, 1600, 3200, 1601, 0
-};
-
-//Sine at Fs/4
-float f4sine[] = {1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,
-1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,
-1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,
-1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,1,0,-1,0,};
-
-//Intermediate 80k real before tx
-int tx_imm[DUC_N];
-
-//Complex input to chain
-#define COMP_IN_SZ (DUC_48N)
-COMP comp_in[COMP_IN_SZ];
-
-unsigned short outbuf[DAC_DUC_BUF_SZ];
-
-void setup_timer()
-{
-    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
-
-    TIM_TimeBaseInitTypeDef timerInitStructure;
-    timerInitStructure.TIM_Prescaler = 84;
-    timerInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
-    timerInitStructure.TIM_Period = 0x8FFFFFFF;
-    timerInitStructure.TIM_ClockDivision = 0;
-    timerInitStructure.TIM_RepetitionCounter = 0;
-    TIM_TimeBaseInit(TIM2, &timerInitStructure);
-    TIM_Cmd(TIM2, ENABLE);
-}
-
-int main(void) {
-    int tstart,tup,tend,cyc,i;
-
-    memset((void*)outbuf,0,sizeof(short)*DAC_DUC_BUF_SZ);
-    setup_timer();
-    fast_dac_open(2*DAC_DUC_BUF_SZ,2*DAC_BUF_SZ);
-    tstart=tend=tup=cyc=0;
-    //Initalize complex input with signal at zero
-    for(i=0;i<COMP_IN_SZ;i++){
-        comp_in[i].real=1;
-        comp_in[i].imag=0;
-    }
-    while (1) {
-	cyc++;
-        //if(cyc>GMSK_TEST_LEN)
-        //    cyc=0;
-	if(cyc%10000==0){
-                printf("48c80r takes %d uSecs\n",tup-tstart);
-		printf("iir upconvert takes %d uSecs\n",tend-tup);
-	}
-        tstart = TIM_GetCounter(TIM2);
-
-        upconv_48c_80r(comp_in,tx_imm,1);
-
-	tup = TIM_GetCounter(TIM2);
-
-	iir_upconv_fixp(tx_imm,outbuf);
-
-	tend = TIM_GetCounter(TIM2);
-
-        //Sit and spin until we can get more samples into the dac
-	while(dac1_write((short*)outbuf,DAC_DUC_BUF_SZ)<0);
-    }
-
-}
diff --git a/stm32/src/fdmdv_profile.c b/stm32/src/fdmdv_profile.c
deleted file mode 100644
index a663e604..00000000
--- a/stm32/src/fdmdv_profile.c
+++ /dev/null
@@ -1,149 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: fdmdv_profile.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 18 July 2014
-
-  Profiling FDMDV modem operation on the STM32F4.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2014 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <math.h>
-
-#include "stm32f4xx_conf.h"
-#include "stm32f4xx.h"
-#include "gdb_stdio.h"
-#include "codec2_fdmdv.h"
-#include "dump.h"
-#include "sine.h"
-#include "machdep.h"
-
-#ifdef __EMBEDDED__
-#define printf gdb_stdio_printf
-#define fopen gdb_stdio_fopen
-#define fclose gdb_stdio_fclose
-#define fread gdb_stdio_fread
-#define fwrite gdb_stdio_fwrite
-#endif
-
-#define TEST_FRAMES 25
-#define CHANNEL_BUF_SIZE (10*FDMDV_NOM_SAMPLES_PER_FRAME)
-
-static int  channel_count = 0;
-static COMP channel[CHANNEL_BUF_SIZE];
-
-static void channel_in(COMP tx_fdm[], int nout) {
-    int i;
-
-    /* add M_PITCH tx samples to end of buffer */
-
-    assert((channel_count + nout) < CHANNEL_BUF_SIZE);
-    for(i=0; i<nout; i++)
-        channel[channel_count+i] = tx_fdm[i];
-    channel_count += M_PITCH;
-}
-
-static void channel_out(COMP rx_fdm[], int nin) {
-    int i,j;
-
-    /* take nin samples from start of buffer */
-
-    for(i=0; i<nin; i++) {
-        rx_fdm[i] = channel[i];
-    }
-
-    /* shift buffer back */
-
-    for(i=0,j=nin; j<channel_count; i++,j++)
-        channel[i] = channel[j];
-    channel_count -= nin;
-}
-
-int main(int argc, char *argv[]) {
-    struct FDMDV       *fdmdv;
-    int                 bits_per_fdmdv_frame,  bits_per_codec_frame;
-    int                *tx_bits;
-    int                *rx_bits;
-    int                *codec_bits;
-    COMP                tx_fdm[2*FDMDV_NOM_SAMPLES_PER_FRAME];
-    COMP                rx_fdm[FDMDV_NOM_SAMPLES_PER_FRAME];
-    int                 i, j, nin, reliable_sync_bit[2], sync_bit, bit_errors, ntest_bits, test_frame_sync;
-    short              *error_pattern;
-    struct MODEM_STATS  stats;
-    PROFILE_VAR(mod_start, demod_start);
-
-    machdep_profile_init ();
-    fdmdv = fdmdv_create(FDMDV_NC);
-
-    bits_per_fdmdv_frame = fdmdv_bits_per_frame(fdmdv);
-    bits_per_codec_frame = 2*fdmdv_bits_per_frame(fdmdv);
-    tx_bits = (int*)malloc(sizeof(int)*bits_per_codec_frame); assert(tx_bits != NULL);
-    rx_bits = (int*)malloc(sizeof(int)*bits_per_codec_frame); assert(rx_bits != NULL);
-    codec_bits = (int*)malloc(sizeof(int)*bits_per_codec_frame); assert(rx_bits != NULL);
-    error_pattern = (short*)malloc(fdmdv_error_pattern_size(fdmdv)*sizeof(int)); assert(error_pattern != NULL);
-
-    nin = FDMDV_NOM_SAMPLES_PER_FRAME;
-    test_frame_sync = 0;
-
-    for(i=0; i<TEST_FRAMES; i++) {
-	fdmdv_get_test_bits(fdmdv, tx_bits);
-	fdmdv_get_test_bits(fdmdv, &tx_bits[bits_per_fdmdv_frame]);
-
-        PROFILE_SAMPLE(mod_start);
-
-	fdmdv_mod(fdmdv, tx_fdm, tx_bits, &sync_bit);
-	assert(sync_bit == 1);
-	fdmdv_mod(fdmdv, &tx_fdm[FDMDV_NOM_SAMPLES_PER_FRAME], &tx_bits[bits_per_fdmdv_frame], &sync_bit);
-	assert(sync_bit == 0);
-        channel_in(tx_fdm, 2*FDMDV_NOM_SAMPLES_PER_FRAME);
-
-        PROFILE_SAMPLE_AND_LOG(demod_start, mod_start, "  mod");
-
-        for(j=0; j<2; j++) {
-            channel_out(rx_fdm, nin);
-            fdmdv_demod(fdmdv, rx_bits, &reliable_sync_bit[j], rx_fdm, &nin);
-            if (reliable_sync_bit[j] == 0)
-                memcpy(codec_bits, rx_bits, bits_per_fdmdv_frame*sizeof(int));
-            else {
-                memcpy(&codec_bits[bits_per_fdmdv_frame], rx_bits, bits_per_fdmdv_frame*sizeof(int));
-                fdmdv_put_test_bits(fdmdv, &test_frame_sync, error_pattern, &bit_errors, &ntest_bits, codec_bits);
-                fdmdv_put_test_bits(fdmdv, &test_frame_sync, error_pattern, &bit_errors, &ntest_bits, &codec_bits[bits_per_fdmdv_frame]);
-            }
-        }
-        PROFILE_SAMPLE_AND_LOG2(demod_start, "  demod");
-        PROFILE_SAMPLE_AND_LOG2(mod_start, "  mod & demod");
-
-        fdmdv_get_demod_stats(fdmdv, &stats);
-
-        printf("frame: %d sync: %d reliable_sync_bit: %d %d SNR: %3.2f test_frame_sync: %d\n",
-               i, stats.sync, reliable_sync_bit[0], reliable_sync_bit[1], (double)stats.snr_est,
-               test_frame_sync);
-        machdep_profile_print_logged_samples();
-    }
-
-    fdmdv_destroy(fdmdv);
-
-    return 0;
-}
-
diff --git a/stm32/src/init.c b/stm32/src/init.c
deleted file mode 100644
index 527141d4..00000000
--- a/stm32/src/init.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/*
- * Dummy function to avoid compiler error
- */
-void _init() {
-
-}
-void _fini() {
-
-}
-
diff --git a/stm32/src/mco_ut.c b/stm32/src/mco_ut.c
deleted file mode 100644
index 7ef7e7ac..00000000
--- a/stm32/src/mco_ut.c
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
-     mco_ut.c
-     
-     Slightly modified version of : 
-       http://stm32f4-discovery.net/2014/10/library-40-output-clocks-stm32f4/
- 
-     Outputs the HSI oscillator on MCO1, pin PA8, which is SCL3 on the SM2000, can
-     be probed around R124.  Used to track down a USB boot loader bug, suspect the
-     HSI on this particular STM32F407 is out so the boot loader is failing on USB
-     discovery/enumeration and forcing a reset.
-*/
-
-/* Include core modules */
-#include "stm32f4xx.h"
-/* Include my libraries here */
-#include "defines.h"
-#include "tm_stm32f4_mco_output.h"
- 
-int main(void) {
-    /* Initialize system */
-    SystemInit();
- 
-    /* Initialize MCO1 output, pin PA8 */
-    TM_MCOOUTPUT_InitMCO1();
-    
-    /* Initialize MCO2 output, pin PC9 */
-    TM_MCOOUTPUT_InitMCO2();
-    
-    /* Set MCO1 output = HSI with prescaler 2 = 16MHz / 2 = 8MHz*/
-    TM_MCOOUTPUT_SetOutput1(TM_MCOOUTPUT1_Source_HSI, TM_MCOOUTPUT_Prescaler_2);
-    
-    /* Set MCO2 output = SYSCLK / 4 */
-    TM_MCOOUTPUT_SetOutput2(TM_MCOOUTPUT2_Source_SYSCLK, TM_MCOOUTPUT_Prescaler_4);
- 
-    while (1) {
-        
-    }
-}
-
diff --git a/stm32/src/new_i2c.c b/stm32/src/new_i2c.c
deleted file mode 100644
index abc5170b..00000000
--- a/stm32/src/new_i2c.c
+++ /dev/null
@@ -1,430 +0,0 @@
-/* 
- * File:   new_i2c.h
- * Author: leon (zs6lmg@gmail.com or leon@lrlabs.com)
- *
- * Created on March 17, 2016, 6:09 PM
- * 
- * GNU license apply.
- * 
- */
-
-
-/*
-  Copyright (C) 2016 Leon
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "stm32f4xx.h"
-#include "stm32f4xx_conf.h"
-#include "new_i2c.h"
-//#include "cds_i2s.h"
-
-//
-//
-//
-#define CONCAT_(x,y) x##y
-#define CONCAT(x,y) CONCAT_(x,y)
-//
-//
-//
-
-//
-//
-//
-//
-#define I2C_SDA_AFPIN_ID CONCAT(GPIO_PinSource,I2C_DX_SDA)
-#define I2C_SCK_AFPIN_ID CONCAT(GPIO_PinSource,I2C_DX_SCK)
-#define I2C_SDA_PIN_ID CONCAT(GPIO_Pin_,I2C_DX_SDA)
-#define I2C_SCK_PIN_ID CONCAT(GPIO_Pin_,I2C_DX_SCK)
-
-
-/* definition to expand macro then apply to pragma message */
-// Verify that my shortcuts are actually working
-//#define VALUE_TO_STRING(x) #x
-//#define VALUE(x) VALUE_TO_STRING(x)
-//
-//#define VAR_NAME_VALUE(var) #var "="  VALUE(var)
-//#pragma message(VAR_NAME_VALUE(I2C_SCK_AFPIN_ID))
-//#pragma message(VAR_NAME_VALUE(I2C_SDA_AFPIN_ID))
-
-/*
- * @brief Setup I2C interface pins
- * PB6 is SCL
- * PB9 is SDA
- * 
- * @param       None
- * 
- * @return      None
- */
-void I2C_Setup(void) {
-    I2C_InitTypeDef I2C_Init_S;
-    GPIO_InitTypeDef GPIO_Init_P;
-    // setup the clock for the GPIO device
-    RCC_AHB1PeriphClockCmd(I2C_DX_CLK_SCK|I2C_DX_CLK_SDA, ENABLE);
-    // enable clock for the i2c device
-#if I2C_D1
-    RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
-    // Performing a Reset
-    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
-    //RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
-    //RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
-#elif I2C_D3
-    RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C3, ENABLE);
-#else
-#error "Problem on I2C"
-#endif
-    // setup the pins
-    GPIO_Init_P.GPIO_Pin=I2C_SDA_PIN_ID;
-    GPIO_Init_P.GPIO_Mode=GPIO_Mode_AF;
-    GPIO_Init_P.GPIO_Speed=GPIO_Speed_50MHz;
-    GPIO_Init_P.GPIO_OType=GPIO_OType_OD;
-    GPIO_Init_P.GPIO_PuPd=GPIO_PuPd_NOPULL;
-    GPIO_Init(I2C_DX_P_SDA, &GPIO_Init_P);
-    //
-    //
-    GPIO_Init_P.GPIO_Pin=I2C_SCK_PIN_ID;
-    GPIO_Init(I2C_DX_P_SCK, &GPIO_Init_P);
-    // assign alternate functions
-#if I2C_D1
-    GPIO_PinAFConfig(I2C_DX_P_SDA, I2C_SDA_AFPIN_ID, GPIO_AF_I2C1);
-    GPIO_PinAFConfig(I2C_DX_P_SCK, I2C_SCK_AFPIN_ID, GPIO_AF_I2C1);
-#elif I2C_D3
-    GPIO_PinAFConfig(I2C_DX_P_SDA, I2C_SDA_AFPIN_ID, GPIO_AF_I2C3);
-    GPIO_PinAFConfig(I2C_DX_P_SCK, I2C_SCK_AFPIN_ID, GPIO_AF_I2C3);
-#else
-#error "Device not defined"
-#endif
-    //
-    I2C_Cmd(I2C_DEVICE, DISABLE);
-    I2C_DeInit(I2C_DEVICE);
-    //
-    //
-    I2C_Init_S.I2C_Mode=I2C_Mode_I2C;
-    I2C_Init_S.I2C_DutyCycle=I2C_DutyCycle_2;
-    I2C_Init_S.I2C_Ack=I2C_Ack_Enable;
-    I2C_Init_S.I2C_OwnAddress1=0x00;
-    I2C_Init_S.I2C_AcknowledgedAddress=I2C_AcknowledgedAddress_7bit;
-    I2C_Init_S.I2C_ClockSpeed=I2C_SPEED;
-    I2C_Cmd(I2C_DEVICE, ENABLE);
-    I2C_Init(I2C_DEVICE, &I2C_Init_S);
-}
-
-
-
-uint32_t I2C_timeout(uint32_t retval) {
-    I2C_GenerateSTOP(I2C_DEVICE, ENABLE);
-    I2C_SoftwareResetCmd(I2C_DEVICE, ENABLE);
-    I2C_SoftwareResetCmd(I2C_DEVICE, DISABLE);
-    I2C_DeInit(I2C_DEVICE);
-    I2C_Setup();
-    return(retval);
-}
-
-
-
-/**
- * @brief  Writes a Byte to a given register through the control interface (I2C)
- * @param  Addr: I2C address to write to.
- * @param  Register: Register inside device to write to.
- * @param  Value: the Byte value to be written into destination register.
- * @return 0 all ok.
- *  0x101 i2c busy.
- *  0x102 master mode not selected.
- *  0x103 master transmitter mode.
- *  0x104 send data failed.
- *  0x105 no reply from device.
- */
-uint32_t I2C_NewWriteRegister(uint8_t Addr, uint8_t Register, uint8_t Value) {
-    uint32_t result = 0;
-
-    /* check if bus is busy */
-    __IO uint32_t Timeout = I2C_LTIMEOUT;
-    while (I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_BUSY )) {
-        if ((Timeout--) == 0) return 0x101;
-    }
-    I2C_GenerateSTART(I2C_DEVICE, ENABLE);
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_CheckEvent(I2C_DEVICE,I2C_EVENT_MASTER_MODE_SELECT)) {
-        if ((Timeout--) == 0) return 0x102;
-    }
-    I2C_Send7bitAddress(I2C_DEVICE,Addr,I2C_Direction_Transmitter);
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_CheckEvent(I2C_DEVICE,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
-        if ((Timeout--) == 0) return 0x103;
-    }
-    I2C_SendData(I2C_DEVICE, Register);
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_CheckEvent(I2C_DEVICE,I2C_EVENT_MASTER_BYTE_TRANSMITTING)) {
-        if ((Timeout--) == 0) return 0x104;
-    }
-    I2C_SendData(I2C_DEVICE, Value);
-    // Wait for reply
-    Timeout = I2C_LTIMEOUT;
-    while (!I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_BTF)) {
-        if ((Timeout--) == 0) return 0x105;
-    }
-    I2C_GenerateSTOP(I2C_DEVICE, ENABLE);
-    return result;
-}
-
-/**
- * @brief  Writes more than 1 bytes to a given register through the control interface (I2C)
- * @param  Addr: I2C address to write to.
- * @param  Register: Register inside device to write to.
- * @param  Value: the Byte(s) to be written into destination register.
- * @param  N: Number of byte(s) to write
- * @return 0 all ok.
- *  0x101 i2c busy.
- *  0x102 master mode not selected.
- *  0x103 master transmitter mode.
- *  0x104 send data failed.
- *  0x105 no reply from device.
- */
-uint32_t I2C_NewWriteRegisterN(uint8_t Addr, uint8_t Register, uint8_t *Value, uint8_t N) {
-    uint32_t result = 0;
-
-    /* check if bus is busy */
-    __IO uint8_t i;
-    __IO uint32_t Timeout = I2C_LTIMEOUT;
-    while (I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_BUSY )) {
-        if ((Timeout--) == 0) return 0x101;
-    }
-    I2C_GenerateSTART(I2C_DEVICE, ENABLE);
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_CheckEvent(I2C_DEVICE,I2C_EVENT_MASTER_MODE_SELECT)) {
-        if ((Timeout--) == 0) return 0x102;
-    }
-    I2C_Send7bitAddress(I2C_DEVICE,Addr,I2C_Direction_Transmitter);
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_CheckEvent(I2C_DEVICE,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
-        if ((Timeout--) == 0) return 0x103;
-    }
-    I2C_SendData(I2C_DEVICE, Register);
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_CheckEvent(I2C_DEVICE,I2C_EVENT_MASTER_BYTE_TRANSMITTING)) {
-        if ((Timeout--) == 0) return 0x104;
-    }
-    for (i = 0; i < N; i++) {
-        I2C_SendData(I2C_DEVICE, *(Value++));
-        // Wait for reply
-        Timeout = I2C_LTIMEOUT;
-        while (!I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_BTF)) {
-            if ((Timeout--) == 0) return 0x105;
-        }
-    }
-    I2C_GenerateSTOP(I2C_DEVICE, ENABLE);
-    return result;
-}
-
-
-
-/**
- * @brief  Reads a Byte to a given register via I2C
- * @param  Addr: I2C address.
- * @param  Register: Register inside device to read.
- * @return value read.
- *  0x101 i2c busy.
- *  0x102 master mode not selected.
- *  0x103 master transmitter mode.
- *  0x104 send data failed.
- *  0x105 no reply from device.
- *  0x106 direction receive.
- *  0x107 data register not empty.
- *  0x108 waiting data.
- */
-uint32_t I2C_NewReadRegister(uint8_t Addr,uint8_t Register) {
-    uint32_t result = 0;
-    __IO uint32_t Timeout = I2C_LTIMEOUT;
-    while (I2C_GetFlagStatus(I2C_DEVICE,I2C_FLAG_BUSY)) {
-        if ((Timeout--) == 0) return I2C_timeout(0x101);
-    }
-    I2C_GenerateSTART(I2C_DEVICE, ENABLE);
-#if (I2Cmodel == 1)
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_GetFlagStatus(I2C_DEVICE,I2C_FLAG_SB)) {
-        if ((Timeout--) == 0) return I2C_timeout(0x102);
-    }
-    I2C_AcknowledgeConfig(I2C_DEVICE, DISABLE);
-    I2C_Send7bitAddress(I2C_DEVICE, Addr, I2C_Direction_Transmitter);
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_ADDR)) {
-        if ((Timeout--) == 0) return I2C_timeout(0x103);
-    }
-    (void) I2C_DEVICE->SR2;
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_TXE)) {
-        if ((Timeout--) == 0) return I2C_timeout(0x104);
-    }
-    I2C_SendData(I2C_DEVICE, Register);
-    Timeout = I2C_STIMEOUT;
-    while ( (!I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_TXE)) ||
-            (!I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_BTF))
-          )  {
-        if ((Timeout--) == 0) return I2C_timeout(0x105);
-    }
-    I2C_GenerateSTART(I2C_DEVICE, ENABLE);
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_SB)) {
-        if ((Timeout--) == 0) return I2C_timeout(0x106);
-    }
-    I2C_Send7bitAddress(I2C_DEVICE, Addr, I2C_Direction_Receiver);
-    Timeout = I2C_STIMEOUT;
-    while (I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_ADDR) == RESET) {
-        if ((Timeout--) == 0) return I2C_timeout(0x107);
-    }
-    (void) I2C_DEVICE->SR2;
-    while (!I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_RXNE)) {
-        if ((Timeout--) == 0) return I2C_timeout(0x108);
-    }
-    I2C_GenerateSTOP(I2C_DEVICE, ENABLE);
-    Timeout = I2C_STIMEOUT;
-    result = I2C_ReceiveData(I2C_DEVICE );
-    Timeout = I2C_STIMEOUT;
-    while (I2C_DEVICE ->CR1 & I2C_CR1_STOP ) {
-        if ((Timeout--) == 0) return I2C_timeout(0x109);
-    }
-    I2C_AcknowledgeConfig(I2C_DEVICE, ENABLE);
-    I2C_ClearFlag(I2C_DEVICE, I2C_FLAG_AF );
-#else
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_CheckEvent(I2C_DEVICE,I2C_EVENT_MASTER_MODE_SELECT)) {
-        if ((Timeout--) == 0) return 0x102;
-    }
-    I2C_Send7bitAddress(I2C_DEVICE,Addr,I2C_Direction_Transmitter);
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_CheckEvent(I2C_DEVICE,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
-        if ((Timeout--) == 0) return 0x103;
-    }
-    I2C_SendData(I2C_DEVICE, Register);
-    Timeout = I2C_STIMEOUT;
-    while (I2C_GetFlagStatus(I2C_DEVICE,I2C_FLAG_BTF) == RESET) {
-            if ((Timeout--) == 0) return 0x104;
-    }
-    I2C_GenerateSTART(I2C_DEVICE, ENABLE);
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_CheckEvent(I2C_DEVICE,I2C_EVENT_MASTER_MODE_SELECT)) {
-        if ((Timeout--) == 0) return 0x105;
-    }
-    I2C_Send7bitAddress(I2C_DEVICE,Addr,I2C_Direction_Receiver);
-    Timeout = I2C_STIMEOUT;
-    while (I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_ADDR) == RESET) {
-        if ((Timeout--) == 0) return 0x106;
-    }
-    I2C_AcknowledgeConfig(I2C_DEVICE,DISABLE);
-    (void) I2C_DEVICE->SR2;
-    I2C_GenerateSTOP(I2C_DEVICE, ENABLE);
-    Timeout = I2C_STIMEOUT;
-    while (I2C_GetFlagStatus(I2C_DEVICE,I2C_FLAG_RXNE) == RESET) {
-        if ((Timeout--) == 0) return 0x107;
-    }
-    result = I2C_ReceiveData(I2C_DEVICE );
-    Timeout = I2C_STIMEOUT;
-    while (I2C_DEVICE ->CR1 & I2C_CR1_STOP ) {
-        if ((Timeout--) == 0) return 0x108;
-    }
-    I2C_AcknowledgeConfig(I2C_DEVICE, ENABLE);
-    I2C_ClearFlag(I2C_DEVICE, I2C_FLAG_AF );
-#endif
-    return result;
-}
-
-/**
- * @brief  Reads more than one byte from a given register via I2C
- * @param  Addr: I2C address.
- * @param  Register: Register inside device to read.
- * @return value read.
- *  0x101 i2c busy.
- *  0x102 master mode not selected.
- *  0x103 master transmitter mode.
- *  0x104 send data failed.
- *  0x105 no reply from device.
- *  0x106 direction receive.
- *  0x107 data register not empty.
- *  0x108 waiting data.
- */
-uint32_t I2C_NewReadRegisterN(uint8_t Addr,uint8_t Register,uint8_t *buffer, uint8_t N) {
-    uint32_t result = 0;
-    uint8_t     cnt;
-    __IO uint32_t Timeout = I2C_LTIMEOUT;
-    if ( (N==0)||(N>64) ) return 0x109;
-    while (I2C_GetFlagStatus(I2C_DEVICE,I2C_FLAG_BUSY)) {
-        if ((Timeout--) == 0) return 0x101;
-    }
-    I2C_GenerateSTART(I2C_DEVICE, ENABLE);
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_CheckEvent(I2C_DEVICE,I2C_EVENT_MASTER_MODE_SELECT)) {
-        if ((Timeout--) == 0) return 0x102;
-    }
-    if(N==1) {
-        // ACK disable
-        I2C_AcknowledgeConfig(I2C_DEVICE, DISABLE);
-    } else {
-        // ACK enable
-        I2C_AcknowledgeConfig(I2C_DEVICE, ENABLE);
-    }
-    I2C_Send7bitAddress(I2C_DEVICE,Addr,I2C_Direction_Transmitter);
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_CheckEvent(I2C_DEVICE,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
-        if ((Timeout--) == 0) return 0x103;
-    }
-    (void) I2C_DEVICE->SR2;
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_TXE)) {
-        if ((Timeout--) == 0) return I2C_timeout(0x104);
-    }
-    I2C_SendData(I2C_DEVICE, Register);
-    Timeout = I2C_STIMEOUT;
-    while ( (!I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_TXE)) ||
-            (!I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_BTF))
-          )  {
-        if ((Timeout--) == 0) return I2C_timeout(0x105);
-    }
-    I2C_GenerateSTART(I2C_DEVICE, ENABLE);
-    Timeout = I2C_STIMEOUT;
-    while (!I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_SB)) {
-        if ((Timeout--) == 0) return I2C_timeout(0x106);
-    }
-    I2C_Send7bitAddress(I2C_DEVICE, Addr, I2C_Direction_Receiver);
-    Timeout = I2C_STIMEOUT;
-    while (I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_ADDR) == RESET) {
-        if ((Timeout--) == 0) return I2C_timeout(0x107);
-    }
-    (void) I2C_DEVICE->SR2;
-    for (cnt=0; cnt<N; cnt++) {
-        if((cnt+1) >= N) {
-            // ACK disable
-            I2C_AcknowledgeConfig(I2C_DEVICE, DISABLE);
-            // Stop-Sequenz
-            I2C_GenerateSTOP(I2C_DEVICE, ENABLE);
-        }
-        Timeout = I2C_STIMEOUT;
-        while (!I2C_GetFlagStatus(I2C_DEVICE, I2C_FLAG_RXNE)) {
-            if ((Timeout--) == 0) return I2C_timeout(0x108);
-        }
-        result=I2C_ReceiveData(I2C_DEVICE);
-        Timeout = I2C_STIMEOUT;
-        while (I2C_DEVICE ->CR1 & I2C_CR1_STOP ) {
-            if ((Timeout--) == 0) return I2C_timeout(0x109);
-        }
-        *buffer=(uint8_t)(result & 0xff);
-        buffer++;
-        Timeout = I2C_STIMEOUT;
-    }
-    I2C_AcknowledgeConfig(I2C_DEVICE, ENABLE);
-    //I2C_ClearFlag(I2C_DEVICE, I2C_FLAG_AF );
-    if (result<0x100) result=0;
-    return result;
-}
-
diff --git a/stm32/src/sine.c b/stm32/src/sine.c
deleted file mode 100644
index be4df00a..00000000
--- a/stm32/src/sine.c
+++ /dev/null
@@ -1,648 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: sine.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 19/8/2010
-
-  Sinusoidal analysis and synthesis functions.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 1990-2010 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-/*---------------------------------------------------------------------------*\
-
-				INCLUDES
-
-\*---------------------------------------------------------------------------*/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <math.h>
-
-#include "defines.h"
-#include "sine.h"
-#include "kiss_fft.h"
-
-#define HPF_BETA 0.125
-
-/*---------------------------------------------------------------------------*\
-
-				HEADERS
-
-\*---------------------------------------------------------------------------*/
-
-void hs_pitch_refinement(MODEL *model, COMP Sw[], float pmin, float pmax,
-			 float pstep);
-
-/*---------------------------------------------------------------------------*\
-
-				FUNCTIONS
-
-\*---------------------------------------------------------------------------*/
-
-/*---------------------------------------------------------------------------*\
-
-  FUNCTION....: make_analysis_window
-  AUTHOR......: David Rowe
-  DATE CREATED: 11/5/94
-
-  Init function that generates the time domain analysis window and it's DFT.
-
-\*---------------------------------------------------------------------------*/
-
-void make_analysis_window(kiss_fft_cfg fft_fwd_cfg, float w[], COMP W[])
-{
-  float m;
-  COMP  wshift[FFT_ENC];
-  COMP  temp;
-  int   i,j;
-
-  /*
-     Generate Hamming window centered on M-sample pitch analysis window
-
-  0            M/2           M-1
-  |-------------|-------------|
-        |-------|-------|
-            NW samples
-
-     All our analysis/synthsis is centred on the M/2 sample.
-  */
-
-  m = 0.0;
-  for(i=0; i<M/2-NW/2; i++)
-    w[i] = 0.0;
-  for(i=M/2-NW/2,j=0; i<M/2+NW/2; i++,j++) {
-    w[i] = 0.5 - 0.5*cosf(TWO_PI*j/(NW-1));
-    m += w[i]*w[i];
-  }
-  for(i=M/2+NW/2; i<M; i++)
-    w[i] = 0.0;
-
-  /* Normalise - makes freq domain amplitude estimation straight
-     forward */
-
-  m = 1.0/sqrtf(m*FFT_ENC);
-  for(i=0; i<M; i++) {
-    w[i] *= m;
-  }
-
-  /*
-     Generate DFT of analysis window, used for later processing.  Note
-     we modulo FFT_ENC shift the time domain window w[], this makes the
-     imaginary part of the DFT W[] equal to zero as the shifted w[] is
-     even about the n=0 time axis if NW is odd.  Having the imag part
-     of the DFT W[] makes computation easier.
-
-     0                      FFT_ENC-1
-     |-------------------------|
-
-      ----\               /----
-           \             /
-            \           /          <- shifted version of window w[n]
-             \         /
-              \       /
-               -------
-
-     |---------|     |---------|
-       NW/2              NW/2
-  */
-
-  for(i=0; i<FFT_ENC; i++) {
-    wshift[i].real = 0.0;
-    wshift[i].imag = 0.0;
-  }
-  for(i=0; i<NW/2; i++)
-    wshift[i].real = w[i+M/2];
-  for(i=FFT_ENC-NW/2,j=M/2-NW/2; i<FFT_ENC; i++,j++)
-   wshift[i].real = w[j];
-
-  kiss_fft(fft_fwd_cfg, (kiss_fft_cpx *)wshift, (kiss_fft_cpx *)W);
-
-  /*
-      Re-arrange W[] to be symmetrical about FFT_ENC/2.  Makes later
-      analysis convenient.
-
-   Before:
-
-
-     0                 FFT_ENC-1
-     |----------|---------|
-     __                   _
-       \                 /
-        \_______________/
-
-   After:
-
-     0                 FFT_ENC-1
-     |----------|---------|
-               ___
-              /   \
-     ________/     \_______
-
-  */
-
-
-  for(i=0; i<FFT_ENC/2; i++) {
-    temp.real = W[i].real;
-    temp.imag = W[i].imag;
-    W[i].real = W[i+FFT_ENC/2].real;
-    W[i].imag = W[i+FFT_ENC/2].imag;
-    W[i+FFT_ENC/2].real = temp.real;
-    W[i+FFT_ENC/2].imag = temp.imag;
-  }
-
-}
-
-/*---------------------------------------------------------------------------*\
-
-  FUNCTION....: hpf
-  AUTHOR......: David Rowe
-  DATE CREATED: 16 Nov 2010
-
-  High pass filter with a -3dB point of about 160Hz.
-
-    y(n) = -HPF_BETA*y(n-1) + x(n) - x(n-1)
-
-\*---------------------------------------------------------------------------*/
-
-float hpf(float x, float states[])
-{
-    states[0] += -HPF_BETA*states[0] + x - states[1];
-    states[1] = x;
-
-    return states[0];
-}
-
-/*---------------------------------------------------------------------------*\
-
-  FUNCTION....: dft_speech
-  AUTHOR......: David Rowe
-  DATE CREATED: 27/5/94
-
-  Finds the DFT of the current speech input speech frame.
-
-\*---------------------------------------------------------------------------*/
-
-void dft_speech(kiss_fft_cfg fft_fwd_cfg, COMP Sw[], float Sn[], float w[])
-{
-  int  i;
-  COMP sw[FFT_ENC];
-
-  for(i=0; i<FFT_ENC; i++) {
-    sw[i].real = 0.0;
-    sw[i].imag = 0.0;
-  }
-
-  /* Centre analysis window on time axis, we need to arrange input
-     to FFT this way to make FFT phases correct */
-
-  /* move 2nd half to start of FFT input vector */
-
-  for(i=0; i<NW/2; i++)
-    sw[i].real = Sn[i+M/2]*w[i+M/2];
-
-  /* move 1st half to end of FFT input vector */
-
-  for(i=0; i<NW/2; i++)
-    sw[FFT_ENC-NW/2+i].real = Sn[i+M/2-NW/2]*w[i+M/2-NW/2];
-
-  kiss_fft(fft_fwd_cfg, (kiss_fft_cpx *)sw, (kiss_fft_cpx *)Sw);
-}
-
-/*---------------------------------------------------------------------------*\
-
-  FUNCTION....: two_stage_pitch_refinement
-  AUTHOR......: David Rowe
-  DATE CREATED: 27/5/94
-
-  Refines the current pitch estimate using the harmonic sum pitch
-  estimation technique.
-
-\*---------------------------------------------------------------------------*/
-
-void two_stage_pitch_refinement(MODEL *model, COMP Sw[])
-{
-  float pmin,pmax,pstep;	/* pitch refinment minimum, maximum and step */
-
-  /* Coarse refinement */
-
-  pmax = TWO_PI/model->Wo + 5;
-  pmin = TWO_PI/model->Wo - 5;
-  pstep = 1.0;
-  hs_pitch_refinement(model,Sw,pmin,pmax,pstep);
-
-  /* Fine refinement */
-
-  pmax = TWO_PI/model->Wo + 1;
-  pmin = TWO_PI/model->Wo - 1;
-  pstep = 0.25;
-  hs_pitch_refinement(model,Sw,pmin,pmax,pstep);
-
-  /* Limit range */
-
-  if (model->Wo < TWO_PI/P_MAX)
-    model->Wo = TWO_PI/P_MAX;
-  if (model->Wo > TWO_PI/P_MIN)
-    model->Wo = TWO_PI/P_MIN;
-
-  model->L = floor(PI/model->Wo);
-}
-
-/*---------------------------------------------------------------------------*\
-
- FUNCTION....: hs_pitch_refinement
- AUTHOR......: David Rowe
- DATE CREATED: 27/5/94
-
- Harmonic sum pitch refinement function.
-
- pmin   pitch search range minimum
- pmax	pitch search range maximum
- step   pitch search step size
- model	current pitch estimate in model.Wo
-
- model 	refined pitch estimate in model.Wo
-
-\*---------------------------------------------------------------------------*/
-
-void hs_pitch_refinement(MODEL *model, COMP Sw[], float pmin, float pmax, float pstep)
-{
-  int m;		/* loop variable */
-  int b;		/* bin for current harmonic centre */
-  float E;		/* energy for current pitch*/
-  float Wo;		/* current "test" fundamental freq. */
-  float Wom;		/* Wo that maximises E */
-  float Em;		/* mamimum energy */
-  float r, one_on_r;	/* number of rads/bin */
-  float p;		/* current pitch */
-
-  /* Initialisation */
-
-  model->L = PI/model->Wo;	/* use initial pitch est. for L */
-  Wom = model->Wo;
-  Em = 0.0;
-  r = TWO_PI/FFT_ENC;
-  one_on_r = 1.0/r;
-
-  /* Determine harmonic sum for a range of Wo values */
-
-  for(p=pmin; p<=pmax; p+=pstep) {
-    E = 0.0;
-    Wo = TWO_PI/p;
-
-    /* Sum harmonic magnitudes */
-    for(m=1; m<=model->L; m++) {
-        b = (int)(m*Wo*one_on_r + 0.5);
-        E += Sw[b].real*Sw[b].real + Sw[b].imag*Sw[b].imag;
-    }
-    /* Compare to see if this is a maximum */
-
-    if (E > Em) {
-      Em = E;
-      Wom = Wo;
-    }
-  }
-
-  model->Wo = Wom;
-}
-
-/*---------------------------------------------------------------------------*\
-
-  FUNCTION....: estimate_amplitudes
-  AUTHOR......: David Rowe
-  DATE CREATED: 27/5/94
-
-  Estimates the complex amplitudes of the harmonics.
-
-\*---------------------------------------------------------------------------*/
-
-void estimate_amplitudes(MODEL *model, COMP Sw[], COMP W[], int est_phase)
-{
-  int   i,m;		/* loop variables */
-  int   am,bm;		/* bounds of current harmonic */
-  int   b;		/* DFT bin of centre of current harmonic */
-  float den;		/* denominator of amplitude expression */
-  float r, one_on_r;	/* number of rads/bin */
-  int   offset;
-  COMP  Am;
-
-  r = TWO_PI/FFT_ENC;
-  one_on_r = 1.0/r;
-
-  for(m=1; m<=model->L; m++) {
-    den = 0.0;
-    am = (int)((m - 0.5)*model->Wo*one_on_r + 0.5);
-    bm = (int)((m + 0.5)*model->Wo*one_on_r + 0.5);
-    b = (int)(m*model->Wo/r + 0.5);
-
-    /* Estimate ampltude of harmonic */
-
-    den = 0.0;
-    Am.real = Am.imag = 0.0;
-    offset = FFT_ENC/2 - (int)(m*model->Wo*one_on_r + 0.5);
-    for(i=am; i<bm; i++) {
-      den += Sw[i].real*Sw[i].real + Sw[i].imag*Sw[i].imag;
-      Am.real += Sw[i].real*W[i + offset].real;
-      Am.imag += Sw[i].imag*W[i + offset].real;
-    }
-
-    model->A[m] = sqrtf(den);
-
-    if (est_phase) {
-
-        /* Estimate phase of harmonic, this is expensive in CPU for
-           embedded devicesso we make it an option */
-
-        model->phi[m] = atan2(Sw[b].imag,Sw[b].real);
-    }
-  }
-}
-
-/*---------------------------------------------------------------------------*\
-
-  est_voicing_mbe()
-
-  Returns the error of the MBE cost function for a fiven F0.
-
-  Note: I think a lot of the operations below can be simplified as
-  W[].imag = 0 and has been normalised such that den always equals 1.
-
-\*---------------------------------------------------------------------------*/
-
-float est_voicing_mbe(
-    MODEL *model,
-    COMP   Sw[],
-    COMP   W[],
-    COMP   Sw_[],         /* DFT of all voiced synthesised signal  */
-                          /* useful for debugging/dump file        */
-    COMP   Ew[],          /* DFT of error                          */
-    float prev_Wo)
-{
-    int   i,l,al,bl,m;    /* loop variables */
-    COMP  Am;             /* amplitude sample for this band */
-    int   offset;         /* centers Hw[] about current harmonic */
-    float den;            /* denominator of Am expression */
-    float error;          /* accumulated error between original and synthesised */
-    float Wo;
-    float sig, snr;
-    float elow, ehigh, eratio;
-    float sixty;
-
-    sig = 1E-4;
-    for(l=1; l<=model->L/4; l++) {
-	sig += model->A[l]*model->A[l];
-    }
-    for(i=0; i<FFT_ENC; i++) {
-	Sw_[i].real = 0.0;
-	Sw_[i].imag = 0.0;
-	Ew[i].real = 0.0;
-	Ew[i].imag = 0.0;
-    }
-
-    Wo = model->Wo;
-    error = 1E-4;
-
-    /* Just test across the harmonics in the first 1000 Hz (L/4) */
-
-    for(l=1; l<=model->L/4; l++) {
-	Am.real = 0.0;
-	Am.imag = 0.0;
-	den = 0.0;
-	al = ceil((l - 0.5)*Wo*FFT_ENC/TWO_PI);
-	bl = ceil((l + 0.5)*Wo*FFT_ENC/TWO_PI);
-
-	/* Estimate amplitude of harmonic assuming harmonic is totally voiced */
-
-        offset = FFT_ENC/2 - l*Wo*FFT_ENC/TWO_PI + 0.5;
-	for(m=al; m<bl; m++) {
-	    Am.real += Sw[m].real*W[offset+m].real;
-	    Am.imag += Sw[m].imag*W[offset+m].real;
-	    den += W[offset+m].real*W[offset+m].real;
-        }
-
-        Am.real = Am.real/den;
-        Am.imag = Am.imag/den;
-
-        /* Determine error between estimated harmonic and original */
-
-        offset = FFT_ENC/2 - l*Wo*FFT_ENC/TWO_PI + 0.5;
-        for(m=al; m<bl; m++) {
-	    Sw_[m].real = Am.real*W[offset+m].real;
-	    Sw_[m].imag = Am.imag*W[offset+m].real;
-	    Ew[m].real = Sw[m].real - Sw_[m].real;
-	    Ew[m].imag = Sw[m].imag - Sw_[m].imag;
-	    error += Ew[m].real*Ew[m].real;
-	    error += Ew[m].imag*Ew[m].imag;
-	}
-    }
-
-    snr = 10.0*log10f(sig/error);
-    if (snr > V_THRESH)
-	model->voiced = 1;
-    else
-	model->voiced = 0;
-
-    /* post processing, helps clean up some voicing errors ------------------*/
-
-    /*
-       Determine the ratio of low freqency to high frequency energy,
-       voiced speech tends to be dominated by low frequency energy,
-       unvoiced by high frequency. This measure can be used to
-       determine if we have made any gross errors.
-    */
-
-    elow = ehigh = 1E-4;
-    for(l=1; l<=model->L/2; l++) {
-	elow += model->A[l]*model->A[l];
-    }
-    for(l=model->L/2; l<=model->L; l++) {
-	ehigh += model->A[l]*model->A[l];
-    }
-    eratio = 10.0*log10f(elow/ehigh);
-
-    /* Look for Type 1 errors, strongly V speech that has been
-       accidentally declared UV */
-
-    if (model->voiced == 0)
-	if (eratio > 10.0)
-	    model->voiced = 1;
-
-    /* Look for Type 2 errors, strongly UV speech that has been
-       accidentally declared V */
-
-    if (model->voiced == 1) {
-	if (eratio < -10.0)
-	    model->voiced = 0;
-
-	/* A common source of Type 2 errors is the pitch estimator
-	   gives a low (50Hz) estimate for UV speech, which gives a
-	   good match with noise due to the close harmoonic spacing.
-	   These errors are much more common than people with 50Hz3
-	   pitch, so we have just a small eratio threshold. */
-
-	sixty = 60.0*TWO_PI/FS;
-	if ((eratio < -4.0) && (model->Wo <= sixty))
-	    model->voiced = 0;
-    }
-    //printf(" v: %d snr: %f eratio: %3.2f %f\n",model->voiced,snr,eratio,dF0);
-
-    return snr;
-}
-
-/*---------------------------------------------------------------------------*\
-
-  FUNCTION....: make_synthesis_window
-  AUTHOR......: David Rowe
-  DATE CREATED: 11/5/94
-
-  Init function that generates the trapezoidal (Parzen) sythesis window.
-
-\*---------------------------------------------------------------------------*/
-
-void make_synthesis_window(float Pn[])
-{
-  int   i;
-  float win;
-
-  /* Generate Parzen window in time domain */
-
-  win = 0.0;
-  for(i=0; i<N/2-TW; i++)
-    Pn[i] = 0.0;
-  win = 0.0;
-  for(i=N/2-TW; i<N/2+TW; win+=1.0/(2*TW), i++ )
-    Pn[i] = win;
-  for(i=N/2+TW; i<3*N/2-TW; i++)
-    Pn[i] = 1.0;
-  win = 1.0;
-  for(i=3*N/2-TW; i<3*N/2+TW; win-=1.0/(2*TW), i++)
-    Pn[i] = win;
-  for(i=3*N/2+TW; i<2*N; i++)
-    Pn[i] = 0.0;
-}
-
-/*---------------------------------------------------------------------------*\
-
-  FUNCTION....: synthesise
-  AUTHOR......: David Rowe
-  DATE CREATED: 20/2/95
-
-  Synthesise a speech signal in the frequency domain from the
-  sinusodal model parameters.  Uses overlap-add with a trapezoidal
-  window to smoothly interpolate betwen frames.
-
-\*---------------------------------------------------------------------------*/
-
-void synthesise(
-  kiss_fft_cfg fft_inv_cfg,
-  float  Sn_[],		/* time domain synthesised signal              */
-  MODEL *model,		/* ptr to model parameters for this frame      */
-  float  Pn[],		/* time domain Parzen window                   */
-  int    shift          /* flag used to handle transition frames       */
-)
-{
-    int   i,l,j,b;	/* loop variables */
-    COMP  Sw_[FFT_DEC];	/* DFT of synthesised signal */
-    COMP  sw_[FFT_DEC];	/* synthesised signal */
-
-    if (shift) {
-	/* Update memories */
-	for(i=0; i<N-1; i++) {
-	    Sn_[i] = Sn_[i+N];
-	}
-	Sn_[N-1] = 0.0;
-    }
-
-    for(i=0; i<FFT_DEC; i++) {
-	Sw_[i].real = 0.0;
-	Sw_[i].imag = 0.0;
-    }
-
-    /*
-      Nov 2010 - found that synthesis using time domain cos() functions
-      gives better results for synthesis frames greater than 10ms.  Inverse
-      FFT synthesis using a 512 pt FFT works well for 10ms window.  I think
-      (but am not sure) that the problem is related to the quantisation of
-      the harmonic frequencies to the FFT bin size, e.g. there is a
-      8000/512 Hz step between FFT bins.  For some reason this makes
-      the speech from longer frame > 10ms sound poor.  The effect can also
-      be seen when synthesising test signals like single sine waves, some
-      sort of amplitude modulation at the frame rate.
-
-      Another possibility is using a larger FFT size (1024 or 2048).
-    */
-
-#define FFT_SYNTHESIS
-#ifdef FFT_SYNTHESIS
-    /* Now set up frequency domain synthesised speech */
-    for(l=1; l<=model->L; l++) {
-    //for(l=model->L/2; l<=model->L; l++) {
-    //for(l=1; l<=model->L/4; l++) {
-	b = (int)(l*model->Wo*FFT_DEC/TWO_PI + 0.5);
-	if (b > ((FFT_DEC/2)-1)) {
-		b = (FFT_DEC/2)-1;
-	}
-	Sw_[b].real = model->A[l]*cosf(model->phi[l]);
-	Sw_[b].imag = model->A[l]*sinf(model->phi[l]);
-	Sw_[FFT_DEC-b].real = Sw_[b].real;
-	Sw_[FFT_DEC-b].imag = -Sw_[b].imag;
-    }
-
-    /* Perform inverse DFT */
-
-    kiss_fft(fft_inv_cfg, (kiss_fft_cpx *)Sw_, (kiss_fft_cpx *)sw_);
-#else
-    /*
-       Direct time domain synthesis using the cos() function.  Works
-       well at 10ms and 20ms frames rates.  Note synthesis window is
-       still used to handle overlap-add between adjacent frames.  This
-       could be simplified as we don't need to synthesise where Pn[]
-       is zero.
-    */
-    for(l=1; l<=model->L; l++) {
-	for(i=0,j=-N+1; i<N-1; i++,j++) {
-	    Sw_[FFT_DEC-N+1+i].real += 2.0*model->A[l]*cos(j*model->Wo*l + model->phi[l]);
-	}
- 	for(i=N-1,j=0; i<2*N; i++,j++)
-	    Sw_[j].real += 2.0*model->A[l]*cos(j*model->Wo*l + model->phi[l]);
-    }
-#endif
-
-    /* Overlap add to previous samples */
-
-    for(i=0; i<N-1; i++) {
-	Sn_[i] += sw_[FFT_DEC-N+1+i].real*Pn[i];
-    }
-
-    if (shift)
-	for(i=N-1,j=0; i<2*N; i++,j++)
-	    Sn_[i] = sw_[j].real*Pn[i];
-    else
-	for(i=N-1,j=0; i<2*N; i++,j++)
-	    Sn_[i] += sw_[j].real*Pn[i];
-}
-
-
-static unsigned long next = 1;
-
-int codec2_rand(void) {
-    next = next * 1103515245 + 12345;
-    return((unsigned)(next/65536) % 32768);
-}
-
diff --git a/stm32/src/stm32f4_dacduc.c b/stm32/src/stm32f4_dacduc.c
deleted file mode 100644
index fa4c9179..00000000
--- a/stm32/src/stm32f4_dacduc.c
+++ /dev/null
@@ -1,416 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: stm32f4_dac.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 1 June 2013
-
-  DAC driver module for STM32F4. DAC1 if fixed at Fs of 2Mhz.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2013 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-#include "stm32f4xx.h"
-#include "codec2_fifo.h"
-#include "stm32f4_dacduc.h"
-#include "debugblinky.h"
-
-/* write to these registers for 12 bit left aligned data, as per data sheet
-   make sure 4 least sig bits set to 0 */
-
-#define DAC_DHR12R1_ADDRESS    0x40007408
-#define DAC_DHR12R2_ADDRESS    0x40007414
-
-#define DAC_MAX      4096            /* maximum amplitude */
-
-/* y=mx+c mapping of samples16 bit shorts to DAC samples.  Table: 74
-   of data sheet indicates With DAC buffer on, DAC range is limited to
-   0x0E0 to 0xF1C at VREF+ = 3.6 V, we have Vref=3.3V which is close.
- */
-
-#define M ((3868.0-224.0)/65536.0)
-#define C 2047.0
-
-
-static struct FIFO *dac1_fifo;
-static struct FIFO *dac2_fifo;
-
-static unsigned short dac1_buf[DAC_DUC_BUF_SZ];
-static unsigned short dac2_buf[DAC_BUF_SZ];
-
-static void tim6_config(void);
-static void tim7_config(void);
-static void dac1_config(void);
-static void dac2_config(void);
-
-int dac_underflow;
-
-void fast_dac_open(int dac1_fifo_size,int dac2_fifo_size) {
-
-    memset(dac1_buf, 32768, sizeof(short)*DAC_DUC_BUF_SZ);
-    memset(dac2_buf, 32768, sizeof(short)*DAC_BUF_SZ);
-
-    /* Create fifos */
-
-    dac1_fifo = codec2_fifo_create(dac1_fifo_size);
-    dac2_fifo = codec2_fifo_create(dac2_fifo_size);
-    assert(dac1_fifo != NULL);
-    assert(dac2_fifo != NULL);
-
-    /* Turn on the clocks we need -----------------------------------------------*/
-
-    /* DMA1 clock enable */
-    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);
-    /* GPIOA clock enable (to be used with DAC) */
-    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
-    /* DAC Periph clock enable */
-    RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);
-
-    /* GPIO Pin configuration DAC1->PA.4, DAC2->PA.5 configuration --------------*/
-
-    GPIO_InitTypeDef GPIO_InitStructure;
-    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5;
-    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
-    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
-    GPIO_Init(GPIOA, &GPIO_InitStructure);
-
-    /* Timer and DAC 1 & 2 Configuration ----------------------------------------*/
-    tim7_config();
-    tim6_config();
-    dac1_config();
-    dac2_config();
-
-    init_debug_blinky();
-}
-
-
-/* Call these puppies to send samples to the DACs.  For your
-   convenience they accept signed 16 bit samples. */
-
-int dac1_write(short buf[], int n) {
-    return codec2_fifo_write(dac1_fifo, buf, n);
-}
-
-int dac2_write(short buf[], int n) {
-    return codec2_fifo_write(dac2_fifo, buf, n);
-}
-
-static void tim6_config(void)
-{
-  TIM_TimeBaseInitTypeDef    TIM_TimeBaseStructure;
-
-  /* TIM6 Periph clock enable */
-  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);
-
-  /* --------------------------------------------------------
-
-  TIM6 input clock (TIM6CLK) is set to 2 * APB1 clock (PCLK1), since
-  APB1 prescaler is different from 1 (see system_stm32f4xx.c and Fig
-  13 clock tree figure in DM0031020.pdf).
-
-     Sample rate Fs = 2*PCLK1/TIM_ClockDivision
-                    = (HCLK/2)/TIM_ClockDivision
-
-  ----------------------------------------------------------- */
-
-  /* Time base configuration */
-
-  TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
-  TIM_TimeBaseStructure.TIM_Period = 5250;
-  TIM_TimeBaseStructure.TIM_Prescaler = 0;
-  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
-  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
-  TIM_TimeBaseInit(TIM6, &TIM_TimeBaseStructure);
-
-  /* TIM6 TRGO selection */
-
-  TIM_SelectOutputTrigger(TIM6, TIM_TRGOSource_Update);
-
-  /* TIM6 enable counter */
-
-  TIM_Cmd(TIM6, ENABLE);
-}
-
-/* Sets up tim7 to run at a high sample rate */
-void tim7_config(void)
-{
-  /* Set up tim7 */
-
-
-  TIM_TimeBaseInitTypeDef    TIM_TimeBaseStructure;
-
-  /* TIM7 Periph clock enable */
-  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, ENABLE);
-
-  /* --------------------------------------------------------
-
-
-  TIM7 input clock (TIM7CLK) is set to 2 * APB1 clock (PCLK1), since
-  APB1 prescaler is different from 1 (see system_stm32f4xx.c and Fig
-  13 clock tree figure in DM0031020.pdf).
-
-     Sample rate Fs = 2*PCLK1/TIM_ClockDivision
-                    = (HCLK/2)/TIM_ClockDivision
-
-  ----------------------------------------------------------- */
-
-  /* Time base configuration */
-
-  TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
-  TIM_TimeBaseStructure.TIM_Period = 41;
-  TIM_TimeBaseStructure.TIM_Prescaler = 0;
-  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
-  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
-  TIM_TimeBaseInit(TIM7, &TIM_TimeBaseStructure);
-
-  /* TIM7 TRGO selection */
-
-  TIM_SelectOutputTrigger(TIM7, TIM_TRGOSource_Update);
-
-  /* TIM7 enable counter */
-
-  TIM_Cmd(TIM7, ENABLE);
-}
-
-static void dac1_config(void)
-{
-  DAC_InitTypeDef  DAC_InitStructure;
-  DMA_InitTypeDef  DMA_InitStructure;
-  NVIC_InitTypeDef NVIC_InitStructure;
-
-  /* DAC channel 1 Configuration */
-
-  /*
-     This line fixed a bug that cost me 5 days, bad wave amplitude
-     value, and some STM32F4 periph library bugs caused triangle wave
-     geneartion to be enable resulting in a low level tone on the
-     SM1000, that we thought was caused by analog issues like layour
-     or power supply biasing
-  */
-  DAC_StructInit(&DAC_InitStructure);
-
-  DAC_InitStructure.DAC_Trigger = DAC_Trigger_T7_TRGO;
-  DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;
-
-  /*External buffering is needed to get nice square samples at Fs=2Mhz. See DM00129215.pdf */
-  DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Disable;
-  DAC_Init(DAC_Channel_1, &DAC_InitStructure);
-
-  /* DMA1_Stream5 channel7 configuration **************************************/
-  /* Table 35 page 219 of the monster data sheet */
-
-  DMA_DeInit(DMA1_Stream5);
-  DMA_InitStructure.DMA_Channel = DMA_Channel_7;
-  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)DAC_DHR12R1_ADDRESS;
-  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)dac1_buf;
-  DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
-  DMA_InitStructure.DMA_BufferSize = DAC_DUC_BUF_SZ;
-  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
-  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
-  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
-  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
-  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
-  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
-  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
-  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
-  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
-  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
-  DMA_Init(DMA1_Stream5, &DMA_InitStructure);
-
-  /* Enable DMA Half & Complete interrupts */
-
-  DMA_ITConfig(DMA1_Stream5, DMA_IT_TC | DMA_IT_HT, ENABLE);
-
-  /* Enable the DMA Stream IRQ Channel */
-
-  NVIC_InitStructure.NVIC_IRQChannel = DMA1_Stream5_IRQn;
-  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
-  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
-  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
-  NVIC_Init(&NVIC_InitStructure);
-
-  /* Enable DMA1_Stream5 */
-
-  DMA_Cmd(DMA1_Stream5, ENABLE);
-
-  /* Enable DAC Channel 1 */
-
-  DAC_Cmd(DAC_Channel_1, ENABLE);
-
-  /* Enable DMA for DAC Channel 1 */
-
-  DAC_DMACmd(DAC_Channel_1, ENABLE);
-}
-
-static void dac2_config(void)
-{
-  DAC_InitTypeDef  DAC_InitStructure;
-  DMA_InitTypeDef DMA_InitStructure;
-  NVIC_InitTypeDef NVIC_InitStructure;
-
-  /* DAC channel 2 Configuration (see notes in dac1_config() above) */
-
-  DAC_StructInit(&DAC_InitStructure);
-  DAC_InitStructure.DAC_Trigger = DAC_Trigger_T6_TRGO;
-  DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;
-  DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
-  DAC_Init(DAC_Channel_2, &DAC_InitStructure);
-
-  /* DMA1_Stream6 channel7 configuration **************************************/
-
-  DMA_DeInit(DMA1_Stream6);
-  DMA_InitStructure.DMA_Channel = DMA_Channel_7;
-  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)DAC_DHR12R2_ADDRESS;
-  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)dac2_buf;
-  DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
-  DMA_InitStructure.DMA_BufferSize = DAC_BUF_SZ;
-  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
-  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
-  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
-  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
-  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
-  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
-  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
-  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
-  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
-  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
-  DMA_Init(DMA1_Stream6, &DMA_InitStructure);
-
-  /* Enable DMA Half & Complete interrupts */
-
-  DMA_ITConfig(DMA1_Stream6, DMA_IT_TC | DMA_IT_HT, ENABLE);
-
-  /* Enable the DMA Stream IRQ Channel */
-
-  NVIC_InitStructure.NVIC_IRQChannel = DMA1_Stream6_IRQn;
-  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
-  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
-  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
-  NVIC_Init(&NVIC_InitStructure);
-
-  /* Enable DMA1_Stream6 */
-
-  DMA_Cmd(DMA1_Stream6, ENABLE);
-
-  /* Enable DAC Channel 2 */
-
-  DAC_Cmd(DAC_Channel_2, ENABLE);
-
-  /* Enable DMA for DAC Channel 2 */
-
-  DAC_DMACmd(DAC_Channel_2, ENABLE);
-
-}
-
-/******************************************************************************/
-/*                 STM32F4xx Peripherals Interrupt Handlers                   */
-/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
-/*  available peripheral interrupt handler's name please refer to the startup */
-/*  file (startup_stm32f40xx.s/startup_stm32f427x.s).                         */
-/******************************************************************************/
-
-/*
-  This function handles DMA1 Stream 5 interrupt request for DAC1.
-*/
-
-void DMA1_Stream5_IRQHandler(void) {
-    GPIOE->ODR |= (1 << 1);
-
-    /* Transfer half empty interrupt - refill first half */
-
-    if(DMA_GetITStatus(DMA1_Stream5, DMA_IT_HTIF5) != RESET) {
-        /* fill first half from fifo */
-	codec2_fifo_read(dac1_fifo, (short*)dac1_buf, DAC_DUC_BUF_SZ/2);
-
-        /* Clear DMA Stream Transfer Complete interrupt pending bit */
-        DMA_ClearITPendingBit(DMA1_Stream5, DMA_IT_HTIF5);
-    }
-
-    /* Transfer complete interrupt - refill 2nd half */
-
-    if(DMA_GetITStatus(DMA1_Stream5, DMA_IT_TCIF5) != RESET) {
-        /* fill second half from fifo */
-	codec2_fifo_read(dac1_fifo, (short*)(dac1_buf+DAC_DUC_BUF_SZ/2), DAC_DUC_BUF_SZ/2);
-
-        /* Clear DMA Stream Transfer Complete interrupt pending bit */
-        DMA_ClearITPendingBit(DMA1_Stream5, DMA_IT_TCIF5);
-    }
-
-    GPIOE->ODR &= ~(1 << 1);
-}
-
-/*
-  This function handles DMA1 Stream 6 interrupt request for DAC2.
-*/
-
-void DMA1_Stream6_IRQHandler(void) {
-    int i, j, sam;
-    short signed_buf[DAC_BUF_SZ/2];
-
-    GPIOE->ODR |= (1 << 2);
-
-    /* Transfer half empty interrupt - refill first half */
-
-    if(DMA_GetITStatus(DMA1_Stream6, DMA_IT_HTIF6) != RESET) {
-        /* fill first half from fifo */
-
-        if (codec2_fifo_read(dac2_fifo, signed_buf, DAC_BUF_SZ/2) == -1) {
-            memset(signed_buf, 0, sizeof(short)*DAC_BUF_SZ/2);
-            dac_underflow++;
-        }
-
-        /* convert to unsigned */
-
-        for(i=0; i<DAC_BUF_SZ/2; i++) {
-            sam = (int)(M*(float)signed_buf[i] + C);
-            dac2_buf[i] = (unsigned short)sam;
-        }
-
-        /* Clear DMA Stream Transfer Complete interrupt pending bit */
-
-        DMA_ClearITPendingBit(DMA1_Stream6, DMA_IT_HTIF6);
-    }
-
-    /* Transfer complete interrupt - refill 2nd half */
-
-    if(DMA_GetITStatus(DMA1_Stream6, DMA_IT_TCIF6) != RESET) {
-        /* fill second half from fifo */
-
-        if (codec2_fifo_read(dac2_fifo, signed_buf, DAC_BUF_SZ/2) == -1) {
-            memset(signed_buf, 0, sizeof(short)*DAC_BUF_SZ/2);
-            dac_underflow++;
-        }
-
-        /* convert to unsigned  */
-
-        for(i=0, j=DAC_BUF_SZ/2; i<DAC_BUF_SZ/2; i++,j++) {
-            sam = (int)(M*(float)signed_buf[i] + C);
-            dac2_buf[j] = (unsigned short)sam;
-        }
-
-        /* Clear DMA Stream Transfer Complete interrupt pending bit */
-
-        DMA_ClearITPendingBit(DMA1_Stream6, DMA_IT_TCIF6);
-    }
-
-    GPIOE->ODR &= ~(1 << 2);
-}
-
diff --git a/stm32/src/stm32f4_dacloduc.c b/stm32/src/stm32f4_dacloduc.c
deleted file mode 100644
index 2aa3f402..00000000
--- a/stm32/src/stm32f4_dacloduc.c
+++ /dev/null
@@ -1,276 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: stm32f4_dacloduc.c
-  AUTHOR......: David Rowe
-  DATE CREATED: Sep 2015
-
-  Experimental DAC driver module for STM32F4 that includes a low IF
-  Digital Up Converter (DUC).  The Fs=96kHz signal is mixed up by a
-  (real) 24 kHz (Fs/4) local oscillator, then output by DAC1.
-
-  DAC1 is connected to pin PA4.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2015 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include "stm32f4xx.h"
-#include "codec2_fifo.h"
-#include "stm32f4_dac.h"
-#include "debugblinky.h"
-
-/* write to these registers for 12 bit left aligned data, as per data sheet 
-   make sure 4 least sig bits set to 0 */
-
-#define DAC_DHR12R1_ADDRESS    0x40007408
-
-#define DAC_MAX      4096            /* maximum amplitude */
-
-/* y=mx+c mapping of samples16 bit shorts to DAC samples.  Table: 74
-   of data sheet indicates With DAC buffer on, DAC range is limited to
-   0x0E0 to 0xF1C at VREF+ = 3.6 V, we have Vref=3.3V which is close.
- */
-
-#define M ((3868.0-224.0)/65536.0)
-#define C 2047.0
-
-static struct FIFO *dac1_fifo;
-
-static unsigned short dac1_buf[DAC_BUF_SZ];
-
-static void tim6_config(void);
-static void dac1_config(void);
-
-int dac_underflow;
-
-short signed_buf[DAC_BUF_SZ/2];
-
-#define MAX_AMP 32767
-
-void dac_open(int fifo_size) {
-    memset(dac1_buf, 32768, sizeof(short)*DAC_BUF_SZ);
-
-    /* Create fifo */
-
-    dac1_fifo = codec2_fifo_create(fifo_size);
-    assert(dac1_fifo != NULL);
-
-    /* Turn on the clocks we need -----------------------------------------------*/
-
-    /* DMA1 clock enable */
-    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);
-    /* GPIOA clock enable (to be used with DAC) */
-    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);                         
-    /* DAC Periph clock enable */
-    RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);
-
-    /* GPIO Pin configuration DAC1->PA.4 configuration --------------------------*/
-
-    GPIO_InitTypeDef GPIO_InitStructure;
-    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
-    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
-    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
-    GPIO_Init(GPIOA, &GPIO_InitStructure);
-
-    /* Timer and DAC 1 Configuration --------------------------------------------*/
-
-    tim6_config();  
-    dac1_config();
-
-    init_debug_blinky();
-}
-
-/* Call these puppies to send samples to the DACs.  For your
-   convenience they accept signed 16 bit samples. */
-
-int dac1_write(short buf[], int n) {   
-    return codec2_fifo_write(dac1_fifo, buf, n);
-}
-
-static void tim6_config(void)
-{
-  TIM_TimeBaseInitTypeDef    TIM_TimeBaseStructure;
-
-  /* TIM6 Periph clock enable */
-  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);
-  
-  /* --------------------------------------------------------
-  
-  TIM6 input clock (TIM6CLK) is set to 2 * APB1 clock (PCLK1), since
-  APB1 prescaler is different from 1 (see system_stm32f4xx.c and Fig
-  13 clock tree figure in DM0031020.pdf).
-
-     Sample rate Fs = 2*PCLK1/TIM_ClockDivision 
-                    = (HCLK/2)/TIM_ClockDivision
-                    = 84E6/TIM_ClockDivision (usually)
-
-  ----------------------------------------------------------- */
-
-  /* Time base configuration */
-
-  TIM_TimeBaseStructInit(&TIM_TimeBaseStructure); 
-  TIM_TimeBaseStructure.TIM_Period = 875-1;         /* 96 kHz */
-  TIM_TimeBaseStructure.TIM_Prescaler = 0;       
-  TIM_TimeBaseStructure.TIM_ClockDivision = 0;    
-  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  
-  TIM_TimeBaseInit(TIM6, &TIM_TimeBaseStructure);
-
-  /* TIM6 TRGO selection */
-
-  TIM_SelectOutputTrigger(TIM6, TIM_TRGOSource_Update);
-  
-  /* TIM6 enable counter */
-
-  TIM_Cmd(TIM6, ENABLE);
-}
-
-static void dac1_config(void)
-{
-  DAC_InitTypeDef  DAC_InitStructure;
-  DMA_InitTypeDef  DMA_InitStructure;
-  NVIC_InitTypeDef NVIC_InitStructure;
-  
-  /* DAC channel 1 Configuration */
-
-  /* 
-     This line fixed a bug that cost me 5 days, bad wave amplitude
-     value, and some STM32F4 periph library bugs caused triangle wave
-     generation to be enable resulting in a low level tone on the
-     SM1000, that we thought was caused by analog issues like layout
-     or power supply biasing
-  */
-  DAC_StructInit(&DAC_InitStructure); 
-
-  DAC_InitStructure.DAC_Trigger = DAC_Trigger_T6_TRGO; 
-  DAC_InitStructure.DAC_WaveGeneration = DAC_WaveGeneration_None;
-  DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
-  DAC_Init(DAC_Channel_1, &DAC_InitStructure);
-
-  /* DMA1_Stream5 channel7 configuration **************************************/
-  /* Table 35 page 219 of the monster data sheet */
-
-  DMA_DeInit(DMA1_Stream5);
-  DMA_InitStructure.DMA_Channel = DMA_Channel_7;  
-  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)DAC_DHR12R1_ADDRESS;
-  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)dac1_buf;
-  DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
-  DMA_InitStructure.DMA_BufferSize = DAC_BUF_SZ;
-  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
-  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
-  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
-  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
-  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
-  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
-  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
-  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
-  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
-  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
-  DMA_Init(DMA1_Stream5, &DMA_InitStructure);
-
-  /* Enable DMA Half & Complete interrupts */
-
-  DMA_ITConfig(DMA1_Stream5, DMA_IT_TC | DMA_IT_HT, ENABLE);
-
-  /* Enable the DMA Stream IRQ Channel */
-
-  NVIC_InitStructure.NVIC_IRQChannel = DMA1_Stream5_IRQn;
-  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
-  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
-  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
-  NVIC_Init(&NVIC_InitStructure);     
-
-  /* Enable DMA1_Stream5 */
-
-  DMA_Cmd(DMA1_Stream5, ENABLE);
-
-  /* Enable DAC Channel 1 */
-
-  DAC_Cmd(DAC_Channel_1, ENABLE);
-
-  /* Enable DMA for DAC Channel 1 */
-
-  DAC_DMACmd(DAC_Channel_1, ENABLE);
-}
-
-
-/******************************************************************************/
-/*                 STM32F4xx Peripherals Interrupt Handlers                   */
-/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
-/*  available peripheral interrupt handler's name please refer to the startup */
-/*  file (startup_stm32f40xx.s/startup_stm32f427x.s).                         */
-/******************************************************************************/
-
-/*
-  This function handles DMA1 Stream 5 interrupt request for DAC1.
-*/
-
-void DMA1_Stream5_IRQHandler(void) {
-    int i, j, sam;
-    short signed_buf[DAC_BUF_SZ/2];
-
-    GPIOE->ODR |= (1 << 1);
-
-    /* Transfer half empty interrupt - refill first half */
-
-    if(DMA_GetITStatus(DMA1_Stream5, DMA_IT_HTIF5) != RESET) {
-
-        /* fill first half from fifo */
-
-        if (codec2_fifo_read(dac1_fifo, signed_buf, DAC_BUF_SZ/2) == -1) {
-            memset(signed_buf, 0, sizeof(short)*DAC_BUF_SZ/2);
-            dac_underflow++;
-        }
-
-        for(i=0; i<DAC_BUF_SZ/2; i++) {
-            sam = (int)(M*(float)signed_buf[i] + C);
-            dac1_buf[i] = (unsigned short)sam;
-        }
-
-        /* Clear DMA Stream Transfer Complete interrupt pending bit */
-
-        DMA_ClearITPendingBit(DMA1_Stream5, DMA_IT_HTIF5);  
-    }
-
-    /* Transfer complete interrupt - refill 2nd half */
-
-    if(DMA_GetITStatus(DMA1_Stream5, DMA_IT_TCIF5) != RESET) {
-
-        /* fill second half from fifo */
-
-        if (codec2_fifo_read(dac1_fifo, signed_buf, DAC_BUF_SZ/2) == -1) {
-            memset(signed_buf, 0, sizeof(short)*DAC_BUF_SZ/2);
-            dac_underflow++;
-        }
-
-        for(i=0, j=DAC_BUF_SZ/2; i<DAC_BUF_SZ/2; i++, j++) {
-            sam = (int)(M*(float)signed_buf[i] + C);
-            dac1_buf[j] = (unsigned short)sam;
-        }
-
-        /* Clear DMA Stream Transfer Complete interrupt pending bit */
-
-        DMA_ClearITPendingBit(DMA1_Stream5, DMA_IT_TCIF5);  
-    }
-
-    GPIOE->ODR &= ~(1 << 1);
-}
-
diff --git a/stm32/src/stm32f4_pwm.c b/stm32/src/stm32f4_pwm.c
deleted file mode 100644
index 3bc3ea74..00000000
--- a/stm32/src/stm32f4_pwm.c
+++ /dev/null
@@ -1,236 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: stm32f4_pwm.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 26 June 2013
-
-  PWM  driver module for STM32F4.
-
-  TODO:
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2013 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-
-#include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-#include "gdb_stdio.h"
-
-#include "stm32f4xx_gpio.h"
-#include "stm32f4xx_rcc.h"
-
-#define TIM1_CCR3_ADDRESS    0x4001003C
-//#define TIM1_CCR3_ADDRESS    0x4001223C
-#define SINE_SAMPLES         32
-
-TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
-TIM_OCInitTypeDef  TIM_OCInitStructure;
-uint16_t uhTimerPeriod;
-uint16_t aSRC_Buffer[SINE_SAMPLES] = {0, 0, 0};
-
-/* 32 sample sine wave which at Fs=16kHz will be 500Hz.  Not sampels
-   are 16 bit 2's complement, the DAC driver convertsto 12 bit
-   unsigned. */
-
-short aSine[SINE_SAMPLES] = {
-    -16,    6384,   12528,  18192,   23200,   27232,   30256,   32128,   32752,   32128,
-    30256,   27232,   23152,   18192,   12528,    6384,     -16,   -6416,  -12560,  -18224,
-    -23184,  -27264,  -30288,  -32160,  -32768,  -32160,  -30288,  -27264,  -23184,  -18224,
-    -12560,   -6416
-};
-
-void Timer1Config();
-
-#define FS  16000
-
-int main(void){
-    Timer1Config();
-    while(1);
-}
-
-/* DR: TIM_Config configures a couple of I/O pins for PWM output from
-   Timer1 Channel 3.  Note I dont think any of this is needed, except
-   perhaps to check timer frequency.  Can be removed down the track. */
-
-/**
-  * @brief  Configure the TIM1 Pins.
-  * @param  None
-  * @retval None
-  */
-static void TIM_Config(void)
-{
-  GPIO_InitTypeDef GPIO_InitStructure;
-
-  /* GPIOA and GPIOB clock enable */
-  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB, ENABLE);
-
-  /* GPIOA Configuration: Channel 3 as alternate function push-pull */
-
-  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 ;
-  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
-  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
-  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
-  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
-  GPIO_Init(GPIOA, &GPIO_InitStructure);
-  GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_TIM1);
-
-  /* GPIOB Configuration: Channel 3N as alternate function push-pull */
-
-  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
-  GPIO_Init(GPIOB, &GPIO_InitStructure);
-  GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_TIM1);
-
-#ifdef DR_OFF
-  /* DMA clock enable */
-  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2 , ENABLE);
-
-  DMA_DeInit(DMA2_Stream6);
-  DMA_InitStructure.DMA_Channel = DMA_Channel_6;
-  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)(TIM1_CCR3_ADDRESS) ;
-  DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)aSRC_Buffer;
-  DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
-  DMA_InitStructure.DMA_BufferSize = SINE_SAMPLES;
-  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
-  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
-  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
-  DMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_HalfWord;
-  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
-  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
-  DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
-  DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;
-  DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
-  DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
-
-  DMA_Init(DMA2_Stream6, &DMA_InitStructure);
-#endif
-}
-
-void Timer1Config() {
-    /* TIM Configuration */
-
-    TIM_Config();
-
-    /* TIM1 example -------------------------------------------------
-
-       TIM1 input clock (TIM1CLK) is set to 2 * APB2 clock (PCLK2), since APB2
-       prescaler is different from 1.
-       TIM1CLK = 2 * PCLK2
-       PCLK2 = HCLK / 2
-       => TIM1CLK = 2 * (HCLK / 2) = HCLK = SystemCoreClock
-
-       TIM1CLK = SystemCoreClock, Prescaler = 0, TIM1 counter clock = SystemCoreClock
-       SystemCoreClock is set to 168 MHz for STM32F4xx devices.
-
-       The objective is to configure TIM1 channel 3 to generate complementary PWM
-       signal with a frequency equal to F KHz:
-       - TIM1_Period = (SystemCoreClock / F) - 1
-
-       The number of this repetitive requests is defined by the TIM1 Repetion counter,
-       each 3 Update Requests, the TIM1 Channel 3 Duty Cycle changes to the next new
-       value defined by the aSRC_Buffer.
-
-       Note:
-       SystemCoreClock variable holds HCLK frequency and is defined in system_stm32f4xx.c file.
-       Each time the core clock (HCLK) changes, user had to call SystemCoreClockUpdate()
-       function to update SystemCoreClock variable value. Otherwise, any configuration
-       based on this variable will be incorrect.
-       -----------------------------------------------------------------------------*/
-
-    /* Compute the value to be set in ARR regiter to generate signal frequency at FS */
-
-#ifdef TMP
-    uhTimerPeriod = (SystemCoreClock / FS ) - 1;
-    //gdb_stdio_printf("uhTimerPeriod = %d\n", uhTimerPeriod);
-
-    /* Compute CCR1 values to generate a duty cycle at 50% */
-
-    for(i=0; i<SINE_SAMPLES; i++) {
-        aSRC_Buffer[i] = uhTimerPeriod *((int)aSine[i] + 32768)/(32768*2);
-    }
-#else
-    uhTimerPeriod = (SystemCoreClock / 28000000) - 1;
-    aSRC_Buffer[0] =   uhTimerPeriod/2 + 1;
-
-#endif
-
-    /* TIM1 clock enable */
-
-    RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
-
-    /* Time Base configuration */
-
-    TIM_DeInit(TIM1);
-    TIM_TimeBaseStructure.TIM_Prescaler = 0;
-    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
-    TIM_TimeBaseStructure.TIM_Period = uhTimerPeriod;
-    TIM_TimeBaseStructure.TIM_ClockDivision = 0;
-    TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
-
-    TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
-
-
-    #define TMP2
-#ifdef TMP2
-    /* Channel 3 Configuration in PWM mode */
-
-    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;
-    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
-    TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
-    TIM_OCInitStructure.TIM_Pulse = aSRC_Buffer[0];
-    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;
-    TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_Low;
-    TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
-    TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;
-
-    TIM_OC3Init(TIM1, &TIM_OCInitStructure);
-
-    /* Enable preload feature */
-    TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);
-#else
-    /* Channel 3 Configuration in PWM mode */
-
-    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Toggle;
-    TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
-    //TIM_OCInitStructure.TIM_Pulse = aSRC_Buffer[0];
-
-    //TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;
-    //TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
-
-    //TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
-    //TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_Low;
-    //TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;
-
-    TIM_OC3Init(TIM1, &TIM_OCInitStructure);
-
-    //TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);
-#endif
-
-    /* TIM1 counter enable */
-    TIM_Cmd(TIM1, ENABLE);
-
-    /* DMA enable*/
-    //DMA_Cmd(DMA2_Stream6, ENABLE);
-
-    /* TIM1 Update DMA Request enable */
-    //TIM_DMACmd(TIM1, TIM_DMA_CC3, ENABLE);
-
-    /* Main Output Enable */
-    TIM_CtrlPWMOutputs(TIM1, ENABLE);
-}
diff --git a/stm32/src/timer_ut.c b/stm32/src/timer_ut.c
deleted file mode 100644
index 1e9dcc4b..00000000
--- a/stm32/src/timer_ut.c
+++ /dev/null
@@ -1,179 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: timer_ut.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 3 Jan 2014
-
-  Unit test STM32F4 timer hardware.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2014 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "stm32f4xx_gpio.h"
-#include "stm32f4xx_rcc.h"
-
-#include "gdb_stdio.h"
-
-#define TIM1_CCR3_ADDRESS    0x4001223C
-
-TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
-TIM_OCInitTypeDef  TIM_OCInitStructure;
-TIM_BDTRInitTypeDef TIM_BDTRInitStructure;
-uint16_t uhTimerPeriod;
-uint16_t aSRC_Buffer[3] = {0, 0, 0};
-
-void Timer1Config();
-#define FS  3500000
-
-int main(void){
-    Timer1Config();
- }
-
-/* DR: TIM_Config configures a couple of I/O pins for PWM output from
-   Timer1 Channel 3.  Note I dont think any of this is needed, except
-   perhaps to check timer frequency.  Can be removed down the track. */
-
-/**
-  * @brief  Configure the TIM1 Pins.
-  * @param  None
-  * @retval None
-  */
-static void TIM_Config(void)
-{
-  GPIO_InitTypeDef GPIO_InitStructure;
-
-  /* GPIOA and GPIOB clock enable */
-  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB, ENABLE);
-
-  /* GPIOA Configuration: Channel 3 as alternate function push-pull */
-  /* Discovery board pin PA10 */
-
-  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 ;
-  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
-  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
-  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
-  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
-  GPIO_Init(GPIOA, &GPIO_InitStructure);
-  GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_TIM1);
-
-  /* GPIOB Configuration: Channel 3N as alternate function push-pull */
-  /* Discovery board pin PB15 */
-
-  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
-  GPIO_Init(GPIOB, &GPIO_InitStructure);
-  GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_TIM1);
-}
-
-void Timer1Config() {
-
-    /* TIM Configuration */
-
-    TIM_Config();
-
-    /* TIM1 example -------------------------------------------------
-
-       TIM1 input clock (TIM1CLK) is set to 2 * APB2 clock (PCLK2), since APB2
-       prescaler is different from 1.
-       TIM1CLK = 2 * PCLK2
-       PCLK2 = HCLK / 2
-       => TIM1CLK = 2 * (HCLK / 2) = HCLK = SystemCoreClock
-
-       TIM1CLK = SystemCoreClock, Prescaler = 0, TIM1 counter clock = SystemCoreClock
-       SystemCoreClock is set to 168 MHz for STM32F4xx devices.
-
-       The objective is to configure TIM1 channel 3 to generate complementary PWM
-       signal with a frequency equal to F KHz:
-       - TIM1_Period = (SystemCoreClock / F) - 1
-
-       The number of this repetitive requests is defined by the TIM1 Repetion counter,
-       each 3 Update Requests, the TIM1 Channel 3 Duty Cycle changes to the next new
-       value defined by the aSRC_Buffer.
-
-       Note:
-       SystemCoreClock variable holds HCLK frequency and is defined in system_stm32f4xx.c file.
-       Each time the core clock (HCLK) changes, user had to call SystemCoreClockUpdate()
-       function to update SystemCoreClock variable value. Otherwise, any configuration
-       based on this variable will be incorrect.
-       -----------------------------------------------------------------------------*/
-
-    /* Compute the value to be set in ARR regiter to generate signal frequency at FS Hz */
-    uhTimerPeriod = (SystemCoreClock / FS ) - 1;
-    /* Compute CCR1 value to generate a duty cycle at 50% */
-    aSRC_Buffer[0] = (uint16_t) (((uint32_t) 5 * (uhTimerPeriod - 1)) / 10);
-    /* Compute CCR1 value to generate a duty cycle at 37.5% */
-    aSRC_Buffer[1] = (uint16_t) (((uint32_t) 375 * (uhTimerPeriod - 1)) / 1000);
-    /* Compute CCR1 value to generate a duty cycle at 25% */
-    aSRC_Buffer[2] = (uint16_t) (((uint32_t) 25 * (uhTimerPeriod - 1)) / 100);
-
-    /* TIM1 Peripheral Configuration -------------------------------------------*/
-    /* TIM1 clock enable */
-    RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
-
-    /* Time Base configuration */
-
-    TIM_DeInit(TIM1);
-    TIM_TimeBaseStructure.TIM_Prescaler = 0;
-    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
-    TIM_TimeBaseStructure.TIM_Period = uhTimerPeriod;
-    TIM_TimeBaseStructure.TIM_ClockDivision = 0;
-    TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
-
-    TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
-
-    /* Channel 3 Configuration in PWM mode */
-
-    /* I think we just ned to enable channel 3 somehow, but without
-       (or optionally with) actual ouput to a GPIO pin.  */
-
-    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;
-    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
-    TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
-    TIM_OCInitStructure.TIM_Pulse = aSRC_Buffer[0];
-    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;
-    TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_Low;
-    TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
-    TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;
-
-    TIM_OC3Init(TIM1, &TIM_OCInitStructure);
-
-    /* Enable preload feature */
-    TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);
-
-    /* Automatic Output enable, Break, dead time and lock configuration*/
-    TIM_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;
-    TIM_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
-    //TIM_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_1;
-    TIM_BDTRInitStructure.TIM_DeadTime = 11;
-    //TIM_BDTRInitStructure.TIM_Break = TIM_Break_Enable;
-    //TIM_BDTRInitStructure.TIM_BreakPolarity = TIM_BreakPolarity_High;
-    TIM_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Enable;
-
-    TIM_BDTRConfig(TIM1, &TIM_BDTRInitStructure);
-
-    /* TIM1 counter enable */
-    TIM_Cmd(TIM1, ENABLE);
-
-    /* Main Output Enable */
-    TIM_CtrlPWMOutputs(TIM1, ENABLE);
-}
-
diff --git a/stm32/src/tm_stm32f4_gpio.c b/stm32/src/tm_stm32f4_gpio.c
deleted file mode 100644
index 70896325..00000000
--- a/stm32/src/tm_stm32f4_gpio.c
+++ /dev/null
@@ -1,238 +0,0 @@
-/**	
- * |----------------------------------------------------------------------
- * | Copyright (C) Tilen Majerle, 2015
- * | 
- * | This program is free software: you can redistribute it and/or modify
- * | it under the terms of the GNU General Public License as published by
- * | the Free Software Foundation, either version 3 of the License, or
- * | any later version.
- * |  
- * | This program is distributed in the hope that it will be useful,
- * | but WITHOUT ANY WARRANTY; without even the implied warranty of
- * | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * | GNU General Public License for more details.
- * | 
- * | You should have received a copy of the GNU General Public License
- * | along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * |----------------------------------------------------------------------
- */
-#include "tm_stm32f4_gpio.h"
-
-/* Private function */
-static uint16_t GPIO_UsedPins[11] = {0,0,0,0,0,0,0,0,0,0,0};
-
-/* Private functions */
-void TM_GPIO_INT_EnableClock(GPIO_TypeDef* GPIOx);
-void TM_GPIO_INT_DisableClock(GPIO_TypeDef* GPIOx);
-void TM_GPIO_INT_Init(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_Mode_t GPIO_Mode, TM_GPIO_OType_t GPIO_OType, TM_GPIO_PuPd_t GPIO_PuPd, TM_GPIO_Speed_t GPIO_Speed);
-
-void TM_GPIO_Init(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_Mode_t GPIO_Mode, TM_GPIO_OType_t GPIO_OType, TM_GPIO_PuPd_t GPIO_PuPd, TM_GPIO_Speed_t GPIO_Speed) {	
-	/* Check input */
-	if (GPIO_Pin == 0x00) {
-		return;
-	}
-	
-	/* Enable clock for GPIO */
-	TM_GPIO_INT_EnableClock(GPIOx);
-	
-	/* Do initialization */
-	TM_GPIO_INT_Init(GPIOx, GPIO_Pin, GPIO_Mode, GPIO_OType, GPIO_PuPd, GPIO_Speed);
-}
-
-void TM_GPIO_InitAlternate(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_OType_t GPIO_OType, TM_GPIO_PuPd_t GPIO_PuPd, TM_GPIO_Speed_t GPIO_Speed, uint8_t Alternate) {
-	uint32_t pinpos;
-
-	/* Check input */
-	if (GPIO_Pin == 0x00) {
-		return;
-	}
-	
-	/* Enable GPIOx clock */
-	TM_GPIO_INT_EnableClock(GPIOx);
-	
-	/* Set alternate functions for all pins */
-	for (pinpos = 0; pinpos < 0x10; pinpos++) {
-		/* Check pin */
-		if ((GPIO_Pin & (1 << pinpos)) == 0) {
-			continue;
-		}
-		
-		/* Set alternate function */
-		GPIOx->AFR[pinpos >> 0x03] = (GPIOx->AFR[pinpos >> 0x03] & ~(0x0F << (4 * (pinpos & 0x07)))) | (Alternate << (4 * (pinpos & 0x07)));
-	}
-	
-	/* Do initialization */
-	TM_GPIO_INT_Init(GPIOx, GPIO_Pin, TM_GPIO_Mode_AF, GPIO_OType, GPIO_PuPd, GPIO_Speed);
-}
-
-void TM_GPIO_DeInit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin) {
-	uint8_t i;
-	uint8_t ptr = TM_GPIO_GetPortSource(GPIOx);
-	
-	/* Go through all pins */
-	for (i = 0x00; i < 0x10; i++) {
-		/* Pin is set */
-		if (GPIO_Pin & (1 << i)) {
-			/* Set 11 bits combination for analog mode */
-			GPIOx->MODER |= (0x03 << (2 * i));
-			
-			/* Pin is not used */
-			GPIO_UsedPins[ptr] &= ~(1 << i);
-		}
-	}
-}
-
-void TM_GPIO_SetPinAsInput(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin) {
-	uint8_t i;
-	/* Go through all pins */
-	for (i = 0x00; i < 0x10; i++) {
-		/* Pin is set */
-		if (GPIO_Pin & (1 << i)) {
-			/* Set 00 bits combination for input */
-			GPIOx->MODER &= ~(0x03 << (2 * i));
-		}
-	}
-}
-
-void TM_GPIO_SetPinAsOutput(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin) {
-	uint8_t i;
-	/* Go through all pins */
-	for (i = 0x00; i < 0x10; i++) {
-		/* Pin is set */
-		if (GPIO_Pin & (1 << i)) {
-			/* Set 01 bits combination for output */
-			GPIOx->MODER = (GPIOx->MODER & ~(0x03 << (2 * i))) | (0x01 << (2 * i));
-		}
-	}
-}
-
-void TM_GPIO_SetPinAsAnalog(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin) {
-	uint8_t i;
-	/* Go through all pins */
-	for (i = 0x00; i < 0x10; i++) {
-		/* Pin is set */
-		if (GPIO_Pin & (1 << i)) {
-			/* Set 11 bits combination for analog mode */
-			GPIOx->MODER |= (0x03 << (2 * i));
-		}
-	}
-}
-
-void TM_GPIO_SetPinAsAlternate(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin) {
-	uint8_t i;
-	
-	/* Set alternate functions for all pins */
-	for (i = 0; i < 0x10; i++) {
-		/* Check pin */
-		if ((GPIO_Pin & (1 << i)) == 0) {
-			continue;
-		}
-		
-		/* Set alternate mode */
-		GPIOx->MODER = (GPIOx->MODER & ~(0x03 << (2 * i))) | (0x02 << (2 * i));
-	}
-}
-
-void TM_GPIO_SetPullResistor(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_PuPd_t GPIO_PuPd) {
-	uint8_t pinpos;
-	
-	/* Go through all pins */
-	for (pinpos = 0; pinpos < 0x10; pinpos++) {
-		/* Check if pin available */
-		if ((GPIO_Pin & (1 << pinpos)) == 0) {
-			continue;
-		}
-
-		/* Set GPIO PUPD register */
-		GPIOx->PUPDR = (GPIOx->PUPDR & ~(0x03 << (2 * pinpos))) | ((uint32_t)(GPIO_PuPd << (2 * pinpos)));
-	}
-}
-
-void TM_GPIO_Lock(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin) {
-	uint32_t d;
-	
-	/* Set GPIO pin with 16th bit set to 1 */
-	d = 0x00010000 | GPIO_Pin;
-	
-	/* Write to LCKR register */
-	GPIOx->LCKR = d;
-	GPIOx->LCKR = GPIO_Pin;
-	GPIOx->LCKR = d;
-	
-	/* Read twice */
-	(void)GPIOx->LCKR;
-	(void)GPIOx->LCKR;
-}
-
-uint16_t TM_GPIO_GetPinSource(uint16_t GPIO_Pin) {
-	uint16_t pinsource = 0;
-	
-	/* Get pinsource */
-	while (GPIO_Pin > 1) {
-		/* Increase pinsource */
-		pinsource++;
-		/* Shift right */
-		GPIO_Pin >>= 1;
-	}
-	
-	/* Return source */
-	return pinsource;
-}
-
-uint16_t TM_GPIO_GetPortSource(GPIO_TypeDef* GPIOx) {
-	/* Get port source number */
-	/* Offset from GPIOA                       Difference between 2 GPIO addresses */
-	return ((uint32_t)GPIOx - (GPIOA_BASE)) / ((GPIOB_BASE) - (GPIOA_BASE));
-}
-
-/* Private functions */
-void TM_GPIO_INT_EnableClock(GPIO_TypeDef* GPIOx) {
-	/* Set bit according to the 1 << portsourcenumber */
-	RCC->AHB1ENR |= (1 << TM_GPIO_GetPortSource(GPIOx));
-}
-
-void TM_GPIO_INT_DisableClock(GPIO_TypeDef* GPIOx) {
-	/* Clear bit according to the 1 << portsourcenumber */
-	RCC->AHB1ENR &= ~(1 << TM_GPIO_GetPortSource(GPIOx));
-}
-
-void TM_GPIO_INT_Init(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, TM_GPIO_Mode_t GPIO_Mode, TM_GPIO_OType_t GPIO_OType, TM_GPIO_PuPd_t GPIO_PuPd, TM_GPIO_Speed_t GPIO_Speed) {
-	uint8_t pinpos;
-	uint8_t ptr = TM_GPIO_GetPortSource(GPIOx);
-	
-	/* Go through all pins */
-	for (pinpos = 0; pinpos < 0x10; pinpos++) {
-		/* Check if pin available */
-		if ((GPIO_Pin & (1 << pinpos)) == 0) {
-			continue;
-		}
-		
-		/* Pin is used */
-		GPIO_UsedPins[ptr] |= 1 << pinpos;
-		
-		/* Set GPIO PUPD register */
-		GPIOx->PUPDR = (GPIOx->PUPDR & ~(0x03 << (2 * pinpos))) | ((uint32_t)(GPIO_PuPd << (2 * pinpos)));
-		
-		/* Set GPIO MODE register */
-		GPIOx->MODER = (GPIOx->MODER & ~((uint32_t)(0x03 << (2 * pinpos)))) | ((uint32_t)(GPIO_Mode << (2 * pinpos)));
-		
-		/* Set only if output or alternate functions */
-		if (GPIO_Mode == TM_GPIO_Mode_OUT || GPIO_Mode == TM_GPIO_Mode_AF) {		
-			/* Set GPIO OTYPE register */
-			GPIOx->OTYPER = (GPIOx->OTYPER & ~(uint16_t)(0x01 << pinpos)) | ((uint16_t)(GPIO_OType << pinpos));
-			
-			/* Set GPIO OSPEED register */
-			GPIOx->OSPEEDR = (GPIOx->OSPEEDR & ~((uint32_t)(0x03 << (2 * pinpos)))) | ((uint32_t)(GPIO_Speed << (2 * pinpos)));
-		}
-	}
-}
-
-uint16_t TM_GPIO_GetUsedPins(GPIO_TypeDef* GPIOx) {
-	/* Return used */
-	return GPIO_UsedPins[TM_GPIO_GetPortSource(GPIOx)];
-}
-
-uint16_t TM_GPIO_GetFreePins(GPIO_TypeDef* GPIOx) {
-	/* Return free pins */
-	return ~GPIO_UsedPins[TM_GPIO_GetPortSource(GPIOx)];
-}
diff --git a/stm32/src/tm_stm32f4_mco_output.c b/stm32/src/tm_stm32f4_mco_output.c
deleted file mode 100644
index 9828c41d..00000000
--- a/stm32/src/tm_stm32f4_mco_output.c
+++ /dev/null
@@ -1,128 +0,0 @@
-/**	
- * |----------------------------------------------------------------------
- * | Copyright (C) Tilen Majerle, 2014
- * | 
- * | This program is free software: you can redistribute it and/or modify
- * | it under the terms of the GNU General Public License as published by
- * | the Free Software Foundation, either version 3 of the License, or
- * | any later version.
- * |  
- * | This program is distributed in the hope that it will be useful,
- * | but WITHOUT ANY WARRANTY; without even the implied warranty of
- * | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * | GNU General Public License for more details.
- * | 
- * | You should have received a copy of the GNU General Public License
- * | along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * |----------------------------------------------------------------------
- */
-#include "tm_stm32f4_mco_output.h"
-
-void TM_MCOOUTPUT_InitMCO1(void) {
-	/* Enable PA8 */
-	TM_GPIO_Init(GPIOA, GPIO_PIN_8, TM_GPIO_Mode_AF, TM_GPIO_OType_PP, TM_GPIO_PuPd_NOPULL, TM_GPIO_Speed_High);
-}
-
-void TM_MCOOUTPUT_InitMCO2(void) {
-	/* Enable PC9 */
-	TM_GPIO_Init(GPIOC, GPIO_PIN_9, TM_GPIO_Mode_AF, TM_GPIO_OType_PP, TM_GPIO_PuPd_NOPULL, TM_GPIO_Speed_High);
-}
-
-void TM_MCOOUTPUT_SetOutput1(TM_MCOOUTPUT1_Source_t Source, TM_MCOOUTPUT_Prescaler_t Prescaler) {
-	uint32_t presc = 0, src = 0;
-	
-	/* Get prescaler */
-	switch (Prescaler) {
-		case TM_MCOOUTPUT_Prescaler_1:
-			presc = RCC_MCO1Div_1;
-			break;
-		case TM_MCOOUTPUT_Prescaler_2:
-			presc = RCC_MCO1Div_2;
-			break;
-		case TM_MCOOUTPUT_Prescaler_3:
-			presc = RCC_MCO1Div_3;
-			break;
-		case TM_MCOOUTPUT_Prescaler_4:
-			presc = RCC_MCO1Div_4;
-			break;
-		case TM_MCOOUTPUT_Prescaler_5:
-			presc = RCC_MCO1Div_5;
-			break;
-		default:
-			break;
-	}
-	
-	/* Get source */
-	switch (Source) {
-		case TM_MCOOUTPUT1_Source_HSE:
-			src = RCC_MCO1Source_HSE;
-		
-			/* Enable RCC HSE oscillator */
-			RCC_HSEConfig(RCC_HSE_ON);
-			break;
-		case TM_MCOOUTPUT1_Source_HSI:
-			src = RCC_MCO1Source_HSI;
-			break;
-		case TM_MCOOUTPUT1_Source_PLLCLK:
-			src = RCC_MCO1Source_PLLCLK;
-			break;
-		case TM_MCOOUTPUT1_Source_LSE:		
-			src = RCC_MCO1Source_LSE;
-		
-			/* Start LSE clock if available */
-			RCC_LSEConfig(RCC_LSE_ON);
-			break;
-		default:
-			break;
-	}
-	
-	
-	/* Set source and prescaler  */
-	RCC_MCO1Config(src, presc);
-}
-
-void TM_MCOOUTPUT_SetOutput2(TM_MCOOUTPUT2_Source_t Source, TM_MCOOUTPUT_Prescaler_t Prescaler) {
-	uint32_t presc = 0, src = 0;
-	
-	/* Get prescaler */
-	switch (Prescaler) {
-		case TM_MCOOUTPUT_Prescaler_1:
-			presc = RCC_MCO2Div_1;
-			break;
-		case TM_MCOOUTPUT_Prescaler_2:
-			presc = RCC_MCO2Div_2;
-			break;
-		case TM_MCOOUTPUT_Prescaler_3:
-			presc = RCC_MCO2Div_3;
-			break;
-		case TM_MCOOUTPUT_Prescaler_4:
-			presc = RCC_MCO2Div_4;
-			break;
-		case TM_MCOOUTPUT_Prescaler_5:
-			presc = RCC_MCO2Div_5;
-			break;
-		default:
-			break;
-	}
-	
-	/* Get clock source */
-	switch (Source) {
-		case TM_MCOOUTPUT2_Source_SYSCLK:
-			src = RCC_MCO2Source_SYSCLK;
-			break;
-		case TM_MCOOUTPUT2_Source_PLLI2SCLK:
-			src = RCC_MCO2Source_PLLI2SCLK;
-			break;
-		case TM_MCOOUTPUT2_Source_HSE:
-			src = RCC_MCO2Source_HSE;
-			break;
-		case TM_MCOOUTPUT2_Source_PLLCLK:
-			src = RCC_MCO2Source_PLLCLK;
-			break;
-		default:
-			break;
-	}
-	
-	/* Set source and prescaler  */
-	RCC_MCO2Config(src, presc);
-}
-- 
2.30.2

