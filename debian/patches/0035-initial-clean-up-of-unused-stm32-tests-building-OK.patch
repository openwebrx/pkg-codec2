From 7b44952b85d48b5afb3ee570179df22edf3e9802 Mon Sep 17 00:00:00 2001
From: David Rowe <david@rowetel.com>
Date: Sun, 31 Oct 2021 07:13:31 +1030
Subject: [PATCH 35/53] initial clean up of unused stm32 tests, building OK

---
 src/dump.c                    |   7 -
 stm32/CMakeLists.txt          | 208 +--------
 stm32/src/adc_rec.c           |  76 ---
 stm32/src/adc_sd.c            |  75 ---
 stm32/src/adc_sfdr_ut.c       |  89 ----
 stm32/src/adcdac_ut.c         |  70 ---
 stm32/src/dac_play.c          |  63 ---
 stm32/src/dac_ut_fast.c       |  37 --
 stm32/src/fdmdv_dump_rt.c     | 154 ------
 stm32/src/fft_test.c          | 435 -----------------
 stm32/src/freedv_rx_profile.c | 136 ------
 stm32/src/freedv_tx_profile.c |  90 ----
 stm32/src/gdb_stdio.c         | 125 -----
 stm32/src/iir_duc.c           | 371 ---------------
 stm32/src/iir_tuner.c         | 325 -------------
 stm32/src/power_ut.c          | 135 ------
 stm32/src/si5351_ut.c         |  45 --
 stm32/src/si53xx.c            | 856 ----------------------------------
 stm32/src/stm32f4_adc_tuner.c | 289 ------------
 stm32/src/tuner_ut.c          | 122 -----
 20 files changed, 6 insertions(+), 3702 deletions(-)
 delete mode 100644 stm32/src/adc_rec.c
 delete mode 100644 stm32/src/adc_sd.c
 delete mode 100644 stm32/src/adc_sfdr_ut.c
 delete mode 100644 stm32/src/adcdac_ut.c
 delete mode 100644 stm32/src/dac_play.c
 delete mode 100644 stm32/src/dac_ut_fast.c
 delete mode 100644 stm32/src/fdmdv_dump_rt.c
 delete mode 100644 stm32/src/fft_test.c
 delete mode 100644 stm32/src/freedv_rx_profile.c
 delete mode 100644 stm32/src/freedv_tx_profile.c
 delete mode 100644 stm32/src/gdb_stdio.c
 delete mode 100644 stm32/src/iir_duc.c
 delete mode 100644 stm32/src/iir_tuner.c
 delete mode 100644 stm32/src/power_ut.c
 delete mode 100644 stm32/src/si5351_ut.c
 delete mode 100644 stm32/src/si53xx.c
 delete mode 100644 stm32/src/stm32f4_adc_tuner.c
 delete mode 100644 stm32/src/tuner_ut.c

diff --git a/src/dump.c b/src/dump.c
index 4fae3b67..ff1977da 100644
--- a/src/dump.c
+++ b/src/dump.c
@@ -32,13 +32,6 @@
 #include <string.h>
 #include <math.h>
 
-#ifdef __EMBEDDED__
-#include "gdb_stdio.h"
-#define fprintf gdb_stdio_fprintf
-#define fopen gdb_stdio_fopen
-#define fclose gdb_stdio_fclose
-#endif
-
 #ifdef DUMP
 static int dumpon = 0;
 
diff --git a/stm32/CMakeLists.txt b/stm32/CMakeLists.txt
index b7f9539e..f937e51b 100644
--- a/stm32/CMakeLists.txt
+++ b/stm32/CMakeLists.txt
@@ -223,7 +223,6 @@ src/stm32f4_dac.c
 ../src/codec2_fifo.c
 )
 add_library(stm32f4_adac STATIC ${STM32F4_ADAC_SRCS})
-
 add_library(codec2 STATIC ${CODEC2_SRCS})
 add_library(codec2_prof STATIC ${CODEC2_SRCS})
 target_compile_definitions(codec2_prof PRIVATE PROFILE)
@@ -231,7 +230,6 @@ target_compile_definitions(codec2_prof PRIVATE PROFILE)
 set(SYSTEM_SRCS
 src/system_stm32f4xx.c
 src/startup_stm32f4xx.s
-src/gdb_stdio.c
 )
 
 add_library(sm1000base STATIC src/sm1000_leds_switches.c src/debugblinky.c ${SYSTEM_SRCS})
@@ -242,120 +240,35 @@ src/stm32f4_machdep.c
 
 list(APPEND PROFILE_SYSTEM_SRCS ${SYSTEM_SRCS})
 
-set(FFT_TEST_SRCS 
-src/fft_test.c
-../src/kiss_fft.c
-)
-
-add_mapped_executable(fft_test ${FFT_TEST_SRCS} ${PROFILE_SYSTEM_SRCS})
-target_link_libraries(fft_test stm32f4 CMSIS)
-elf2bin(fft_test)
-
-
-# Rule for programming the SM1000
-#%.pgm: %.bin
-#	$(SUDO) dfu-util -d 0483:df11 -c 1 -i 0 -a 0 -s 0x08000000 -D $<
-####################################################
-
-set(CODEC2_PROFILE_SRCS
-src/codec2_profile.c
-)
-
-add_mapped_executable(codec2_profile ${CODEC2_PROFILE_SRCS} ${PROFILE_SYSTEM_SRCS})
-target_link_libraries(codec2_profile codec2_prof stm32f4 CMSIS)
-target_compile_definitions(codec2_profile PRIVATE PROFILE)
-elf2bin(codec2_profile)
+#----------------------------
 
 set(DAC_UT_SRCS
 src/dac_ut.c
 )
-
 add_mapped_executable(dac_ut ${DAC_UT_SRCS})
 target_link_libraries(dac_ut stm32f4_adac stm32f4 sm1000base)
 elf2bin(dac_ut)
 
-set(FAST_DAC_UT_SRCS
-src/fast_dac_ut.c
-../src/codec2_fifo.c
-src/iir_duc.c
-src/stm32f4_dacduc.c
-src/debugblinky.c
-)
-
-add_mapped_executable(fast_dac_ut ${FAST_DAC_UT_SRCS} ${SYSTEM_SRCS})
-target_link_libraries(fast_dac_ut stm32f4)
-target_compile_options(fast_dac_ut PRIVATE "-O3")
-elf2bin(fast_dac_ut)
-
-set(ADCDAC_UT_SRCS
-src/adcdac_ut.c
-)
-
-add_mapped_executable(adcdac_ut ${ADCDAC_UT_SRCS} ${STM32F4_ADAC_SRCS} ${SYSTEM_SRCS})
-target_link_libraries(adcdac_ut stm32f4 sm1000base)
-target_compile_options(adcdac_ut PRIVATE "-O0")
-elf2bin(adcdac_ut)
-
-
-set(DAC_PLAY_SRCS
-src/dac_play.c
-../src/codec2_fifo.c
-src/stm32f4_dac.c
-)
-
-add_mapped_executable(dac_play ${DAC_PLAY_SRCS} ${SYSTEM_SRCS})
-target_link_libraries(dac_play stm32f4 sm1000base)
-target_compile_options(dac_play PRIVATE "-O0")
-elf2bin(dac_play)
-
-set(ADC_REC_SRCS
-src/adc_rec.c
-)
-
-add_mapped_executable(adc_rec ${ADC_REC_SRCS})
-target_link_libraries(adc_rec stm32f4_adac stm32f4 sm1000base)
-elf2bin(adc_rec)
-
-set(ADC_SD_SRCS
-src/adc_sd.c
-)
-
-add_mapped_executable(adc_sd ${ADC_SD_SRCS})
-target_link_libraries(adc_sd stm32f4_adac stm32f4 sm1000base)
-elf2bin(adc_sd)
+#----------------------------
 
 set(PWM_UT_SRCS
 src/stm32f4_pwm.c
 )
-
 add_mapped_executable(pwm_ut ${PWM_UT_SRCS})
 target_link_libraries(pwm_ut stm32f4 sm1000base)
 elf2bin(pwm_ut)
 
-# ------------------------------------------------
+#----------------------------
 
 set(USART_UT_SRCS
 src/stm32f4_usart.c
 src/usart_ut.c
 )
-
 add_mapped_executable(usart_ut ${USART_UT_SRCS})
 target_link_libraries(usart_ut stm32f4 sm1000base)
 elf2bin(usart_ut)
 
-# ------------------------------------------------
-
-
-set(POWER_UT_SRCS
-src/power_ut.c
-)
-
-list(APPEND POWER_UT_SRCS ${CODEC2_SRCS})
-
-# stm32/src/power_ut.c:124:5: error: too few arguments to function 'adc_open'
-# stm32/src/power_ut.c:125:5: error: too few arguments to function 'dac_open'
-#add_mapped_executable(power_ut ${POWER_UT_SRCS})
-#target_link_libraries(power_ut stm32f4_adac stm32f4 sm1000base)
+#----------------------------
 
 set(USB_VCP
 usb_conf/usb_bsp.c
@@ -393,27 +306,17 @@ add_mapped_executable(adc_rec_usb ${ADC_REC_USB_SRCS} ${USB_VCP})
 target_link_libraries(adc_rec_usb stm32f4_adac stm32f4 sm1000base)
 elf2bin(adc_rec_usb)
 
-
-set(FDMDV_PROFILE_SRCS
-src/fdmdv_profile.c
-)
-
-list(APPEND FDMDV_PROFILE_SRCS ${CODEC2_SRCS} ${SYSTEM_SRCS})
-
-# Doesn't compile because M_PITCH is not defined but M_PITCH_S is.
-#add_mapped_executable(fdmdv_profile ${FDMDV_PROFILE_SRCS})
-#target_link_libraries(fdmdv_profile stm32f4)
-#target_compile_definitions(fdmdv_profile PRIVATE PROFILE)
+#----------------------------
 
 set(SM1000_LEDS_SWITCHES_UT_SRCS
 src/sm1000_leds_switches_ut.c
 src/sm1000_leds_switches.c
 )
-
 add_mapped_executable(sm1000_leds_switches_ut ${SM1000_LEDS_SWITCHES_UT_SRCS})
 target_link_libraries(sm1000_leds_switches_ut stm32f4 sm1000base)
 elf2bin(sm1000_leds_switches_ut)
 
+#----------------------------
 
 set(SM1000_SRCS
 src/sm1000_main.c
@@ -433,110 +336,11 @@ src/memtools.c
 
 list(APPEND SM1000_SRCS ${CODEC2_SRCS})
 
-
 add_mapped_executable(sm1000v5 ${SM1000_SRCS} ${SYSTEM_SRCS})
 target_link_libraries(sm1000v5 stm32f4_adac stm32f4 CMSIS)
 target_compile_options(sm1000v5 PRIVATE "-O3")
 elf2bin(sm1000v5)
 elf2dfu(sm1000v5)
 
-set(FREEDV_TX_PROFILE_SRCS
-src/freedv_tx_profile.c
-)
-
-add_mapped_executable(freedv_tx_profile ${FREEDV_TX_PROFILE_SRCS} ${PROFILE_SYSTEM_SRCS})
-target_link_libraries(freedv_tx_profile codec2_prof stm32f4 CMSIS)
-target_compile_definitions(freedv_tx_profile PRIVATE PROFILE)
-elf2bin(freedv_tx_profile)
-
-
-set(FREEDV_RX_PROFILE_SRCS
-src/freedv_rx_profile.c
-)
-
-add_mapped_executable(freedv_rx_profile ${FREEDV_RX_PROFILE_SRCS} ${PROFILE_SYSTEM_SRCS})
-target_link_libraries(freedv_rx_profile codec2_prof stm32f4 CMSIS)
-#target_link_libraries(freedv_rx_base "-Wl,-Map=$<TARGET_PROPERTY:NAME>.map")
-elf2bin(freedv_rx_profile)
-
-set(FDMDV_DUMP_RT_SRCS
-src/fdmdv_dump_rt.c
-)
-
-list(APPEND FDMDV_DUMP_RT_SRCS ${CODEC2_SRCS} ${SYSTEM_SRCS})
-
-# Doesn't build due to FREEDV_NSAMPLES not being defined.
-#add_mapped_executable(fdmdv_dump_rt ${FDMDV_DUMP_RT_SRCS})
-#target_link_libraries(fdmdv_dump_rt stm32f4_adac stm32f4 sm1000base)
-#target_compile_options(fdmdv_dump_rt PRIVATE "-O3")
-
-# ---------------------------------------------------------------------------
-
-set(TUNER_UT_SRCS
-src/tuner_ut.c
-src/iir_tuner.c
-../src/fm.c)
-
-# this needs to be compiled without the optimiser or ugly things happen
-# would be nice to work out why as ISRs need to run fast
-
-add_library(stm32f4_adc_tuner STATIC src/stm32f4_adc_tuner.c)
-add_mapped_executable(tuner_ut ${TUNER_UT_SRCS} ${SYSTEM_SRCS})
-target_compile_options(tuner_ut PRIVATE "-O3")
-target_link_libraries(tuner_ut stm32f4_adc_tuner stm32f4_adac stm32f4 sm1000base)
-elf2bin(tuner_ut)
-
-# -----------------------------------------------------------------------------
-
-set(ADC_SFDR_UT_SRCS
-src/adc_sfdr_ut.c
-src/iir_tuner.c
-)
-
-add_mapped_executable(adc_sfdr_ut ${ADC_SFDR_UT_SRCS})
-target_link_libraries(adc_sfdr_ut stm32f4_adc_tuner stm32f4_adac stm32f4 sm1000base CMSIS)
-elf2bin(adc_sfdr_ut)
-
-# -----------------------------------------------------------------------------
-
-#set(FM_LODUC_PLAY_SRCS
-#src/fm_loduc_play.c
-#gdb_stdio.c
-#../src/codec2_fifo.c
-#../src/fm.c
-#src/debugblinky.c
-#src/system_stm32f4xx.c
-#src/startup_stm32f4xx.s
-#)
-
-#add_library(stm32f4_dacloduc STATIC src/stm32f4_dacloduc.c)
-
-#add_mapped_executable(fm_loduc_play ${FM_LODUC_PLAY_SRCS})
-#target_link_libraries(fm_loduc_play stm32f4_dacloduc)
-
-# -----------------------------------------------------------------------------
-
-set(SI5351_UT_SRCS
-src/si5351_ut.c
-src/new_i2c.c
-src/si53xx.c
-)
-
-add_mapped_executable(si5351_ut ${SI5351_UT_SRCS})
-target_link_libraries(si5351_ut stm32f4 sm1000base)
-elf2bin(si5351_ut)
-
-# -----------------------------------------------------------------------------
-
-set(MCO_UT_SRCS
-src/mco_ut.c
-src/tm_stm32f4_mco_output.c
-src/tm_stm32f4_gpio.c
-)
-
-add_mapped_executable(mco_ut ${MCO_UT_SRCS})
-target_link_libraries(mco_ut stm32f4 sm1000base)
-elf2bin(mco_ut)
 
-# -----------------------------------------------------------------------------
 
diff --git a/stm32/src/adc_rec.c b/stm32/src/adc_rec.c
deleted file mode 100644
index 1fba194f..00000000
--- a/stm32/src/adc_rec.c
+++ /dev/null
@@ -1,76 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: adc_rec.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 30 May 2014
-
-  Records a 16 kHz sample rate raw file from one of the ADC channels,
-  which are connected to pins PA1 (ADC1) and PA2 (ADC2).
-
-  Note the semi-hosting system isn't fast enough to transfer 2 16 kHz
-  streams at once.
-
-  ~/stlink$ sudo ./st-util -f ~/codec2-dev/stm32/adc_rec.elf
-  ~/codec2-dev/stm32$ ~/gcc-arm-none-eabi-4_7-2013q1/bin/arm-none-eabi-gdb adc_rec.elf
-
-  (when finished)
-  $ play -r 16000 -s -2 ~/stlink/adc.raw
-
-  adc1 -> "from radio"
-  adc2 -> "mic amp"
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2014 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <stdlib.h>
-#include "stm32f4_adc.h"
-#include "gdb_stdio.h"
-#include "stm32f4xx_gpio.h"
-
-#define REC_TIME_SECS 10
-#define  N  (ADC_BUF_SZ*6)
-#define FS  16000
-
-extern int adc_overflow1;
-extern int adc_overflow2;
-
-int main(void){
-    short  buf[N];
-    FILE  *fadc;
-    int    i, bufs;
-
-    fadc = fopen("adc.raw", "wb");
-    if (fadc == NULL) {
-        printf("Error opening input file: adc.raw\n\nTerminating....\n");
-        exit(1);
-    }
-    bufs = FS*REC_TIME_SECS/N;
-
-    printf("Starting!\n");
-    adc_open(ADC_FS_16KHZ, 4*N, NULL, NULL);
-
-    for(i=0; i<bufs; i++) {
-        while(adc2_read(buf, N) == -1);
-        fwrite(buf, sizeof(short), N, fadc);
-        printf("adc_overflow1: %d  adc_overflow2: %d   \n", adc_overflow1, adc_overflow2);
-    }
-    fclose(fadc);
-
-    printf("Finished!\n");
-}
diff --git a/stm32/src/adc_sd.c b/stm32/src/adc_sd.c
deleted file mode 100644
index 935f719e..00000000
--- a/stm32/src/adc_sd.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: adc_sd.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 30 May 2014
-
-  Measures the std deviation of the ADC signals.  Used to check noise
-  levels on each ADC.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2014 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <stdlib.h>
-#include <math.h>
-#include "stm32f4_adc.h"
-#include "stm32f4_dac.h"
-#include "gdb_stdio.h"
-
-#define REC_TIME_SECS 10
-#define  N  (ADC_BUF_SZ*4)
-#define FS  16000
-
-static float calc_sd(short x[], int n) {
-    float sum, mean, sum_diff, sd;
-    int   i;
-
-    sum = 0.0;
-    for(i=0; i<n;i++) {
-        sum += (float)x[i];
-    }
-    mean = sum/n;
-
-    sum_diff = 0.0;
-    for(i=0; i<n;i++) {
-        sum_diff += ((float)x[i] - mean)*((float)x[i] - mean);
-    }
-
-    sd = sqrtf(sum_diff/n);
-
-    return sd;
-}
-
-int main(void){
-    short  buf[N];
-    float  sd1, sd2;
-
-    adc_open(ADC_FS_16KHZ, 2*N, NULL, NULL);
-
-    printf("Starting!\n");
-    while(1) {
-        while(adc1_read(buf, N) == -1);
-        sd1 = calc_sd(buf, N);
-        while(adc2_read(buf, N) == -1);
-        sd2 = calc_sd(buf, N);
-
-        printf("adc1: %5.1f adc2: %5.1f\n", (double)sd1, (double)sd2);
-    }
-
-}
diff --git a/stm32/src/adc_sfdr_ut.c b/stm32/src/adc_sfdr_ut.c
deleted file mode 100644
index d0900349..00000000
--- a/stm32/src/adc_sfdr_ut.c
+++ /dev/null
@@ -1,89 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: adc_sfdr_ut.c
-  AUTHOR......: David Rowe
-  DATE CREATED: August 2015
-
-  Unit test for high speed ADC SFDR testing.  Samples ADC1 from in PA1 at
-  Fs=2 MHz and write raw samples to a file, in discontinuus blocks of
-  ADC_TUNER_BUF_SZ/2 samples.  The blocks are discontinuous as we
-  don'thave the bandwitdh back to the host to support continuous sampling.
-
-  To process the blocks, fread() ADC_TUNER_BUF_SZ/2 samples at a time,
-  abs(fft) and sum results from next block.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2015 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <assert.h>
-#include <stdlib.h>
-#include "gdb_stdio.h"
-#include "stm32f4_dac.h"
-#include "stm32f4_adc_tuner.h"
-#include "iir_tuner.h"
-#include "sm1000_leds_switches.h"
-#include "../src/codec2_fm.h"
-#include "stm32f4xx.h"
-
-#define BUFS          10
-#define FS            2E6
-#define N             1024
-
-extern int adc_overflow1;
-
-int main(void) {
-    unsigned short unsigned_buf[N];
-    short          buf[N];
-    int            sam;
-    int            i, j, fifo_sz;
-    FILE          *fadc;
-
-    fadc = fopen("adc.raw", "wb");
-    if (fadc == NULL) {
-        printf("Error opening output file: adc.raw\n\nTerminating....\n");
-        exit(1);
-    }
-    fifo_sz = ADC_TUNER_BUF_SZ;
-    printf("Starting! bufs: %d %d\n", BUFS, fifo_sz);
-
-    adc_open(fifo_sz);
-    adc_set_tuner_en(0); /* dump raw samples, no tuner */
-
-    sm1000_leds_switches_init();
-
-    for (i=0; i<BUFS; i++) {
-        while(adc1_read((short*)unsigned_buf, N) == -1);
-
-        /* convert to signed */
-
-        for(j=0; j<N; j++) {
-            sam = (int)unsigned_buf[j] - 32768;
-            buf[j] = sam;
-        }
-
-        /* most of the time will be spent here */
-
-        GPIOE->ODR |= (1 << 3);
-        fwrite(buf, sizeof(short), N, fadc);
-        GPIOE->ODR &= ~(1 << 3);
-    }
-    fclose(fadc);
-
-    printf("Finished!\n");
-}
diff --git a/stm32/src/adcdac_ut.c b/stm32/src/adcdac_ut.c
deleted file mode 100644
index 77f8c4e7..00000000
--- a/stm32/src/adcdac_ut.c
+++ /dev/null
@@ -1,70 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: adcdac_ut.c
-  AUTHOR......: David Rowe
-  DATE CREATED: May 31 201310 Aug 2014
-
-  Echoes ADC2 input (mic) to DAC2 output (speaker) on SM1000.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2013 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <assert.h>
-#include "stm32f4_dac.h"
-#include "stm32f4_adc.h"
-#include "sm1000_leds_switches.h"
-
-#define SINE_SAMPLES   32
-
-
-/* 32 sample sine wave which at Fs=16kHz will be 500Hz.  Note samples
-   are 16 bit 2's complement, the DAC driver convertsto 12 bit
-   unsigned. */
-
-short aSine[] = {
-     -16,    6384,   12528,   18192,   23200,   27232,   30256,   32128,
-   32752,   32128,   30256,   27232,   23152,   18192,   12528,    6384,
-     -16,   -6416,  -12560,  -18224,  -23184,  -27264,  -30288,  -32160,
-  -32768,  -32160,  -30288,  -27264,  -23184,  -18224,  -12560,   -6416
-};
-
-int main(void) {
-    short buf[SINE_SAMPLES];
-    int   i;
-
-    dac_open(ADC_FS_16KHZ,4*DAC_BUF_SZ, 0, 0);
-    adc_open(ADC_FS_16KHZ, 4*ADC_BUF_SZ, 0, 0);
-    sm1000_leds_switches_init();
-
-    while (1) {
-
-        /* keep DAC FIFOs topped up */
-
-        while(adc2_read(buf, SINE_SAMPLES) == -1);
-
-        if (!switch_select()) {
-            for(i=0; i<SINE_SAMPLES; i++)
-                buf[i] = aSine[i];
-        }
-
-        dac2_write(buf, SINE_SAMPLES, 0);
-    }
-
-}
-
diff --git a/stm32/src/dac_play.c b/stm32/src/dac_play.c
deleted file mode 100644
index b9604351..00000000
--- a/stm32/src/dac_play.c
+++ /dev/null
@@ -1,63 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: dac_play.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 1 June 2013
-
-  Plays a 16 kHz sample rate raw file to the STM32F4 DACs. DAC1 is
-  connected to pin PA4, DAC2 is connected to pin PA5.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2013 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <stdlib.h>
-#include "stm32f4_dac.h"
-#include "gdb_stdio.h"
-
-#define N    (5*DAC_BUF_SZ)
-
-int main(void) {
-    short  buf[N];
-    FILE  *fplay;
-
-    dac_open(DAC_FS_16KHZ, 2*N, NULL, NULL);
-
-    while(1) {
-        fplay = fopen("stm_in.raw", "rb");
-        if (fplay == NULL) {
-            printf("Error opening input file: stm_in.raw\n\nTerminating....\n");
-            exit(1);
-        }
-
-        printf("Starting!\n");
-
-        while(fread(buf, sizeof(short), N, fplay) == N) {
-            while(dac1_write(buf, N, 0) == -1);
-            while(dac2_write(buf, N, 0) == -1);
-        }
-
-        printf("Finished!\n");
-        fclose(fplay);
-    }
-
-    /* let FIFO empty */
-
-    while(1);
-}
-
diff --git a/stm32/src/dac_ut_fast.c b/stm32/src/dac_ut_fast.c
deleted file mode 100644
index 9c750594..00000000
--- a/stm32/src/dac_ut_fast.c
+++ /dev/null
@@ -1,37 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: dac_ut_fast.c
-  AUTHOR......: David Rowe
-  DATE CREATED: Sep 2015
-
-  Plays a Fs/4 sine wave sampled out of PA5 on a Discovery board, used for 
-  testing high speed DAC operation, e.g. for IF/RF generation.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2015 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <assert.h>
-#include "stm32f4_dac.h"
-
-
-int main(void) {
-    dac_open(4*DAC_BUF_SZ);
-    while (1);
-}
-
diff --git a/stm32/src/fdmdv_dump_rt.c b/stm32/src/fdmdv_dump_rt.c
deleted file mode 100644
index 52ca9771..00000000
--- a/stm32/src/fdmdv_dump_rt.c
+++ /dev/null
@@ -1,154 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: fdmdv_dump_rt.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 9 Sep 2014
-
- Runs the fdmdv demod in real time for a few seconds then dumps some
- modem info to a text file for plotting in Octave.  Way to verify the
- "from radio" SM1000 hardware, ADC, and demod on the SM1000.
-
- Requires FreeDV signal to be sent to CN6 of SM1000.
-
- Octave:
-
-   load scatter.txt
-   l=length(scatter)
-   plot(scatter(:,1:2:l),scatter(:,2:2:l),'+')
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2014 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <math.h>
-
-#include <stm32f4xx_gpio.h>
-#include "stm32f4_adc.h"
-#include "stm32f4_dac.h"
-#include "freedv_api.h"
-#include "codec2_fdmdv.h"
-#include "sm1000_leds_switches.h"
-#include "gdb_stdio.h"
-
-#ifdef __EMBEDDED__
-#define printf gdb_stdio_printf
-#define fprintf gdb_stdio_fprintf
-#define fopen gdb_stdio_fopen
-#define fclose gdb_stdio_fclose
-#define fread gdb_stdio_fread
-#define fwrite gdb_stdio_fwrite
-#endif
-
-#define FREEDV_NSAMPLES_16K (2*FREEDV_NSAMPLES)
-#define START_LOG_FRAMES 100
-#define LOG_FRAMES       10
-#define STOP_LOG_FRAMES  (START_LOG_FRAMES+LOG_FRAMES)
-#define NC  16
-
-int main(void) {
-    struct freedv *f;
-    short          adc16k[FDMDV_OS_TAPS_16K+FREEDV_NSAMPLES_16K];
-    short          dac16k[FREEDV_NSAMPLES_16K];
-    short          adc8k[FREEDV_NSAMPLES];
-    short          dac8k[FDMDV_OS_TAPS_8K+FREEDV_NSAMPLES];
-
-    int            nin, nout, i, j, frames, lines;
-
-    COMP          *symb, *psymb;
-
-    /* init all the drivers for various peripherals */
-
-    sm1000_leds_switches_init();
-    dac_open(4*DAC_BUF_SZ);
-    adc_open(4*ADC_BUF_SZ);
-    f = freedv_open(FREEDV_MODE_1600);
-
-    /* clear filter memories */
-
-    for(i=0; i<FDMDV_OS_TAPS_16K; i++)
-	adc16k[i] = 0.0;
-    for(i=0; i<FDMDV_OS_TAPS_8K; i++)
-	dac8k[i] = 0.0;
-
-    /* allocate storage for the symbols */
-
-#define TMP
-#ifdef TMP
-    symb = (COMP*)malloc(sizeof(COMP)*(NC+1)*(STOP_LOG_FRAMES - START_LOG_FRAMES));
-    assert(symb != NULL);
-    psymb = symb;
-    frames = 0;
-    lines = 0;
-#endif
-    while(1)  {
-
-        /* Receive --------------------------------------------------------------------------*/
-
-        /* ADC1 is the demod in signal from the radio rx, DAC2 is the SM1000 speaker */
-
-        nin = freedv_nin(f);
-        nout = nin;
-        f->total_bit_errors = 0;
-
-        if (adc1_read(&adc16k[FDMDV_OS_TAPS_16K], 2*nin) == 0) {
-            GPIOE->ODR = (1 << 3);
-            fdmdv_16_to_8_short(adc8k, &adc16k[FDMDV_OS_TAPS_16K], nin);
-            nout = freedv_rx(f, &dac8k[FDMDV_OS_TAPS_8K], adc8k);
-            fdmdv_8_to_16_short(dac16k, &dac8k[FDMDV_OS_TAPS_8K], nout);
-            dac2_write(dac16k, 2*nout);
-            led_ptt(0); led_rt(f->fdmdv_stats.sync); led_err(f->total_bit_errors);
-            GPIOE->ODR &= ~(1 << 3);
-
-#define TMP1
-#ifdef TMP1
-            if (f->fdmdv_stats.sync)
-                frames++;
-            if ((frames >= START_LOG_FRAMES) && (lines < LOG_FRAMES)) {
-                for(i=0; i<=f->fdmdv_stats.Nc; i++)
-                    psymb[i] = f->fdmdv_stats.rx_symbols[i];
-                psymb += (f->fdmdv_stats.Nc+1);
-                lines++;
-            }
-
-            if (frames >= STOP_LOG_FRAMES) {
-                FILE *ft = fopen("scatter.txt", "wt");
-                assert(ft != NULL);
-                printf("Writing scatter file....\n");
-                for(j=0; j<LOG_FRAMES; j++) {
-                    for(i=0; i<=f->fdmdv_stats.Nc; i++) {
-                        fprintf(ft, "%f\t%f\t",
-                                (double)symb[j*(f->fdmdv_stats.Nc+1)+i].real,
-                                (double)symb[j*(f->fdmdv_stats.Nc+1)+i].imag);
-                        printf("line: %d\n", j);
-                    }
-                    fprintf(ft, "\n");
-                }
-                fclose(ft);
-                printf("SNR = %3.2f dB\nfinished!\n", (double)f->fdmdv_stats.snr_est);
-                while(1);
-            }
-#endif
-        }
-
-    } /* while(1) ... */
-}
-
diff --git a/stm32/src/fft_test.c b/stm32/src/fft_test.c
deleted file mode 100644
index 7bb2fe6c..00000000
--- a/stm32/src/fft_test.c
+++ /dev/null
@@ -1,435 +0,0 @@
-/* ----------------------------------------------------------------------
-* Copyright (C) 2010 ARM Limited. All rights reserved.
-*
-* $Date:        29. November 2010
-* $Revision: 	V1.0.3
-*
-* Project: 	    CMSIS DSP Library
-* Title:	    arm_fft_bin_example_f32.c
-*
-* Description:	Example code demonstrating calculation of Max energy bin of
-*				frequency domain of input signal.
-*
-* Target Processor: Cortex-M4/Cortex-M3
-*
-*
-* Version 1.0.3 2010/11/29
-*    Re-organized the CMSIS folders and updated documentation.
-*
-* Version 1.0.1 2010/10/05 KK
-*    Production release and review comments incorporated.
-*
-* Version 1.0.0 2010/09/20 KK
-*    Production release and review comments incorporated.
-* ------------------------------------------------------------------- */
-
-/**
- * @ingroup groupExamples
- */
-
-/**
- * @defgroup FrequencyBin Frequency Bin Example
- *
- * \par Description
- * \par
- * Demonstrates the calculation of the maximum energy bin in the frequency
- * domain of the input signal with the use of Complex FFT, Complex
- * Magnitude, and Maximum functions.
- *
- * \par Algorithm:
- * \par
- * The input test signal contains a 10 kHz signal with uniformly distributed white noise.
- * Calculating the FFT of the input signal will give us the maximum energy of the
- * bin corresponding to the input frequency of 10 kHz.
- *
- * \par Block Diagram:
- * \image html FFTBin.gif "Block Diagram"
- * \par
- * The figure below shows the time domain signal of 10 kHz signal with
- * uniformly distributed white noise, and the next figure shows the input
- * in the frequency domain. The bin with maximum energy corresponds to 10 kHz signal.
- * \par
- * \image html FFTBinInput.gif "Input signal in Time domain"
- * \image html FFTBinOutput.gif "Input signal in Frequency domain"
- *
- * \par Variables Description:
- * \par
- * \li \c testInput_f32_10khz points to the input data
- * \li \c testOutput points to the output data
- * \li \c fftSize length of FFT
- * \li \c ifftFlag flag for the selection of CFFT/CIFFT
- * \li \c doBitReverse Flag for selection of normal order or bit reversed order
- * \li \c refIndex reference index value at which maximum energy of bin ocuurs
- * \li \c testIndex calculated index value at which maximum energy of bin ocuurs
- *
- * \par CMSIS DSP Software Library Functions Used:
- * \par
- * - arm_cfft_radix4_init_f32()
- * - arm_cfft_radix4_f32()
- * - arm_cmplx_mag_f32()
- * - arm_max_f32()
- *
- * <b> Refer  </b>
- * \link arm_fft_bin_example_f32.c \endlink
- *
- */
-
-
-/** \example arm_fft_bin_example_f32.c
-  */
-
-
-#include "arm_math.h"
-#include "gdb_stdio.h"
-#include "machdep.h"
-#include "kiss_fft.h"
-
-#define TEST_LENGTH_SAMPLES 1024
-
-/* -------------------------------------------------------------------
-* External Input and Output buffer Declarations for FFT Bin Example
-* ------------------------------------------------------------------- */
-extern float32_t testInput_f32_10khz[2048];
-static float32_t testOutput[TEST_LENGTH_SAMPLES/2];
-static float32_t kiss_complex_out[TEST_LENGTH_SAMPLES];
-
-/* ------------------------------------------------------------------
-* Global variables for FFT Bin Example
-* ------------------------------------------------------------------- */
-uint32_t fftSize = TEST_LENGTH_SAMPLES/2;
-uint32_t ifftFlag = 0;
-uint32_t doBitReverse = 1;
-
-/* Reference index at which max energy of bin ocuurs */
-uint32_t refIndex = 213, testIndex = 0;
-
-/* ----------------------------------------------------------------------
-* Max magnitude FFT Bin test
-* ------------------------------------------------------------------- */
-
-void SystemInit(void);
-
-int main(void)
-{
-
-	arm_status status;
-	arm_cfft_radix2_instance_f32 S;
-	float32_t maxValue;
-        unsigned int fft_start, kiss_fft_start;
-        kiss_fft_cfg fft_fwd_cfg;
-
-        SystemInit();
-        machdep_profile_init();
-        fft_fwd_cfg = kiss_fft_alloc(fftSize, 0, NULL, NULL);
-        kiss_fft_start = machdep_profile_sample();
-        kiss_fft(fft_fwd_cfg, (kiss_fft_cpx *)testInput_f32_10khz,
-                 (kiss_fft_cpx *)kiss_complex_out);
-        machdep_profile_sample_and_log(kiss_fft_start, "  kiss_fft");
-
-	status = ARM_MATH_SUCCESS;
-
-	/* Initialize the CFFT/CIFFT module */
-	status = arm_cfft_radix2_init_f32(&S, fftSize, ifftFlag, doBitReverse);
-
-	/* Process the data through the CFFT/CIFFT module */
-        fft_start = machdep_profile_sample();
-        arm_cfft_radix2_f32(&S, testInput_f32_10khz);
-        machdep_profile_sample_and_log(fft_start, "  fft");
-        machdep_profile_print_logged_samples();
-
-	/* Process the data through the Complex Magnitude Module for
-	calculating the magnitude at each bin */
-	arm_cmplx_mag_f32(testInput_f32_10khz, testOutput,fftSize);
-
-	/* Calculates maxValue and returns corresponding BIN value */
-	arm_max_f32(testOutput, fftSize, &maxValue, &testIndex);
-
-	if(testIndex !=  refIndex)
-	{
-		status = ARM_MATH_TEST_FAILURE;
-	}
-
-	/* ----------------------------------------------------------------------
-	** Loop here if the signals fail the PASS check.
-	** This denotes a test failure
-	** ------------------------------------------------------------------- */
-
-	if( status != ARM_MATH_SUCCESS)
-	{
-		while(1);
-	}
-
-    while(1);                             /* main function does not return */
-
-    return 0;
-}
-
- /** \endlink */
-
-
-/* ----------------------------------------------------------------------
-Test Input signal contains 10KHz signal + Uniformly distributed white noise
-** ------------------------------------------------------------------- */
-
-float32_t testInput_f32_10khz[2048] = 
-{   
--0.865129623056441, 	0.000000000000000, 	-2.655020678073846, 	0.000000000000000, 	0.600664612949661, 	0.000000000000000, 	0.080378093886515, 	0.000000000000000, 	
--2.899160484012034, 	0.000000000000000, 	2.563004262857762, 	0.000000000000000, 	3.078328403304206, 	0.000000000000000, 	0.105906778385130, 	0.000000000000000, 	
-0.048366940168201, 	0.000000000000000, 	-0.145696461188734, 	0.000000000000000, 	-0.023417155362879, 	0.000000000000000, 	2.127729174988954, 	0.000000000000000, 	
--1.176633086028377, 	0.000000000000000, 	3.690223557991855, 	0.000000000000000, 	-0.622791766173194, 	0.000000000000000, 	0.722837373872203, 	0.000000000000000, 	
-2.739754205367484, 	0.000000000000000, 	-0.062610410524552, 	0.000000000000000, 	-0.891296810967338, 	0.000000000000000, 	-1.845872258871811, 	0.000000000000000, 	
-1.195039415434387, 	0.000000000000000, 	-2.177388969045026, 	0.000000000000000, 	1.078649103637905, 	0.000000000000000, 	2.570976050490193, 	0.000000000000000, 	
--1.383551403404574, 	0.000000000000000, 	2.392141424058873, 	0.000000000000000, 	2.858002843205065, 	0.000000000000000, 	-3.682433899725536, 	0.000000000000000, 	
--3.488146646451150, 	0.000000000000000, 	1.323468578888120, 	0.000000000000000, 	-0.099771155430726, 	0.000000000000000, 	1.561168082500454, 	0.000000000000000, 	
-1.025026795103179, 	0.000000000000000, 	0.928841900171200, 	0.000000000000000, 	2.930499509864950, 	0.000000000000000, 	2.013349089766430, 	0.000000000000000, 	
-2.381676148486737, 	0.000000000000000, 	-3.081062307950236, 	0.000000000000000, 	-0.389579115537544, 	0.000000000000000, 	0.181540149166620, 	0.000000000000000, 	
--2.601953341353208, 	0.000000000000000, 	0.333435137783218, 	0.000000000000000, 	-2.812945856162965, 	0.000000000000000, 	2.649109640172910, 	0.000000000000000, 	
--1.003963025744654, 	0.000000000000000, 	1.552460768755035, 	0.000000000000000, 	0.088641345335247, 	0.000000000000000, 	-2.519951327113426, 	0.000000000000000, 	
--4.341348988610527, 	0.000000000000000, 	0.557772429359965, 	0.000000000000000, 	-1.671267412948494, 	0.000000000000000, 	0.733951350960387, 	0.000000000000000, 	
-0.409263788034864, 	0.000000000000000, 	3.566033071952806, 	0.000000000000000, 	1.882565173848352, 	0.000000000000000, 	-1.106017073793287, 	0.000000000000000, 	
-0.154456720778718, 	0.000000000000000, 	-2.513205795512153, 	0.000000000000000, 	0.310978660939421, 	0.000000000000000, 	0.579706500111723, 	0.000000000000000, 	
-0.000086383683251, 	0.000000000000000, 	-1.311866980897721, 	0.000000000000000, 	1.840007477574986, 	0.000000000000000, 	-3.253005768451345, 	0.000000000000000, 	
-1.462584328739432, 	0.000000000000000, 	1.610103610851738, 	0.000000000000000, 	0.761914676858907, 	0.000000000000000, 	0.974541361089834, 	0.000000000000000, 	
-0.686845845885983, 	0.000000000000000, 	1.849153122025191, 	0.000000000000000, 	0.787800410401453, 	0.000000000000000, 	-1.187438909666279, 	0.000000000000000, 	
--0.754937911044720, 	0.000000000000000, 	0.084373858395232, 	0.000000000000000, 	-2.600269011710521, 	0.000000000000000, 	-0.962982842142644, 	0.000000000000000, 	
--0.369328108540868, 	0.000000000000000, 	0.810791418361879, 	0.000000000000000, 	3.587016488699641, 	0.000000000000000, 	-0.520776145083723, 	0.000000000000000, 	
-0.640249919627884, 	0.000000000000000, 	1.103122489464969, 	0.000000000000000, 	2.231779881455556, 	0.000000000000000, 	-1.308035392685241, 	0.000000000000000, 	
-0.424070304330106, 	0.000000000000000, 	-0.200383932651189, 	0.000000000000000, 	-2.365526783356541, 	0.000000000000000, 	-0.989114757436628, 	0.000000000000000, 	
-2.770807688959777, 	0.000000000000000, 	-0.444172737462307, 	0.000000000000000, 	0.079760979374078, 	0.000000000000000, 	-0.005199118412183, 	0.000000000000000, 	
--0.664712668309527, 	0.000000000000000, 	-0.624171857561896, 	0.000000000000000, 	0.537306979007338, 	0.000000000000000, 	-2.575955675497642, 	0.000000000000000, 	
-1.562363235756780, 	0.000000000000000, 	1.814069369848895, 	0.000000000000000, 	-1.293428583392509, 	0.000000000000000, 	-1.026188449495686, 	0.000000000000000, 	
--2.981771815588717, 	0.000000000000000, 	-4.223468103075124, 	0.000000000000000, 	2.672674782004045, 	0.000000000000000, 	-0.856096801117735, 	0.000000000000000, 	
-0.048517345512563, 	0.000000000000000, 	-0.026860721136222, 	0.000000000000000, 	0.392932277758187, 	0.000000000000000, 	-1.331740855093099, 	0.000000000000000, 	
--1.894292129477081, 	0.000000000000000, 	-1.425006468460681, 	0.000000000000000, 	-2.721772427617057, 	0.000000000000000, 	-1.616831100216806, 	0.000000000000000, 	
-3.551177651488947, 	0.000000000000000, 	-0.069685667896087, 	0.000000000000000, 	-3.134634907409102, 	0.000000000000000, 	-0.263627598944639, 	0.000000000000000, 	
--1.650469945991350, 	0.000000000000000, 	-2.203580339374399, 	0.000000000000000, 	-0.872203246123242, 	0.000000000000000, 	1.230782812607287, 	0.000000000000000, 	
-0.257288860093291, 	0.000000000000000, 	1.989083106173137, 	0.000000000000000, 	-1.985638729453261, 	0.000000000000000, 	-1.416185105842892, 	0.000000000000000, 	
--1.131097688325772, 	0.000000000000000, 	-2.245130805416057, 	0.000000000000000, 	-1.938873996219074, 	0.000000000000000, 	2.043608361562645, 	0.000000000000000, 	
--0.583727989880841, 	0.000000000000000, 	-1.785266378212929, 	0.000000000000000, 	1.961457586224753, 	0.000000000000000, 	1.139400099963223, 	0.000000000000000, 	
--1.979519343363991, 	0.000000000000000, 	2.003023322818429, 	0.000000000000000, 	0.229004069076829, 	0.000000000000000, 	3.452808862193135, 	0.000000000000000, 	
-2.882273808365857, 	0.000000000000000, 	-1.549450501844438, 	0.000000000000000, 	-3.283872089931876, 	0.000000000000000, 	-0.327025884099064, 	0.000000000000000, 	
--0.054979977136430, 	0.000000000000000, 	-1.192280531479012, 	0.000000000000000, 	0.645539328365578, 	0.000000000000000, 	2.300832863404618, 	0.000000000000000, 	
--1.092951789535240, 	0.000000000000000, 	-1.017368249363773, 	0.000000000000000, 	-0.142673056169787, 	0.000000000000000, 	0.831073544881250, 	0.000000000000000, 	
--2.314612531587064, 	0.000000000000000, 	-2.221456299106321, 	0.000000000000000, 	0.460261143885226, 	0.000000000000000, 	0.050585301888595, 	0.000000000000000, 	
-0.364373329183988, 	0.000000000000000, 	-1.685956552069538, 	0.000000000000000, 	0.050664512351055, 	0.000000000000000, 	-0.193355783902718, 	0.000000000000000, 	
--0.158660446046828, 	0.000000000000000, 	2.394156453841953, 	0.000000000000000, 	-1.562965718554525, 	0.000000000000000, 	-2.199750600869900, 	0.000000000000000, 	
-1.544984022381773, 	0.000000000000000, 	-1.988307216807315, 	0.000000000000000, 	-0.628240722541046, 	0.000000000000000, 	-1.436235771505429, 	0.000000000000000, 	
-1.677013691147313, 	0.000000000000000, 	1.600741781678228, 	0.000000000000000, 	-0.757380959134706, 	0.000000000000000, 	-4.784797439515566, 	0.000000000000000, 	
-0.265121462834569, 	0.000000000000000, 	3.862029485934378, 	0.000000000000000, 	2.386823577249430, 	0.000000000000000, 	-3.655779745436893, 	0.000000000000000, 	
--0.763541621368016, 	0.000000000000000, 	-1.182140388432962, 	0.000000000000000, 	-1.349106114858063, 	0.000000000000000, 	-2.287533624396759, 	0.000000000000000, 	
--0.028603745188423, 	0.000000000000000, 	-1.353580755934427, 	0.000000000000000, 	0.461602380352937, 	0.000000000000000, 	-0.059599055078928, 	0.000000000000000, 	
--0.929946734342228, 	0.000000000000000, 	0.065773089295561, 	0.000000000000000, 	1.106565863102982, 	0.000000000000000, 	4.719295086373593, 	0.000000000000000, 	
--2.108377703544395, 	0.000000000000000, 	-2.226393620240159, 	0.000000000000000, 	1.375668397437521, 	0.000000000000000, 	-0.960772428525443, 	0.000000000000000, 	
--2.156313465390571, 	0.000000000000000, 	1.126060012375311, 	0.000000000000000, 	2.756485137030720, 	0.000000000000000, 	0.739639690862600, 	0.000000000000000, 	
-3.914769510295006, 	0.000000000000000, 	1.685232785586675, 	0.000000000000000, 	4.079058040970612, 	0.000000000000000, 	-1.174598301660513, 	0.000000000000000, 	
--2.885776587275580, 	0.000000000000000, 	-0.241073635188767, 	0.000000000000000, 	3.080489872502403, 	0.000000000000000, 	-2.051244183999421, 	0.000000000000000, 	
-0.664330486845139, 	0.000000000000000, 	-1.697798999370016, 	0.000000000000000, 	1.452369423649782, 	0.000000000000000, 	-1.523532831019280, 	0.000000000000000, 	
-0.171981186587481, 	0.000000000000000, 	-4.685274721583927, 	0.000000000000000, 	-1.336175835319380, 	0.000000000000000, 	1.419070770428945, 	0.000000000000000, 	
--0.035791601713475, 	0.000000000000000, 	2.291937971632081, 	0.000000000000000, 	-1.962559313450293, 	0.000000000000000, 	-4.831595589339301, 	0.000000000000000, 	
--1.857055284000925, 	0.000000000000000, 	2.606271522635512, 	0.000000000000000, 	-0.576447978738030, 	0.000000000000000, 	0.082299166967720, 	0.000000000000000, 	
-1.888399453494614, 	0.000000000000000, 	-3.564705298046079, 	0.000000000000000, 	-0.939357831083889, 	0.000000000000000, 	-1.903578203697778, 	0.000000000000000, 	
--2.642492215447250, 	0.000000000000000, 	-0.182990405251017, 	0.000000000000000, 	3.742026478011174, 	0.000000000000000, 	0.104295803798333, 	0.000000000000000, 	
-1.848678195370347, 	0.000000000000000, 	-1.887384346896369, 	0.000000000000000, 	0.365048973046045, 	0.000000000000000, 	-0.889638010354219, 	0.000000000000000, 	
-1.173877118428863, 	0.000000000000000, 	-1.178562827540109, 	0.000000000000000, 	0.610271645685184, 	0.000000000000000, 	1.831284815697871, 	0.000000000000000, 	
-0.449575390102283, 	0.000000000000000, 	1.597171905253443, 	0.000000000000000, 	3.918574971904773, 	0.000000000000000, 	0.868104027970404, 	0.000000000000000, 	
-0.582643134746494, 	0.000000000000000, 	2.321256382353331, 	0.000000000000000, 	-0.238118642223180, 	0.000000000000000, 	-2.890287868054370, 	0.000000000000000, 	
-0.970995414625622, 	0.000000000000000, 	0.666137930891283, 	0.000000000000000, 	-0.202435718709502, 	0.000000000000000, 	2.057930200518194, 	0.000000000000000, 	
-3.120583443719949, 	0.000000000000000, 	-0.863945271701041, 	0.000000000000000, 	0.906848893874630, 	0.000000000000000, 	-1.434124930222570, 	0.000000000000000, 	
-0.754659384848783, 	0.000000000000000, 	-5.224154442713778, 	0.000000000000000, 	2.330229744098967, 	0.000000000000000, 	1.113946320164698, 	0.000000000000000, 	
-0.523324920322840, 	0.000000000000000, 	1.750740911548348, 	0.000000000000000, 	-0.899333972913577, 	0.000000000000000, 	0.228705845203506, 	0.000000000000000, 	
--1.934782624767648, 	0.000000000000000, 	-3.508386237231303, 	0.000000000000000, 	-2.107108523073510, 	0.000000000000000, 	0.380587645474815, 	0.000000000000000, 	
--0.476200877183279, 	0.000000000000000, 	-2.172086712642198, 	0.000000000000000, 	1.795372535780299, 	0.000000000000000, 	-2.100318983391055, 	0.000000000000000, 	
--0.022571122461405, 	0.000000000000000, 	0.674514020010955, 	0.000000000000000, 	-0.148872569390857, 	0.000000000000000, 	0.298175890592737, 	0.000000000000000, 	
--1.134244492493590, 	0.000000000000000, 	-3.146848422289455, 	0.000000000000000, 	-1.357950199087602, 	0.000000000000000, 	0.667362732020878, 	0.000000000000000, 	
--3.119397998316724, 	0.000000000000000, 	-1.189341126297637, 	0.000000000000000, 	-1.532744386856668, 	0.000000000000000, 	-1.672972484202534, 	0.000000000000000, 	
--2.042283373871558, 	0.000000000000000, 	-1.479481547595924, 	0.000000000000000, 	-0.002668662875396, 	0.000000000000000, 	0.262737760129546, 	0.000000000000000, 	
-2.734456080621830, 	0.000000000000000, 	-0.671945925075102, 	0.000000000000000, 	-3.735078262179111, 	0.000000000000000, 	-0.161705013319883, 	0.000000000000000, 	
-0.748963512361001, 	0.000000000000000, 	1.128046374367600, 	0.000000000000000, 	0.649651335592966, 	0.000000000000000, 	1.880020215025867, 	0.000000000000000, 	
--1.095632293842306, 	0.000000000000000, 	1.197764876160487, 	0.000000000000000, 	0.323646656252985, 	0.000000000000000, 	-1.655502751114502, 	0.000000000000000, 	
-3.666399062961496, 	0.000000000000000, 	-0.334060899735197, 	0.000000000000000, 	-2.119056978738397, 	0.000000000000000, 	3.721375117275012, 	0.000000000000000, 	
-0.044874186872307, 	0.000000000000000, 	-2.733053897593234, 	0.000000000000000, 	1.590700278891042, 	0.000000000000000, 	3.215711772781902, 	0.000000000000000, 	
--1.792085012843801, 	0.000000000000000, 	-0.405797188885475, 	0.000000000000000, 	-0.628080020080892, 	0.000000000000000, 	-1.831815840843960, 	0.000000000000000, 	
-2.973656862522834, 	0.000000000000000, 	-0.212032655138417, 	0.000000000000000, 	0.372437389437234, 	0.000000000000000, 	-1.614030579023492, 	0.000000000000000, 	
--0.704900996358698, 	0.000000000000000, 	1.123700273452105, 	0.000000000000000, 	-0.136371848130819, 	0.000000000000000, 	3.020284357635585, 	0.000000000000000, 	
--0.550211350877649, 	0.000000000000000, 	5.101256236381711, 	0.000000000000000, 	3.367051512192333, 	0.000000000000000, 	-4.385131946669234, 	0.000000000000000, 	
--3.967303337694391, 	0.000000000000000, 	-0.965894936640022, 	0.000000000000000, 	0.328366945264681, 	0.000000000000000, 	0.199041562924914, 	0.000000000000000, 	
-1.067681999025495, 	0.000000000000000, 	-1.939516091697170, 	0.000000000000000, 	-1.092980954328824, 	0.000000000000000, 	0.273786079368066, 	0.000000000000000, 	
--0.040928322190265, 	0.000000000000000, 	-0.118368078577437, 	0.000000000000000, 	1.766589628899997, 	0.000000000000000, 	1.738321311635393, 	0.000000000000000, 	
--2.895012794321649, 	0.000000000000000, 	1.213521771395142, 	0.000000000000000, 	0.922971726633985, 	0.000000000000000, 	1.091516563636489, 	0.000000000000000, 	
-3.226378465469620, 	0.000000000000000, 	1.149169778666974, 	0.000000000000000, 	-1.695986327709386, 	0.000000000000000, 	-0.974803077355813, 	0.000000000000000, 	
--4.898035507513607, 	0.000000000000000, 	1.622719302889447, 	0.000000000000000, 	0.583891313586579, 	0.000000000000000, 	-1.677182424094957, 	0.000000000000000, 	
--1.915633132814685, 	0.000000000000000, 	-1.980150370851616, 	0.000000000000000, 	0.604538269404190, 	0.000000000000000, 	0.939862406149365, 	0.000000000000000, 	
--1.266939874246416, 	0.000000000000000, 	-1.494771249200063, 	0.000000000000000, 	0.278042784093988, 	0.000000000000000, 	0.326627416008916, 	0.000000000000000, 	
--1.914530157643303, 	0.000000000000000, 	1.908947721862196, 	0.000000000000000, 	0.531819285694044, 	0.000000000000000, 	3.056856632319658, 	0.000000000000000, 	
--0.389241827774643, 	0.000000000000000, 	-2.418606606780420, 	0.000000000000000, 	0.915299238878703, 	0.000000000000000, 	-0.098774174295283, 	0.000000000000000, 	
--0.906199428444304, 	0.000000000000000, 	0.316716451217743, 	0.000000000000000, 	-4.367700643578311, 	0.000000000000000, 	1.491687997515293, 	0.000000000000000, 	
--1.962381126288365, 	0.000000000000000, 	-0.700829196527045, 	0.000000000000000, 	3.028958963615630, 	0.000000000000000, 	-2.313461067462598, 	0.000000000000000, 	
--1.431933239886712, 	0.000000000000000, 	-0.831153039725342, 	0.000000000000000, 	3.939495598250743, 	0.000000000000000, 	0.342974753984771, 	0.000000000000000, 	
--2.768330763002974, 	0.000000000000000, 	-2.744010370019008, 	0.000000000000000, 	3.821352685212561, 	0.000000000000000, 	4.551065271455856, 	0.000000000000000, 	
-3.270136437041298, 	0.000000000000000, 	-3.188028411950982, 	0.000000000000000, 	-0.777075012417436, 	0.000000000000000, 	0.097110650265216, 	0.000000000000000, 	
-1.221216137608812, 	0.000000000000000, 	-1.325824244541822, 	0.000000000000000, 	-2.655296734084113, 	0.000000000000000, 	-1.074792144885704, 	0.000000000000000, 	
-2.770401584439407, 	0.000000000000000, 	5.240270645610543, 	0.000000000000000, 	0.108576672208892, 	0.000000000000000, 	-1.209394350650142, 	0.000000000000000, 	
-1.403344353838785, 	0.000000000000000, 	-0.299032904177277, 	0.000000000000000, 	4.074959450638227, 	0.000000000000000, 	1.718727473952107, 	0.000000000000000, 	
--3.061349227080806, 	0.000000000000000, 	-1.158596888541269, 	0.000000000000000, 	3.381858904662625, 	0.000000000000000, 	0.957339964054052, 	0.000000000000000, 	
-0.179900074904899, 	0.000000000000000, 	-3.909641902506081, 	0.000000000000000, 	0.805717289408649, 	0.000000000000000, 	2.047413793928261, 	0.000000000000000, 	
--1.273580225826614, 	0.000000000000000, 	-2.681359186869971, 	0.000000000000000, 	-0.721241345822093, 	0.000000000000000, 	-1.613090681569475, 	0.000000000000000, 	
-0.463138804815955, 	0.000000000000000, 	0.377223507800954, 	0.000000000000000, 	2.046550684968141, 	0.000000000000000, 	0.178508732797712, 	0.000000000000000, 	
--0.477815330358845, 	0.000000000000000, 	3.763355908332053, 	0.000000000000000, 	1.300430303035163, 	0.000000000000000, 	-0.214625793857725, 	0.000000000000000, 	
-1.343267891864081, 	0.000000000000000, 	-0.340007682433245, 	0.000000000000000, 	2.062703194680005, 	0.000000000000000, 	0.042032160234235, 	0.000000000000000, 	
-0.643732569732250, 	0.000000000000000, 	-1.913502543857589, 	0.000000000000000, 	3.771340762937158, 	0.000000000000000, 	1.050024807363386, 	0.000000000000000, 	
--4.440489488592649, 	0.000000000000000, 	0.444904302066643, 	0.000000000000000, 	2.898702265650048, 	0.000000000000000, 	1.953232980548558, 	0.000000000000000, 	
-2.761564952735079, 	0.000000000000000, 	1.963537633260397, 	0.000000000000000, 	-2.168858472916215, 	0.000000000000000, 	-4.116235357699841, 	0.000000000000000, 	
-4.183678271896528, 	0.000000000000000, 	0.600422284944681, 	0.000000000000000, 	-0.659352647255126, 	0.000000000000000, 	-0.993127338218109, 	0.000000000000000, 	
--2.463571314945747, 	0.000000000000000, 	0.937720951545881, 	0.000000000000000, 	-3.098957308429730, 	0.000000000000000, 	-2.354719140045463, 	0.000000000000000, 	
--0.417285119323949, 	0.000000000000000, 	2.187974075975947, 	0.000000000000000, 	1.101468905172585, 	0.000000000000000, 	-3.185800678152109, 	0.000000000000000, 	
-2.357534709345083, 	0.000000000000000, 	0.246645606729407, 	0.000000000000000, 	4.440905650784504, 	0.000000000000000, 	-2.236807716637866, 	0.000000000000000, 	
--2.171481518317550, 	0.000000000000000, 	-2.029571795072690, 	0.000000000000000, 	0.135599790431348, 	0.000000000000000, 	-1.277965265520191, 	0.000000000000000, 	
--1.927976233157507, 	0.000000000000000, 	-5.434492783745394, 	0.000000000000000, 	-2.026375829312657, 	0.000000000000000, 	1.009666016819321, 	0.000000000000000, 	
-0.238549782367247, 	0.000000000000000, 	-0.516403923971309, 	0.000000000000000, 	-0.933977817429352, 	0.000000000000000, 	0.155803015935614, 	0.000000000000000, 	
--0.396194809997929, 	0.000000000000000, 	-0.915178100253214, 	0.000000000000000, 	0.666329367985015, 	0.000000000000000, 	-1.517991149945785, 	0.000000000000000, 	
-0.458266744144822, 	0.000000000000000, 	-1.242845974381418, 	0.000000000000000, 	0.057914823556477, 	0.000000000000000, 	0.994101307476875, 	0.000000000000000, 	
--2.387209849199325, 	0.000000000000000, 	0.459297048883826, 	0.000000000000000, 	0.227711405683905, 	0.000000000000000, 	0.030255073506117, 	0.000000000000000, 	
--1.323361608181337, 	0.000000000000000, 	-4.650244457426706, 	0.000000000000000, 	0.062908579526021, 	0.000000000000000, 	3.462831028244432, 	0.000000000000000, 	
-1.303608183314856, 	0.000000000000000, 	-1.430415193881612, 	0.000000000000000, 	-1.672886118942142, 	0.000000000000000, 	0.992890699210099, 	0.000000000000000, 	
--0.160814531784247, 	0.000000000000000, 	-1.238132939350430, 	0.000000000000000, 	-0.589223271459376, 	0.000000000000000, 	2.326363810561534, 	0.000000000000000, 	
--4.433789496230785, 	0.000000000000000, 	1.664686987538929, 	0.000000000000000, 	-2.366128834617921, 	0.000000000000000, 	1.212421570743837, 	0.000000000000000, 	
--4.847914267690055, 	0.000000000000000, 	0.228485221404712, 	0.000000000000000, 	0.466139765470957, 	0.000000000000000, 	-1.344202776943546, 	0.000000000000000, 	
--1.012053673330574, 	0.000000000000000, 	-2.844980626424742, 	0.000000000000000, 	-1.552703722026340, 	0.000000000000000, 	-1.448830983885038, 	0.000000000000000, 	
-0.127010756753980, 	0.000000000000000, 	-1.667188263752299, 	0.000000000000000, 	3.424818052085100, 	0.000000000000000, 	0.956291135453840, 	0.000000000000000, 	
--3.725533331754662, 	0.000000000000000, 	-1.584534272368832, 	0.000000000000000, 	-1.654148210472472, 	0.000000000000000, 	0.701610500675698, 	0.000000000000000, 	
-0.164954538683927, 	0.000000000000000, 	-0.739260064712987, 	0.000000000000000, 	-2.167324026090101, 	0.000000000000000, 	-0.310240491909496, 	0.000000000000000, 	
--2.281790349106906, 	0.000000000000000, 	1.719655331305361, 	0.000000000000000, 	-2.997005923606441, 	0.000000000000000, 	-1.999301431556852, 	0.000000000000000, 	
--0.292229010068828, 	0.000000000000000, 	1.172317994855851, 	0.000000000000000, 	0.196734885241533, 	0.000000000000000, 	2.981365193477068, 	0.000000000000000, 	
-2.637726016926352, 	0.000000000000000, 	1.434045125217982, 	0.000000000000000, 	0.883627180451827, 	0.000000000000000, 	-1.434040761445747, 	0.000000000000000, 	
--1.528891971086553, 	0.000000000000000, 	-3.306913135367542, 	0.000000000000000, 	-0.399059265470646, 	0.000000000000000, 	-0.265674394285178, 	0.000000000000000, 	
-3.502591252855384, 	0.000000000000000, 	0.830301156604454, 	0.000000000000000, 	-0.220021317046083, 	0.000000000000000, 	-0.090553770476646, 	0.000000000000000, 	
-0.771863477047951, 	0.000000000000000, 	1.351209629105760, 	0.000000000000000, 	3.773699756201963, 	0.000000000000000, 	0.472600118752329, 	0.000000000000000, 	
-2.332825668012222, 	0.000000000000000, 	1.853747950314528, 	0.000000000000000, 	0.759515251766178, 	0.000000000000000, 	1.327112776215496, 	0.000000000000000, 	
-2.518730296237868, 	0.000000000000000, 	0.764450208786353, 	0.000000000000000, 	-0.278275349491296, 	0.000000000000000, 	-0.041559465082020, 	0.000000000000000, 	
-1.387166083167787, 	0.000000000000000, 	2.612996769598122, 	0.000000000000000, 	-0.385404831721799, 	0.000000000000000, 	2.005630016170309, 	0.000000000000000, 	
--0.950500047307998, 	0.000000000000000, 	-1.166884021392492, 	0.000000000000000, 	1.432973552928162, 	0.000000000000000, 	2.540370505384567, 	0.000000000000000, 	
--1.140505295054501, 	0.000000000000000, 	-3.673358835201185, 	0.000000000000000, 	-0.450691288038056, 	0.000000000000000, 	1.601024294408014, 	0.000000000000000, 	
-0.773213556014045, 	0.000000000000000, 	2.973873693246168, 	0.000000000000000, 	-1.361548406382279, 	0.000000000000000, 	1.409136332424815, 	0.000000000000000, 	
--0.963382518314713, 	0.000000000000000, 	-2.031268227368161, 	0.000000000000000, 	0.983309972085586, 	0.000000000000000, 	-3.461412488471631, 	0.000000000000000, 	
--2.601124929406039, 	0.000000000000000, 	-0.533896239766343, 	0.000000000000000, 	-2.627129008866350, 	0.000000000000000, 	0.622111169161305, 	0.000000000000000, 	
--1.160926365580422, 	0.000000000000000, 	-2.406196188132628, 	0.000000000000000, 	-1.076870362758737, 	0.000000000000000, 	-1.791866820937175, 	0.000000000000000, 	
--0.749453071522325, 	0.000000000000000, 	-5.324156615990973, 	0.000000000000000, 	-1.038698022238289, 	0.000000000000000, 	-2.106629944730630, 	0.000000000000000, 	
-0.659295598564773, 	0.000000000000000, 	0.520940881580988, 	0.000000000000000, 	-0.055649203928700, 	0.000000000000000, 	0.292096765423137, 	0.000000000000000, 	
--4.663743901790872, 	0.000000000000000, 	-0.125066503391666, 	0.000000000000000, 	-2.452620252445380, 	0.000000000000000, 	-0.712128227397468, 	0.000000000000000, 	
--0.048938037970968, 	0.000000000000000, 	-1.821520226003361, 	0.000000000000000, 	0.810106421304257, 	0.000000000000000, 	-0.196636623956257, 	0.000000000000000, 	
--0.701769836763804, 	0.000000000000000, 	2.460345045649201, 	0.000000000000000, 	3.506597671641116, 	0.000000000000000, 	-2.711322611972225, 	0.000000000000000, 	
--0.658079876600542, 	0.000000000000000, 	-2.040082099646173, 	0.000000000000000, 	2.201668355395807, 	0.000000000000000, 	1.181507395879711, 	0.000000000000000, 	
--1.640739552179682, 	0.000000000000000, 	-1.613393726467190, 	0.000000000000000, 	-1.156741241731352, 	0.000000000000000, 	2.527773464519963, 	0.000000000000000, 	
--0.497040638009502, 	0.000000000000000, 	-0.975817112895589, 	0.000000000000000, 	-2.866830755546166, 	0.000000000000000, 	1.120214498507878, 	0.000000000000000, 	
-5.986771654661698, 	0.000000000000000, 	0.398219252656757, 	0.000000000000000, 	-3.545606013198135, 	0.000000000000000, 	0.312398099396191, 	0.000000000000000, 	
--2.265327979531788, 	0.000000000000000, 	0.792121001107366, 	0.000000000000000, 	-3.736145137670100, 	0.000000000000000, 	0.762228883650802, 	0.000000000000000, 	
-2.283545661214646, 	0.000000000000000, 	3.780020629583529, 	0.000000000000000, 	3.117260228608810, 	0.000000000000000, 	-2.011159255609613, 	0.000000000000000, 	
-0.279107700476072, 	0.000000000000000, 	2.003369134246936, 	0.000000000000000, 	-1.448171234480257, 	0.000000000000000, 	0.584697150310140, 	0.000000000000000, 	
-0.919508663636197, 	0.000000000000000, 	-3.071349141675388, 	0.000000000000000, 	-1.555923649263667, 	0.000000000000000, 	2.232497079438850, 	0.000000000000000, 	
--0.012662139119883, 	0.000000000000000, 	0.372825540734715, 	0.000000000000000, 	2.378543590847629, 	0.000000000000000, 	1.459053407813062, 	0.000000000000000, 	
--0.967913907390927, 	0.000000000000000, 	1.322825200678212, 	0.000000000000000, 	-1.033775820061824, 	0.000000000000000, 	-1.813629552693142, 	0.000000000000000, 	
-4.794348161661486, 	0.000000000000000, 	0.655279811518676, 	0.000000000000000, 	-2.224590138589720, 	0.000000000000000, 	0.595329481295766, 	0.000000000000000, 	
-3.364055988866225, 	0.000000000000000, 	1.863416422998127, 	0.000000000000000, 	1.930305751828105, 	0.000000000000000, 	-0.284467053432545, 	0.000000000000000, 	
--0.923374905878938, 	0.000000000000000, 	1.922988234041399, 	0.000000000000000, 	0.310482143432719, 	0.000000000000000, 	0.332122302397134, 	0.000000000000000, 	
--1.659487472408966, 	0.000000000000000, 	-1.865943507877961, 	0.000000000000000, 	-0.186775297569864, 	0.000000000000000, 	-1.700543850628361, 	0.000000000000000, 	
-0.497157959366735, 	0.000000000000000, 	-0.471244843957418, 	0.000000000000000, 	-0.432013753969948, 	0.000000000000000, 	-4.000189880113231, 	0.000000000000000, 	
--0.415335170016467, 	0.000000000000000, 	0.317311950972859, 	0.000000000000000, 	0.038393428927595, 	0.000000000000000, 	0.177219909465206, 	0.000000000000000, 	
-0.531650958095143, 	0.000000000000000, 	-2.711644985175806, 	0.000000000000000, 	0.328744077805156, 	0.000000000000000, 	-0.938417707547928, 	0.000000000000000, 	
-0.970379584897379, 	0.000000000000000, 	1.873649473917137, 	0.000000000000000, 	0.177938226987023, 	0.000000000000000, 	0.155609346302393, 	0.000000000000000, 	
--1.276504241867208, 	0.000000000000000, 	-0.463725075928807, 	0.000000000000000, 	-0.064748250389500, 	0.000000000000000, 	-1.725568534062385, 	0.000000000000000, 	
--0.139066584804067, 	0.000000000000000, 	1.975514554117767, 	0.000000000000000, 	-0.807063199499478, 	0.000000000000000, 	-0.326926659682788, 	0.000000000000000, 	
-1.445727032487938, 	0.000000000000000, 	-0.597151107739100, 	0.000000000000000, 	2.732557531709386, 	0.000000000000000, 	-2.907130934109188, 	0.000000000000000, 	
--1.461264832679981, 	0.000000000000000, 	-1.708588604968163, 	0.000000000000000, 	3.652851925431363, 	0.000000000000000, 	0.682050868282879, 	0.000000000000000, 	
--0.281312579963294, 	0.000000000000000, 	0.554966483307825, 	0.000000000000000, 	-0.981341739340932, 	0.000000000000000, 	1.279543331141603, 	0.000000000000000, 	
-0.036589747826856, 	0.000000000000000, 	2.312073745896073, 	0.000000000000000, 	1.754682200732425, 	0.000000000000000, 	-0.957515875428627, 	0.000000000000000, 	
--0.833596942819695, 	0.000000000000000, 	0.437054368791033, 	0.000000000000000, 	-0.898819399360279, 	0.000000000000000, 	-0.296050580896839, 	0.000000000000000, 	
--0.785144257649601, 	0.000000000000000, 	-2.541503089003311, 	0.000000000000000, 	2.225075846758761, 	0.000000000000000, 	-1.587290487902002, 	0.000000000000000, 	
--1.421404172056462, 	0.000000000000000, 	-3.015149802293631, 	0.000000000000000, 	1.780874288867949, 	0.000000000000000, 	-0.865812740882613, 	0.000000000000000, 	
--2.845327531197112, 	0.000000000000000, 	1.445225867774367, 	0.000000000000000, 	2.183733236584647, 	0.000000000000000, 	1.163371072749080, 	0.000000000000000, 	
-0.883547693520409, 	0.000000000000000, 	-1.224093106684675, 	0.000000000000000, 	-1.854501116331044, 	0.000000000000000, 	1.783082089255796, 	0.000000000000000, 	
-2.301508706196191, 	0.000000000000000, 	-0.539901944139077, 	0.000000000000000, 	1.962315832319967, 	0.000000000000000, 	-0.060709041870503, 	0.000000000000000, 	
--1.353139923300238, 	0.000000000000000, 	-1.482887537805234, 	0.000000000000000, 	1.273732601967176, 	0.000000000000000, 	-3.456609915556321, 	0.000000000000000, 	
--3.752320586540873, 	0.000000000000000, 	3.536356614978951, 	0.000000000000000, 	0.206035952043233, 	0.000000000000000, 	5.933966913773842, 	0.000000000000000, 	
--0.486633898075490, 	0.000000000000000, 	-0.329595089863342, 	0.000000000000000, 	1.496414153905337, 	0.000000000000000, 	0.137868749388880, 	0.000000000000000, 	
--0.437192030996792, 	0.000000000000000, 	2.682750615210656, 	0.000000000000000, 	-2.440234892848570, 	0.000000000000000, 	1.433910252426186, 	0.000000000000000, 	
--0.415051506104074, 	0.000000000000000, 	1.982003013708649, 	0.000000000000000, 	1.345796609972435, 	0.000000000000000, 	-2.335949513404370, 	0.000000000000000, 	
-1.065988867433025, 	0.000000000000000, 	2.741844905000464, 	0.000000000000000, 	-1.754047930934362, 	0.000000000000000, 	0.229252730015575, 	0.000000000000000, 	
--0.679791016408669, 	0.000000000000000, 	-2.274097820043743, 	0.000000000000000, 	0.149802252231876, 	0.000000000000000, 	-0.139697151364830, 	0.000000000000000, 	
--2.773367420505435, 	0.000000000000000, 	-4.403400246165611, 	0.000000000000000, 	-1.468974515184135, 	0.000000000000000, 	0.664990623095844, 	0.000000000000000, 	
--3.446979775557143, 	0.000000000000000, 	1.850006428987618, 	0.000000000000000, 	-1.550866747921936, 	0.000000000000000, 	-3.632874882935257, 	0.000000000000000, 	
-0.828039662992464, 	0.000000000000000, 	2.794055182632816, 	0.000000000000000, 	-0.593995716682633, 	0.000000000000000, 	0.142788156054200, 	0.000000000000000, 	
-0.552461945119668, 	0.000000000000000, 	0.842127129738758, 	0.000000000000000, 	1.414335509600077, 	0.000000000000000, 	-0.311559241382430, 	0.000000000000000, 	
-1.510590844695250, 	0.000000000000000, 	1.692217183824300, 	0.000000000000000, 	0.613760285711957, 	0.000000000000000, 	0.065233463207770, 	0.000000000000000, 	
--2.571912893711505, 	0.000000000000000, 	-1.707001531141341, 	0.000000000000000, 	0.673884968382041, 	0.000000000000000, 	0.889863883420103, 	0.000000000000000, 	
--2.395635435233346, 	0.000000000000000, 	1.129247296359819, 	0.000000000000000, 	0.569074704779735, 	0.000000000000000, 	6.139436017480722, 	0.000000000000000, 	
-0.822158309259017, 	0.000000000000000, 	-3.289872016222589, 	0.000000000000000, 	0.417612988384414, 	0.000000000000000, 	1.493982103868165, 	0.000000000000000, 	
--0.415353391377005, 	0.000000000000000, 	0.288670764933155, 	0.000000000000000, 	-1.895650228872272, 	0.000000000000000, 	-0.139631694475020, 	0.000000000000000, 	
-1.445103299005436, 	0.000000000000000, 	2.877182243683429, 	0.000000000000000, 	1.192428490172580, 	0.000000000000000, 	-5.964591921763842, 	0.000000000000000, 	
-0.570859795882959, 	0.000000000000000, 	2.328333316356666, 	0.000000000000000, 	0.333755014930026, 	0.000000000000000, 	1.221901577771909, 	0.000000000000000, 	
-0.943358697415568, 	0.000000000000000, 	2.793063983613067, 	0.000000000000000, 	3.163005066073616, 	0.000000000000000, 	2.098300664513867, 	0.000000000000000, 	
--3.915313164333447, 	0.000000000000000, 	-2.475766769064539, 	0.000000000000000, 	1.720472044894277, 	0.000000000000000, 	-1.273591949275665, 	0.000000000000000, 	
--1.213451272938616, 	0.000000000000000, 	0.697439404325690, 	0.000000000000000, 	-0.309902287574293, 	0.000000000000000, 	2.622575852162781, 	0.000000000000000, 	
--2.075881936219060, 	0.000000000000000, 	0.777847545691770, 	0.000000000000000, 	-3.967947986440650, 	0.000000000000000, 	-3.066503371806472, 	0.000000000000000, 	
-1.193780625937845, 	0.000000000000000, 	0.214246579281311, 	0.000000000000000, 	-2.610681491162162, 	0.000000000000000, 	-1.261224183972745, 	0.000000000000000, 	
--1.165071748544285, 	0.000000000000000, 	-1.116548474834374, 	0.000000000000000, 	0.847202164846982, 	0.000000000000000, 	-3.474301529532390, 	0.000000000000000, 	
-0.020799541946476, 	0.000000000000000, 	-3.868995473288166, 	0.000000000000000, 	1.757979409638067, 	0.000000000000000, 	0.868115130183109, 	0.000000000000000, 	
-0.910167436737958, 	0.000000000000000, 	-1.878855115563720, 	0.000000000000000, 	1.710357104174161, 	0.000000000000000, 	-1.468933980990902, 	0.000000000000000, 	
-1.799544171601169, 	0.000000000000000, 	-4.922332880027887, 	0.000000000000000, 	0.219424548939720, 	0.000000000000000, 	-0.971671113451924, 	0.000000000000000, 	
--0.940533475616266, 	0.000000000000000, 	0.122510114412152, 	0.000000000000000, 	-1.373686254916911, 	0.000000000000000, 	1.760348103896323, 	0.000000000000000, 	
-0.391745067829643, 	0.000000000000000, 	2.521958505327354, 	0.000000000000000, 	-1.300693516405092, 	0.000000000000000, 	-0.538251788309178, 	0.000000000000000, 	
-0.797184135810173, 	0.000000000000000, 	2.908800548982588, 	0.000000000000000, 	1.590902251655215, 	0.000000000000000, 	-1.070323714487264, 	0.000000000000000, 	
--3.349764443340999, 	0.000000000000000, 	-1.190563529731447, 	0.000000000000000, 	1.363369471291963, 	0.000000000000000, 	-1.814270299924576, 	0.000000000000000, 	
--0.023381588315711, 	0.000000000000000, 	1.719182048679569, 	0.000000000000000, 	0.839917213252626, 	0.000000000000000, 	1.006099633839122, 	0.000000000000000, 	
-0.812462674381527, 	0.000000000000000, 	1.755814336346739, 	0.000000000000000, 	2.546848681206319, 	0.000000000000000, 	-1.555300208869455, 	0.000000000000000, 	
-1.017053811631167, 	0.000000000000000, 	0.996591039170903, 	0.000000000000000, 	-1.228047247924881, 	0.000000000000000, 	4.809462271463009, 	0.000000000000000, 	
-2.318113116151685, 	0.000000000000000, 	-1.206932520679733, 	0.000000000000000, 	1.273757685623312, 	0.000000000000000, 	0.724335352481802, 	0.000000000000000, 	
-1.519876652073198, 	0.000000000000000, 	-2.749670314714158, 	0.000000000000000, 	3.424042481847581, 	0.000000000000000, 	-3.714668360421517, 	0.000000000000000, 	
-1.612834197004014, 	0.000000000000000, 	-2.038234723985566, 	0.000000000000000, 	1.470938786562152, 	0.000000000000000, 	2.111634918450302, 	0.000000000000000, 	
-1.030376670151787, 	0.000000000000000, 	-0.420877189003829, 	0.000000000000000, 	-1.502024800532894, 	0.000000000000000, 	0.452310749163804, 	0.000000000000000, 	
--1.606059382300987, 	0.000000000000000, 	-4.006159967834147, 	0.000000000000000, 	-2.152801208196508, 	0.000000000000000, 	1.671674089372579, 	0.000000000000000, 	
-1.714536333564101, 	0.000000000000000, 	-1.011518543005344, 	0.000000000000000, 	-0.576410282180584, 	0.000000000000000, 	0.733689809480836, 	0.000000000000000, 	
-1.004245602717974, 	0.000000000000000, 	1.010090391888449, 	0.000000000000000, 	3.811459513385621, 	0.000000000000000, 	-5.230621089271954, 	0.000000000000000, 	
-0.678044861034399, 	0.000000000000000, 	1.255935859598107, 	0.000000000000000, 	1.674521701615288, 	0.000000000000000, 	-1.656695216761705, 	0.000000000000000, 	
-1.169286028869693, 	0.000000000000000, 	0.524915416191998, 	0.000000000000000, 	2.397642885039520, 	0.000000000000000, 	2.108711400616072, 	0.000000000000000, 	
-2.037618211018084, 	0.000000000000000, 	-0.623664553406925, 	0.000000000000000, 	2.984106170984409, 	0.000000000000000, 	1.132182737400932, 	0.000000000000000, 	
--2.859274340352130, 	0.000000000000000, 	-0.975550071398723, 	0.000000000000000, 	-1.359935119997407, 	0.000000000000000, 	-2.963308211050121, 	0.000000000000000, 	
--0.228726662781163, 	0.000000000000000, 	-1.411110379682043, 	0.000000000000000, 	0.741553355734225, 	0.000000000000000, 	0.497554254758309, 	0.000000000000000, 	
-2.371907950598855, 	0.000000000000000, 	1.063465168988748, 	0.000000000000000, 	-0.641082692081488, 	0.000000000000000, 	-0.855439878540726, 	0.000000000000000, 	
-0.578321738578726, 	0.000000000000000, 	3.005809768796194, 	0.000000000000000, 	1.961458699064065, 	0.000000000000000, 	-3.206261663772745, 	0.000000000000000, 	
--0.364431989095434, 	0.000000000000000, 	-0.263182496622273, 	0.000000000000000, 	1.843464680631139, 	0.000000000000000, 	-0.419107530229249, 	0.000000000000000, 	
-1.662335873298487, 	0.000000000000000, 	-0.853687563304005, 	0.000000000000000, 	-2.584133404357169, 	0.000000000000000, 	3.466839568922895, 	0.000000000000000, 	
-0.881671345091973, 	0.000000000000000, 	0.454620014206908, 	0.000000000000000, 	-1.737245187402739, 	0.000000000000000, 	2.162713238369243, 	0.000000000000000, 	
--3.868539002714486, 	0.000000000000000, 	2.014114855933826, 	0.000000000000000, 	-0.703233831811006, 	0.000000000000000, 	-3.410319935997574, 	0.000000000000000, 	
--1.851235811006584, 	0.000000000000000, 	0.909783907894036, 	0.000000000000000, 	0.091884002136728, 	0.000000000000000, 	-2.688294201131650, 	0.000000000000000, 	
--0.906134178460955, 	0.000000000000000, 	3.475054609035133, 	0.000000000000000, 	-0.573927964170323, 	0.000000000000000, 	-0.429542937515399, 	0.000000000000000, 	
-0.991348618739939, 	0.000000000000000, 	1.974804904926325, 	0.000000000000000, 	0.975783450796698, 	0.000000000000000, 	-3.057119549071503, 	0.000000000000000, 	
--3.899429237481194, 	0.000000000000000, 	0.362439009175350, 	0.000000000000000, 	-1.124461670265618, 	0.000000000000000, 	1.806000360163583, 	0.000000000000000, 	
--2.768333362600288, 	0.000000000000000, 	0.244387897900379, 	0.000000000000000, 	0.908767296720926, 	0.000000000000000, 	1.254669374391882, 	0.000000000000000, 	
--1.420441929463686, 	0.000000000000000, 	-0.875658895966293, 	0.000000000000000, 	0.183824603376167, 	0.000000000000000, 	-3.361653917011686, 	0.000000000000000, 	
--0.796615630227952, 	0.000000000000000, 	-1.660226542658673, 	0.000000000000000, 	1.654439358307226, 	0.000000000000000, 	2.782812946709771, 	0.000000000000000, 	
-1.418064412811531, 	0.000000000000000, 	-0.819645647243761, 	0.000000000000000, 	0.807724772592699, 	0.000000000000000, 	-0.941967976379298, 	0.000000000000000, 	
--2.312768306047469, 	0.000000000000000, 	0.872426936477443, 	0.000000000000000, 	0.919528961530845, 	0.000000000000000, 	-2.084904575264847, 	0.000000000000000, 	
--1.972464868459322, 	0.000000000000000, 	-1.050687203338466, 	0.000000000000000, 	1.659579707007902, 	0.000000000000000, 	-1.820640014705855, 	0.000000000000000, 	
--1.195078061671045, 	0.000000000000000, 	-1.639773173762048, 	0.000000000000000, 	1.616744338157063, 	0.000000000000000, 	4.019216096811563, 	0.000000000000000, 	
-3.461021102549681, 	0.000000000000000, 	1.642352734361484, 	0.000000000000000, 	-0.046354693720813, 	0.000000000000000, 	-0.041936252359677, 	0.000000000000000, 	
--2.393307519480551, 	0.000000000000000, 	-0.341471634615121, 	0.000000000000000, 	-0.392073595257017, 	0.000000000000000, 	-0.219299018372730, 	0.000000000000000, 	
--2.016391579662071, 	0.000000000000000, 	-0.653096251969787, 	0.000000000000000, 	1.466353155666821, 	0.000000000000000, 	-2.872058864320412, 	0.000000000000000, 	
--2.157180779503830, 	0.000000000000000, 	0.723257479841560, 	0.000000000000000, 	3.769951308104384, 	0.000000000000000, 	-1.923392042420024, 	0.000000000000000, 	
-0.644899359942840, 	0.000000000000000, 	-2.090226891621437, 	0.000000000000000, 	-0.277043982890403, 	0.000000000000000, 	-0.528271428321112, 	0.000000000000000, 	
-2.518120645960652, 	0.000000000000000, 	1.040820431111488, 	0.000000000000000, 	-4.560583754742486, 	0.000000000000000, 	-0.226899614918836, 	0.000000000000000, 	
-1.713331231108959, 	0.000000000000000, 	-3.293941019163642, 	0.000000000000000, 	-1.113331444648290, 	0.000000000000000, 	-1.032308423149906, 	0.000000000000000, 	
-1.593774272982443, 	0.000000000000000, 	-1.246840475090529, 	0.000000000000000, 	-0.190344684920137, 	0.000000000000000, 	-1.719386356896355, 	0.000000000000000, 	
--2.827721754659679, 	0.000000000000000, 	-0.092438285279020, 	0.000000000000000, 	-0.565844430675246, 	0.000000000000000, 	-1.077916121691716, 	0.000000000000000, 	
--1.208665809504693, 	0.000000000000000, 	-2.996014266381254, 	0.000000000000000, 	2.888573323402423, 	0.000000000000000, 	2.829507048720695, 	0.000000000000000, 	
--0.859177034120755, 	0.000000000000000, 	-1.969302377743254, 	0.000000000000000, 	0.777437674525362, 	0.000000000000000, 	-0.124910190157646, 	0.000000000000000, 	
-0.129875493115290, 	0.000000000000000, 	-4.192139262163992, 	0.000000000000000, 	3.023496047962126, 	0.000000000000000, 	1.149775163736637, 	0.000000000000000, 	
-2.038151304801731, 	0.000000000000000, 	3.016122489841263, 	0.000000000000000, 	-4.829481812137012, 	0.000000000000000, 	-1.668436615909279, 	0.000000000000000, 	
-0.958586784636918, 	0.000000000000000, 	1.550652410058678, 	0.000000000000000, 	-1.456305257976716, 	0.000000000000000, 	-0.079588392344731, 	0.000000000000000, 	
--2.453213599392345, 	0.000000000000000, 	0.296795909127105, 	0.000000000000000, 	-0.253426616607643, 	0.000000000000000, 	1.418937160028195, 	0.000000000000000, 	
--1.672949529066915, 	0.000000000000000, 	-1.620990298572947, 	0.000000000000000, 	-1.085103073196045, 	0.000000000000000, 	0.738606361195386, 	0.000000000000000, 	
--2.097831202853255, 	0.000000000000000, 	2.711952282071310, 	0.000000000000000, 	1.498539238246888, 	0.000000000000000, 	1.317457282535915, 	0.000000000000000, 	
--0.302765938349717, 	0.000000000000000, 	-0.044623707947201, 	0.000000000000000, 	2.337405215062395, 	0.000000000000000, 	-3.980689173859100, 	0.000000000000000, 	
-
-
-};
-
diff --git a/stm32/src/freedv_rx_profile.c b/stm32/src/freedv_rx_profile.c
deleted file mode 100644
index 52ad6d22..00000000
--- a/stm32/src/freedv_rx_profile.c
+++ /dev/null
@@ -1,136 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: freedv_rx_profile.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 13 August 2014
-
-  Profiling freedv_rx() operation on the STM32F4.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2014 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#define PROFILE
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <math.h>
-
-#include "stm32f4xx_conf.h"
-#include "stm32f4xx.h"
-#include "gdb_stdio.h"
-#include "freedv_api.h"
-#include "machdep.h"
-#include "codec2_fdmdv.h"
-
-#ifdef __EMBEDDED__
-#define printf gdb_stdio_printf
-#define fopen gdb_stdio_fopen
-#define fclose gdb_stdio_fclose
-#define fread gdb_stdio_fread
-#define fwrite gdb_stdio_fwrite
-#define fprintf gdb_stdio_fprintf
-#endif
-
-#define FREEDV_NSAMPLES_16K (2*FREEDV_NSAMPLES)
-
-int main(int argc, char *argv[]) {
-    struct freedv *f;
-    FILE          *fin, *fout, *ftotal;
-    int            frame, nin_16k, nin, i, nout = 0;
-    int            n_samples, n_samples_16k;
-    int            sync;
-    float          snr_est;
-
-    PROFILE_VAR(fdmdv_16_to_8_start, freedv_rx_start, fdmdv_8_to_16_start);
-
-    machdep_profile_init();
-
-    f = freedv_open(FREEDV_MODE_1600);
-    n_samples = freedv_get_n_speech_samples(f);
-    n_samples_16k = 2*n_samples;
-
-    short          adc16k[FDMDV_OS_TAPS_16K+n_samples_16k];
-    short          dac16k[n_samples_16k];
-    short          adc8k[n_samples];
-    short          dac8k[FDMDV_OS_TAPS_8K+n_samples];
-
-    // Receive ---------------------------------------------------------------------
-
-    frame = 0;
-
-    fin = fopen("mod_16k.raw", "rb");
-    if (fin == NULL) {
-        printf("Error opening input file\n");
-        exit(1);
-    }
-
-    fout = fopen("speechout_16k.raw", "wb");
-    if (fout == NULL) {
-        printf("Error opening output file\n");
-        exit(1);
-    }
-
-    ftotal = fopen("total.txt", "wt");
-    assert(ftotal != NULL);
-
-    /* clear filter memories */
-
-    for(i=0; i<FDMDV_OS_TAPS_16K; i++)
-	adc16k[i] = 0.0;
-    for(i=0; i<FDMDV_OS_TAPS_8K; i++)
-	dac8k[i] = 0.0;
-
-    nin = freedv_nin(f);
-    nin_16k = 2*nin;
-    nout = nin;
-    while (fread(&adc16k[FDMDV_OS_TAPS_16K], sizeof(short), nin_16k, fin) == nin_16k) {
-
-        PROFILE_SAMPLE(fdmdv_16_to_8_start);
-
-        fdmdv_16_to_8_short(adc8k, &adc16k[FDMDV_OS_TAPS_16K], nin);
-
-        PROFILE_SAMPLE_AND_LOG(freedv_rx_start, fdmdv_16_to_8_start, "  fdmdv_16_to_8");
-
-        nout = freedv_rx(f, &dac8k[FDMDV_OS_TAPS_8K], adc8k);
-        nin = freedv_nin(f); nin_16k = 2*nin;
-
-        PROFILE_SAMPLE_AND_LOG(fdmdv_8_to_16_start, freedv_rx_start, "  freedv_rx");
-
-        fdmdv_8_to_16_short(dac16k, &dac8k[FDMDV_OS_TAPS_8K], nout);
-
-        PROFILE_SAMPLE_AND_LOG2(fdmdv_8_to_16_start, "  fdmdv_8_to_16");
-
-        fprintf(ftotal, "%d\n", machdep_profile_sample() - fdmdv_16_to_8_start);
-        machdep_profile_print_logged_samples();
-
-        fwrite(dac16k, sizeof(short), 2*nout, fout);
-        freedv_get_modem_stats(f, &sync, &snr_est);
-        printf("frame: %d nin_16k: %d sync: %d SNR: %3.2f \n",
-               ++frame, nin_16k, sync, (double)snr_est);
-    }
-
-    fclose(fin);
-    fclose(fout);
-    fclose(ftotal);
-
-    return 0;
-}
-
diff --git a/stm32/src/freedv_tx_profile.c b/stm32/src/freedv_tx_profile.c
deleted file mode 100644
index c1c0b024..00000000
--- a/stm32/src/freedv_tx_profile.c
+++ /dev/null
@@ -1,90 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: freedv_tx_profile.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 13 August 2014
-
-  Profiling freedv_tx() operation on the STM32F4.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2014 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <math.h>
-
-#include "stm32f4xx_conf.h"
-#include "stm32f4xx.h"
-#include "gdb_stdio.h"
-#include "freedv_api.h"
-#include "machdep.h"
-
-#ifdef __EMBEDDED__
-#define printf gdb_stdio_printf
-#define fopen gdb_stdio_fopen
-#define fclose gdb_stdio_fclose
-#define fread gdb_stdio_fread
-#define fwrite gdb_stdio_fwrite
-#endif
-
-int main(int argc, char *argv[]) {
-    struct freedv *f;
-    FILE          *fin, *fout;
-    int            frame, n_samples;
-    PROFILE_VAR(freedv_start);
-
-    machdep_profile_init();
-
-    f = freedv_open(FREEDV_MODE_1600);
-    n_samples = freedv_get_n_speech_samples(f);
-    short inbuf[n_samples], outbuf[n_samples];
-
-    // Transmit ---------------------------------------------------------------------
-
-    fin = fopen("stm_in.raw", "rb");
-    if (fin == NULL) {
-        printf("Error opening input file\n");
-        exit(1);
-    }
-
-    fout = fopen("mod.raw", "wb");
-    if (fout == NULL) {
-        printf("Error opening output file\n");
-        exit(1);
-    }
-
-    frame = 0;
-
-    while (fread(inbuf, sizeof(short), n_samples, fin) == n_samples) {
-        PROFILE_SAMPLE(freedv_start);
-        freedv_tx(f, outbuf, inbuf);
-        PROFILE_SAMPLE_AND_LOG2(freedv_start, "  freedv_tx");
-
-        fwrite(outbuf, sizeof(short), n_samples, fout);
-        printf("frame: %d\n", ++frame);
-        machdep_profile_print_logged_samples();
-   }
-
-    fclose(fin);
-    fclose(fout);
-
-    return 0;
-}
-
diff --git a/stm32/src/gdb_stdio.c b/stm32/src/gdb_stdio.c
deleted file mode 100644
index 46245e4c..00000000
--- a/stm32/src/gdb_stdio.c
+++ /dev/null
@@ -1,125 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: gdb_stdio.c
-  AUTHOR......: David Rowe
-  DATE CREATED: April 23 2013
-
-  Some stdio I/O functions that perform I/O on the host using gdb.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2013 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <stdio.h>
-#include <string.h>
-#include <stdarg.h>
-#include "gdb_stdio.h"
-
-#define MAX_STR 2048
-
-/* command codes we use to signal host */
-
-#define GDB_STDIO_PRINTF  1
-#define GDB_STDIO_FOPEN   2
-#define GDB_STDIO_FCLOSE  3
-#define GDB_STDIO_FWRITE  4
-#define GDB_STDIO_FREAD   5
-#define GDB_STDIO_FPRINTF 6
-
-/* globals we use to communicate with host */
-
-volatile int   gdb_stdio_func = 0;
-volatile int   gdb_stdio_ret;
-volatile char *gdb_stdio_pstr1;
-volatile char *gdb_stdio_pstr2;
-volatile int   gdb_stdio_strlen1;
-volatile int   gdb_stdio_strlen2;
-volatile FILE *gdb_stdio_file;
-volatile void *gdb_stdio_ptr;
-volatile int   gdb_stdio_size;
-volatile int   gdb_stdio_nmem;
-
-void gdb_stdio_fprintf(FILE *file, const char *format, ...) {
-    va_list arg;
-    char str[MAX_STR];
-
-    va_start(arg, format);
-    vsnprintf(str, MAX_STR, format, arg);
-    va_end(arg);
-    gdb_stdio_file = file;
-    gdb_stdio_pstr1 = str;
-    gdb_stdio_strlen1 = strlen(str);
-
-    gdb_stdio_func = GDB_STDIO_FPRINTF;
-    while(gdb_stdio_func);
-}
-
-void gdb_stdio_printf(const char *format, ...) {
-    va_list arg;
-    char str[MAX_STR];
-
-    va_start(arg, format);
-    vsnprintf(str, MAX_STR, format, arg);
-    va_end(arg);
-    gdb_stdio_pstr1 = str;
-    gdb_stdio_strlen1 = strlen(str);
-
-    gdb_stdio_func = GDB_STDIO_PRINTF;
-    while(gdb_stdio_func);
-}
-
-FILE *gdb_stdio_fopen(char file_name[], char mode[]) {
-    gdb_stdio_pstr1 = file_name;
-    gdb_stdio_pstr2 = mode;
-    gdb_stdio_strlen1 = strlen(file_name);
-    gdb_stdio_strlen2 = strlen(mode);
-
-    gdb_stdio_func = GDB_STDIO_FOPEN;
-    while(gdb_stdio_func);
-    return (FILE*)gdb_stdio_ret;
-}
-
-void gdb_stdio_fclose(FILE *file) {
-    gdb_stdio_file = file;
-
-    gdb_stdio_func = GDB_STDIO_FCLOSE;
-    while(gdb_stdio_func);
-}
-
-int gdb_stdio_fwrite(void *ptr, int size, int nmem, FILE *file) {
-    gdb_stdio_ptr = ptr;
-    gdb_stdio_size = size;
-    gdb_stdio_nmem = nmem;
-    gdb_stdio_file = file;
-
-    gdb_stdio_func = GDB_STDIO_FWRITE;
-    while(gdb_stdio_func);
-    return gdb_stdio_ret;
-}
-
-int gdb_stdio_fread(void *ptr, int size, int nmem, FILE *file) {
-    gdb_stdio_ptr = ptr;
-    gdb_stdio_size = size;
-    gdb_stdio_nmem = nmem;
-    gdb_stdio_file = file;
-
-    gdb_stdio_func = GDB_STDIO_FREAD;
-    while(gdb_stdio_func);
-    return gdb_stdio_ret;
-}
-
diff --git a/stm32/src/iir_duc.c b/stm32/src/iir_duc.c
deleted file mode 100644
index 2c930599..00000000
--- a/stm32/src/iir_duc.c
+++ /dev/null
@@ -1,371 +0,0 @@
- /*---------------------------------------------------------------------------*\
-
-  FILE........: iir_duc.c
-  AUTHOR......: Brady O'Brien
-  DATE CREATED: 6 Mar 2015
-
-  Interapolator/Filter for IF upconversion
-
-  Unit testing:
-
-    ~/codec2-dev/stm32$ gcc -D__UNITTEST__ -Iinc src/iir_duc.c -o iir_duc -lm -Wall -I../src/
-    ~/codec2-dev/stm32$ ./iir_duc
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2015 Brady O'Brien
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "stm32f4_dacduc.h"
-#include "iir_duc.h"
-
-#define BETA1                    0.99002			// B1MUL/(2**B1SHFT)
-#define B1MUL			 32441
-#define B1SMUL			 -38328
-#define B1SHFT			 15				// 10 bits gives us plenty of headroom between 31 bits of int and 14 bits of ADC
-#define B2MUL			 24593  			// This actually matches BETA2 exactly with the supplied BETA1
-#define B2SHFT			 15				// 10 is also the lowest we can go without beta1=1
-#define BETA2                    (1.0 - (1.0-BETA1)*DUC_M)	// B2MUL/(2**B2SHFT)
-#define IN_SCALE                 2.0                            //Input scaling factor. Should be as large as the amplitude of the incoming samples
-#define DAC_SCALE                4096                           //Maximum output to DAC
-#define DAC_SCALE_2		 2040
-
-
-//IIR and FIR filter states. Global for go fast.
-float f_1,f_2,f;
-int   n_1,n_2,n,m_1,m_2,m;
-
-/*
-   Upconvert and bandpass filter a chunk of spectrum from Fs/M to Fs. We're going for 700khz here.
-   modin needs to be DUC_N long and dac_out needs to be DUC_N*DUC_M long. This
-*/
-
-void iir_upconv(float modin[], unsigned short dac_out[]){
-    int i,j,k;
-    int m;
-    k=0;
-    //Iterate through input samples and apply pre-eq FIR, interpolate, and apply BPF IIR
-    for(i=0;i<DUC_N;i++){
-        f = modin[i]+f_2*BETA2;
-        f_2 = f_1;
-        f_1 = modin[i];                                             //Scale fir output and convert to fixed.
-        m = (int)((f/(IN_SCALE))*DAC_SCALE_2);                      //Scale fir output and convert to fixed
-        n = m + ((B1SMUL*n_1)>>B1SHFT) - ((B1MUL*n_2)>>B1SHFT);   //Apply one cycle of IIR. This feeds the fir-ed sample into the output filter
-        n_2 = n_1;
-        n_1 = n;
-        dac_out[k]=(unsigned short)(n+DAC_SCALE_2);
-        k++;
-        //now do the rest of the filtering. Because we're zero-stuffing we can neglect the sample from the fir filter.
-        for(j=1;j<DUC_M;j++,k++){
-            n = ((B1SMUL*n_1)>>B1SHFT) - ((B1MUL*n_2)>>B1SHFT);
-            n_2 = n_1;
-            n_1 = n;
-            dac_out[k]=(unsigned short)((n)+DAC_SCALE_2);
-        }
-    }
-}
-
-/*
-   Upconvert and bandpass filter a chunk of spectrum from Fs/M to Fs. We're going for 700khz here.
-   modin needs to be DUC_N long and dac_out needs to be DUC_N*DUC_M long. This
-*/
-
-void iir_upconv_fixp(int modin[], unsigned short dac_out[]){
-    int i,j,k;
-    int l;
-    k=0;
-    //Iterate through input samples and apply pre-eq FIR, interpolate, and apply BPF IIR
-    for(i=0;i<DUC_N;i++){
-        l = modin[i];//(modin[i]*10)>>4;
-        m = l+((m_2*B2MUL)>>B2SHFT);
-        m_2 = m_1;
-        m_1 = l;                                             //Scale fir output and convert to fixed.
-        //m = (int)((f/(IN_SCALE))*DAC_SCALE_2);                      //Scale fir output and convert to fixed
-        n = m + ((B1SMUL*n_1)>>B1SHFT) - ((B1MUL*n_2)>>B1SHFT);   //Apply one cycle of IIR. This feeds the fir-ed sample into the output filter
-        n_2 = n_1;
-        n_1 = n;
-        dac_out[k]=(unsigned short)(n+DAC_SCALE_2);
-        k++;
-        //now do the rest of the filtering. Because we're zero-stuffing we can neglect the sample from the fir filter.
-        for(j=1;j<DUC_M;j++,k++){
-            n = ((B1SMUL*n_1)>>B1SHFT) - ((B1MUL*n_2)>>B1SHFT);
-            n_2 = n_1;
-            n_1 = n;
-            dac_out[k]=(unsigned short)((n)+DAC_SCALE_2);
-        }
-    }
-}
-
-#define F48C80R_LEN 25
-#define F48C80R_MUL 4096
-static int js3 = 0;                           //Index for downsampling
-static int js5 = 0;                           //Index for upsampling
-static unsigned int w48c80r;                  //Phase for real to comp conversion
-static int ptr_48c80r;                        //Pointer in fir delay lines
-static int fir_48c80r[];                      //Fir filter coeffs
-static int fir_48c80r_re[F48C80R_LEN*2];      //Real delay line. Can probably be made much smaller.
-static int fir_48c80r_im[F48C80R_LEN*2];      //Imag delay line. Can probably be made much smaller.
-static int * sel_48c80r[2] = {fir_48c80r_re,fir_48c80r_im};    //Selector used to optimize out branches in inner loops
-
-/*
-   Interpolate and shift from 48k complex to 80k real, centered on Fs/4.
-    comp_8 - Input samples - 8Kc complex - must be DUC_48N*count long
-    upout - Output samples - must be DUC_N*count long
-    count - how many chunks of samples must be processed
-*/
-
-void upconv_48c_80r(COMP comp_48[],int real_80[],int count){
-    int i,j,k;         //Loop counters
-    int ret;         //Temp vars
-    int nr,ni;         //Temp vars
-    int inidx = 0;     //Input index
-    int outidx = 0;
-    int ncs_48c80r[3];
-    for(i=0;i<count;i++){ //Iterate through sample blocks
-        for(j=0;j<DUC_N*3;j++){ //Iterate through high rate intermediate
-            if(js5==0){              //Upsample by 5
-                nr=(int)(comp_48[inidx].real*F48C80R_MUL);
-                ni=(int)(comp_48[inidx].imag*F48C80R_MUL);
-                fir_48c80r_re[ptr_48c80r] = nr;
-                fir_48c80r_im[ptr_48c80r] = ni;
-                fir_48c80r_re[ptr_48c80r+F48C80R_LEN] = nr;
-                fir_48c80r_im[ptr_48c80r+F48C80R_LEN] = ni;
-                inidx++;
-                js5=5;
-                if(ptr_48c80r>=F48C80R_LEN)
-                    ptr_48c80r-=F48C80R_LEN;
-            }
-            if(js3==0){               //Downsample by 3
-                ni=0;
-                /*This loop computes the FIR filter. It only computes from either the re or the im delay line,
-                    depending on comp->re phase It also skips all 'zeros' in the delay line */
-                for(k=js5;k<F48C80R_LEN;k+=5)
-                    ni+=(fir_48c80r[k]*sel_48c80r[w48c80r&0x1][ptr_48c80r+k]);
-                ncs_48c80r[0]=ni;
-                ncs_48c80r[2]=-ni;
-                ret=(ncs_48c80r[w48c80r&0x2]);
-                real_80[outidx]=ret>>14; //Scale back result; should probably just return int
-                outidx++;
-                js3=3;
-                w48c80r+=3;
-            }
-            ptr_48c80r++;
-            js3--;
-            js5--;
-        }
-    }
-}
-
-#define F8C80R_LEN 42                                     //Number of taps in the 8C80R filters
-#define F8C80R_MUL 4096
-static int int1r,int2r,int3r,int4r,int5r,cmb1r,cmb2r,cmb3r,cmb4r,cmb5r; //States for re combs and integrators
-static int int1i,int2i,int3i,int4i,int5i,cmb1i,cmb2i,cmb3i,cmb4i,cmb5i; //States for im combs and integrators
-static int ptr_8c80r;                                       //circular buffer ptr fir_8c80r_re
-static int w8c80r = 0;                                      //Omega for upconversion
-
-static int fir_8c80r_cic_i[];                               //FIR Coeffs
-static int fir_8c80r_re[F8C80R_LEN*2];                      //FIR delay line for re
-static int fir_8c80r_im[F8C80R_LEN*2];                      //FIR delay line for im
-
-/*
-   Interpolate and shift from 8k complex to 80k real, centered on Fs/4.
-    comp_8 - Input samples - 8Kc complex - must be (DUC_N/10)*count long
-    upout - Output samples - must be DUC_N*count long
-    count - how many chunks of samples must be processed
-*/
-
-void upconv_8c_80r(COMP comp_8[],float real_80[],int count){
-    int i,j,k;                           //Loop indices
-    float ret;                     //Temporary variables
-    int nr,ni;
-    int cmbr,cmbi,cmbrr,cmbii,rein,imin; //More temporaries
-    int inidx = 0;                       //Index of input
-    int outidx = 0;                      //Index of output
-    for(i=0;i<count;i++){                //Iterate through chunks of samples
-        for(j=0;j<DUC_N/5;j++){
-            if(j&0x1){ //If j is odd, stuff a zero, otherwise get a sample
-                nr = 0;
-                ni = 0;
-            } else {
-                nr = (int)(comp_8[inidx].real*F8C80R_MUL);
-                ni = (int)(comp_8[inidx].imag*F8C80R_MUL);
-                inidx++;
-            }
-            // Put the sample in the delay line
-            fir_8c80r_re[ptr_8c80r]=nr;
-            fir_8c80r_im[ptr_8c80r]=ni;
-            fir_8c80r_re[ptr_8c80r+F8C80R_LEN]=nr;
-            fir_8c80r_im[ptr_8c80r+F8C80R_LEN]=ni;
-            nr=0; ni=0;
-            //Some special initilization voodoo is done here.
-            //We skip all of the zeros by setting up the loop this way
-            for(k=(j&0x1);k<F8C80R_LEN;k+=2){
-                nr+=(fir_8c80r_cic_i[k]*fir_8c80r_re[ptr_8c80r+k])>>14;
-                ni+=(fir_8c80r_cic_i[k]*fir_8c80r_im[ptr_8c80r+k])>>14;
-            }
-            ptr_8c80r++;                          //Spin the dealy line index
-            if(ptr_8c80r>=F8C80R_LEN)
-                ptr_8c80r=0;
-            rein=nr;
-            imin=ni;
-            cmbr =  rein - cmb1r; cmb1r = rein;   //Comb 1 real
-            cmbrr = cmbr - cmb2r; cmb2r = cmbr;   //Comb 2 real
-            cmbr = cmbrr - cmb3r; cmb3r = cmbrr;  //Comb 3 real
-            cmbrr = cmbr - cmb4r; cmb4r = cmbr;   //Comb 4 real
-	    cmbr = cmbrr - cmb5r; cmb5r = cmbrr;
-
-            cmbi =  imin - cmb1i; cmb1i = imin;   //Comb 1 im
-            cmbii = cmbi - cmb2i; cmb2i = cmbi;   //Comb 2 im
-            cmbi = cmbii - cmb3i; cmb3i = cmbii;  //Comb 3 im
-            cmbii = cmbi - cmb4i; cmb4i = cmbi;   //Comb 4 im
-            cmbi = cmbii - cmb5i; cmb5i = cmbii;   //Comb 4 im
-            //Do first cycle of integration
-            int1r = cmbr + int1r;                //Integrator stage 1 re
-            int2r = int1r + int2r;                //Integrator stage 2 re
-            int3r = int2r + int3r;                //Integrator stage 3 re
-            int4r = int3r + int4r;                //Integrator stage 4 re
-            int5i = int4i + int5i;
-
-            int1i = cmbi + int1i;                //Integrator stage 1 im
-            int2i = int1i + int2i;                //Integrator stage 2 im
-            int3i = int2i + int3i;                //Integrator stage 3 im
-            int4i = int3i + int4i;                //Integrator stage 4 im
-            int5r = int4r + int5r;
-            //Convert this complex into real and cancel out the gain from CIC
-            //This should probably spit out integers instead of going back to float
-            switch(w8c80r&0x3){                   //Do comp->real conversion by hand
-                case 0:ret=(float)(-int5i>>7);break;
-                case 1:ret=(float)(int5r>>7);break;
-                case 2:ret=(float)(int5i>>7);break;
-                case 3:ret=(float)(-int5r>>7);break;
-            }
-            real_80[outidx] = ret/8192;   //Divide by 4096 to cancel out gain
-            outidx++;
-            w8c80r++;     //spin omega
-            //Next 4 stages of integration. Stage 1 can be ignored because of zero stuffing.
-            for(k=1;k<5;k++){
-                int2r = int1r + int2r;            //Integrator stage 2 re
-                int3r = int2r + int3r;            //Integrator stage 3 re
-                int4r = int3r + int4r;            //Integrator stage 4 re
-		int5r = int4r + int5r;
-                int2i = int1i + int2i;            //Integrator stage 2 im
-                int3i = int2i + int3i;            //Integrator stage 3 im
-                int4i = int3i + int4i;            //Integrator stage 4 im
-	        int5i = int4i + int5i;
-                switch(w8c80r&0x3){               //Do comp->real conversion by hand
-                    case 0:ret=(float)(-int5i>>7);break;
-                    case 1:ret=(float)(int5r>>7);break;
-                    case 2:ret=(float)(int5i>>7);break;
-                    case 3:ret=(float)(-int5r>>7);break;
-                }
-                real_80[outidx] = ret/8192;  //Cancel out gain from all that.
-                outidx++;
-		w8c80r++;
-            }
-        }
-    }
-}
-
-#ifdef __UNITTEST__
-
-#include <math.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <assert.h>
-
-#define FS     80000
-#define AMP_MAX 1
-
-#define NOUT_BUFS    500
-#define NIN          (NOUT_BUFS*DUC_N)
-#define NOUT         (NIN*DUC_M)
-
-void synth_line(float us[], float f, float amp, int n) {
-    float w, sam;
-    int   i;
-
-    w = 2*M_PI*f/(float)FS;
-
-    for(i=0; i<n; i++) {
-        sam = amp*AMP_MAX*cos(w*i);
-        us[i] += sam;
-    }
-}
-
-COMP       in[48000];
-int 	   s[NIN];
-float      fout[NIN];
-unsigned short todac[NOUT];
-
-int main(void) {
-    float          w;
-    FILE          *f;
-    int            i;
-
-    for(i=0;i<48000;i++){
-        //Tone at Fs/4 +/- 3K
-	w = 2.*M_PI*1000./(float)(FS/10);
-        in[i].real=cos((float)i*w);
-        //in[i].imag=.1*sin((float)i*w);
-        //in[i].real=0;
-        //in[i].real=1;
-        in[i].imag=0;
-    }
-
-    //Impulse to give us an idea of our filter bands
-    in[0].imag=0.70710678118;
-    in[0].real=0.70710678118;
-
-    //interpolate from 8k comp to 80k real
-    upconv_48c_80r(in,s,NOUT_BUFS);
-    for(i=0;i<NOUT_BUFS;i++)
-        iir_upconv_fixp(&s[i*(DUC_N)],&todac[i*(DUC_N*DUC_M)]);
-
-    f = fopen("iir_duc_s.txt", "wt");  assert(f != NULL);
-    for(i=0; i<NIN; i++)
-        fprintf(f, "%d\n", s[i]);
-    fprintf(f, "\n");
-    fclose(f);
-
-    f = fopen("iir_duc.txt", "wt");  assert(f != NULL);
-    for(i=0; i<NOUT; i++)
-        fprintf(f, "%d\n", todac[i]);
-    fprintf(f, "\n");
-    fclose(f);
-    return 0;
-}
-
-#endif
-
-
-//Coeffs for fixed point fir LPF and CIC precompensation
-static int fir_8c80r_cic_i[] = {
-    0,    0,   -2,   16,  -16,  -20,   26,   37,  -47,  -68,
-   83,  116, -139, -187,  219,  294, -339, -461,  528,  766,
- -882,-1540, 1730, 6117, 6117, 1730,-1540, -882,  766,  528,
- -461, -339,  294,  219, -187, -139,  116,   83,  -68,  -47,
-   37,   26,
-};
-
-//Coeffs for fir filter used in 48k comp to 80k real conversion
-static int fir_48c80r[] = {
-  -21,  -41,  -74, -109, -115,  -42,  153,  493,  958, 1483,
- 1970, 2316, 2441, 2316, 1970, 1483,  958,  493,  153,  -42,
- -115, -109,  -74,  -41,  -21,
-};
-
-
diff --git a/stm32/src/iir_tuner.c b/stm32/src/iir_tuner.c
deleted file mode 100644
index 84219955..00000000
--- a/stm32/src/iir_tuner.c
+++ /dev/null
@@ -1,325 +0,0 @@
- /*---------------------------------------------------------------------------*\
-
-  FILE........: iir_tuner.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 20 Feb 2015
-
-  Filter/decimator function, broken out to this file so we can unit
-  test easily.
-
-  Unit testing:
-
-    ~/codec2-dev/stm32$ gcc -D__UNITTEST__ -Iinc src/iir_tuner.c -o iir_tuner -lm -Wall
-    ~/codec2-dev/stm32$ ./iir_tuner
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2015 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifdef __UNITTEST__
-
-#include <assert.h>
-#include <math.h>
-#include <stdio.h>
-
-#endif
-
-#include "stm32f4_adc_tuner.h"
-#include "iir_tuner.h"
-
-/* Filter coefficients of IIR tuner (BETA1) and FIR equaliser (BETA2).
-   Note neat trick to relate BETA2 to BETA1 by the decimation rate */
-
-#define BETA1                    .9990234375			// B1MUL/(2**B1SHFT)
-#define B1MUL			 1023
-#define B1SMUL			 1204
-#define B1SHFT			 10				// 10 bits gives us plenty of headroom between 31 bits of int and 14 bits of ADC
-#define B2MUL			 979				// This actually matches BETA2 exactly with the supplied BETA1
-#define B2SHFT			 10				// 10 is also the lowest we can go without beta1=1
-#define BETA2                    (1.0 - (1.0-BETA1)*ADC_TUNER_M)// B2MUL/(2**B2SHFT)
-
-#define FIXED_IIR                                               //Define this to compile a fixed point IIR filter
-
-/* filter states - we keep them global due to the need for speed */
-
-#ifdef FIXED_IIR
-int n_2, n_1, o_2, o_1;
-#else
-float y_2, y_1, z_2, z_1;
-#endif
-
-/*
-   ADC -> signed conversion - IIR BPF - Decimate - FIR Equaliser -> FIFO
-*/
-
-void iir_tuner(
-               float          dec_50[],   // ADC_TUNER_N/2 output samples
-               unsigned short adc_buf[]   // ADC_TUNER_BUF_SZ/2 input samples
-) 
-{
-    int i, j, k;
-#ifndef FIXED_IIR
-    float x, y, z;
-#endif
-    int n, m, o;
-
-    for(i=0, j=0; i<ADC_TUNER_BUF_SZ/2; j++) {
-
-        /* IIR BPF centred at Fs/4.  All your MIPs are belong to this
-           loop. */
-        for(k=0; k<ADC_TUNER_M; k++,i++) {
-            #ifdef FIXED_IIR
-            m = (int)adc_buf[i];
-            n = m - ((B1SMUL*n_1)>>B1SHFT) - ((B1MUL*n_2)>>B1SHFT);
-            n_2 = n_1;
-            n_1 = n;
-            #else
-	    x = (int)adc_buf[i] - 32768;
-	    y = x - (BETA1*y_2);
-	    y_2 = y_1;
-            y_1 = y;
-            #endif
-        }
-
-        /* Equaliser FIR filter, notch at Fs/(4*ADC_TUNER_M) to smooth out
-           IIR BPF passband response */
-        #ifdef FIXED_IIR
-	o = n + ((B2MUL*o_2)>>B2SHFT);
-	dec_50[j] = (float)o;
-	o_2 = o_1;
-	o_1 = n;
-        #else
-	z=y+BETA2*z_2;
-	dec_50[j] = z;
-        z_2 = z_1;
-        z_1 = y;
-        #endif
-
-    }
-}
-
-
-/* BPF at 12.5 kHz +/- 2000 Hz, and decimate down to Fs = 10kHz */
-
-static float fir_50_to_10[];
-void iir_tuner_dec_50_to_10(float dec_10[], float dec_50[], int n) {
-    int   i,j,k;
-    float acc;
-
-    for(i=0,k=0; i<n; i+=5,k++) {
-        acc = 0.0;
-        for(j=0; j<IIR_TUNER_DEC_50_10_FILT_MEM; j++)
-            acc += dec_50[i-j]*fir_50_to_10[j];
-        dec_10[k] = acc;
-    }
-
-}
-
-
-#ifdef __UNITTEST__
-
-#define FS      2000000
-#define AMP_MAX 32767
-
-#define NOUT_BUFS    100
-#define NOUT         (NOUT_BUFS*ADC_TUNER_N)
-#define NIN          (NOUT*ADC_TUNER_M)
-
-void synth_line(unsigned short us[], float f, float amp, int n) {
-    float w, sam;
-    int   i;
-
-    w = 2*M_PI*f/(float)FS;
-
-    for(i=0; i<n; i++) {
-        sam = amp*AMP_MAX*cos(w*i);
-        us[i] += (unsigned short)(sam + 0.5);
-    }
-}
-
-
-int main(void) {
-    float          f1,f2,f3,f4;
-    unsigned short s[NIN];
-    float          dec_50[IIR_TUNER_DEC_50_10_FILT_MEM+NOUT];
-    float          dec_10[NOUT/5];
-    FILE          *f;
-    int            i,j,k;
-    short          dec_10_short;
-
-    /* test Fs=2E6 unsigned short to Fs=50E3 float tuner/resampler -----------------------*/
-
-    f1 = 700E3;
-    f2 = f1 + 8E3;       /* wanted */
-    f3 = f1 - 7E3;       /* wanted */
-    f4 = f1 - 207E3;     /* out of band, should be greatly attenuated */
-
-    for(i=0; i<NIN; i++)
-        s[i] = 32767;
-    synth_line(s, f1, 1, NIN);
-    //synth_line(s, f3, 0.1, NIN);
-    //synth_line(s, f4, 0.2, NIN);
-    for(i=0, j=0; i<NIN; i+=ADC_TUNER_BUF_SZ/2, j+=ADC_TUNER_N/2) {
-        iir_tuner(&dec_50[j], &s[i]);
-    }
-
-    f = fopen("iir_tuner_s.txt", "wt");  assert(f != NULL);
-    for(i=0; i<NIN; i++)
-        fprintf(f, "%d\n", s[i]);
-    fprintf(f, "\n");
-    fclose(f);
-
-    f = fopen("iir_tuner.txt", "wt");  assert(f != NULL);
-    for(i=0; i<NOUT; i++)
-        fprintf(f, "%f\n", dec_50[i]);
-    fprintf(f, "\n");
-    fclose(f);
-
-    /* test FS=2E6 unsigned short -> Fs=10kHz short ---------------------------------------------*/
-
-    for(i=0; i<NIN; i++)
-        s[i] = 32767;
-    for(i=1; i<NIN; i+=4)
-        s[i] += 32767;
-    for(i=3; i<NIN; i+=4)
-        s[i] -= 32767;
-
-    for(i=0, j=0, k=0; i<NIN; i+=ADC_TUNER_BUF_SZ/2, j+=ADC_TUNER_N/2, k+=(ADC_TUNER_N/2)/5) {
-        iir_tuner(&dec_50[IIR_TUNER_DEC_50_10_FILT_MEM+j], &s[i]);
-        iir_tuner_dec_50_to_10(&dec_10[k], &dec_50[IIR_TUNER_DEC_50_10_FILT_MEM+j], ADC_TUNER_N/2);
-    }
-
-    f = fopen("iir_tuner2.txt", "wt");  assert(f != NULL);
-    for(i=0; i<NOUT/5; i++) {
-        dec_10_short = dec_10[i]/ADC_TUNER_M;
-        fprintf(f, "%d\n", dec_10_short);
-    }
-    fprintf(f, "\n");
-    fclose(f);
-
-    return 0;
-}
-
-#endif
-
-/* Band pass FIR filter coefficents centred on Fs/4, used before Fs=50kHz to Fs=10kHz */
-
-static float fir_50_to_10[] = {
-    -1.71502876e-07,
-    -3.93029078e-05,
-    -5.30743362e-04,
-    1.17938704e-04,
-    1.09727519e-03,
-    -1.90605585e-04,
-    -1.61350037e-03,
-    2.37746793e-04,
-    1.86947117e-03,
-    -2.28459776e-04,
-    -1.56457257e-03,
-    1.33627883e-04,
-    4.28669971e-04,
-    5.51555269e-05,
-    1.60217953e-03,
-    -3.09989338e-04,
-    -4.22595074e-03,
-    5.63604865e-04,
-    6.71504730e-03,
-    -7.23797964e-04,
-    -8.02135199e-03,
-    7.03165104e-04,
-    7.05924883e-03,
-    -4.54750532e-04,
-    -3.11212393e-03,
-    2.24463518e-08,
-    -3.75334414e-03,
-    5.63496992e-04,
-    1.24113249e-02,
-    -1.08145162e-03,
-    -2.06694342e-02,
-    1.38572694e-03,
-    2.55955103e-02,
-    -1.34897285e-03,
-    -2.41472078e-02,
-    9.32473244e-04,
-    1.39715800e-02,
-    -2.09763900e-04,
-    5.83111135e-03,
-    -6.44614872e-04,
-    -3.42028021e-02,
-    1.40049434e-03,
-    6.80569757e-02,
-    -1.83898122e-03,
-    -1.02710848e-01,
-    1.82014182e-03,
-    1.32754277e-01,
-    -1.32936318e-03,
-    -1.53163914e-01,
-    4.86473969e-04,
-    1.60393264e-01,
-    4.86473969e-04,
-    -1.53163914e-01,
-    -1.32936318e-03,
-    1.32754277e-01,
-    1.82014182e-03,
-    -1.02710848e-01,
-    -1.83898122e-03,
-    6.80569757e-02,
-    1.40049434e-03,
-    -3.42028021e-02,
-    -6.44614872e-04,
-    5.83111135e-03,
-    -2.09763900e-04,
-    1.39715800e-02,
-    9.32473244e-04,
-    -2.41472078e-02,
-    -1.34897285e-03,
-    2.55955103e-02,
-    1.38572694e-03,
-    -2.06694342e-02,
-    -1.08145162e-03,
-    1.24113249e-02,
-    5.63496992e-04,
-    -3.75334414e-03,
-    2.24463518e-08,
-    -3.11212393e-03,
-    -4.54750532e-04,
-    7.05924883e-03,
-    7.03165104e-04,
-    -8.02135199e-03,
-    -7.23797964e-04,
-    6.71504730e-03,
-    5.63604865e-04,
-    -4.22595074e-03,
-    -3.09989338e-04,
-    1.60217953e-03,
-    5.51555269e-05,
-    4.28669971e-04,
-    1.33627883e-04,
-    -1.56457257e-03,
-    -2.28459776e-04,
-    1.86947117e-03,
-    2.37746793e-04,
-    -1.61350037e-03,
-    -1.90605585e-04,
-    1.09727519e-03,
-    1.17938704e-04,
-    -5.30743362e-04,
-    -3.93029078e-05,
-    -1.71502876e-07
-};
-
diff --git a/stm32/src/power_ut.c b/stm32/src/power_ut.c
deleted file mode 100644
index 97338239..00000000
--- a/stm32/src/power_ut.c
+++ /dev/null
@@ -1,135 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: power_ut.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 30 May 2014
-
-  Runs Codec 2, ADC, and DAC, to fully exercise STM32C so we can a feel for
-  run-time power consumption for SM1000 and hence dimension regulators.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2014 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <math.h>
-
-#include "stm32f4xx_conf.h"
-#include "stm32f4xx.h"
-#include "stm32f4_adc.h"
-#include "stm32f4_dac.h"
-#include "gdb_stdio.h"
-#include "codec2.h"
-#include "dump.h"
-#include "sine.h"
-#include "machdep.h"
-
-#ifdef __EMBEDDED__
-#define printf gdb_stdio_printf
-#define fopen gdb_stdio_fopen
-#define fclose gdb_stdio_fclose
-#define fread gdb_stdio_fread
-#define fwrite gdb_stdio_fwrite
-#endif
-
-#define SPEED_TEST_SAMPLES 24000
-
-/* modification of test used to measure codec2 execuation speed.  We read/write ADC/DAC
-   but dont do anything with the samples, as they are at 16 kHz and codec needs 8 kHz.  Just
-   trying to exercise everything to get a feel for power consumption */
-
-static void c2speedtest(int mode, char inputfile[])
-{
-    struct CODEC2 *codec2;
-    short         *inbuf, *outbuf, *pinbuf, *dummy_buf;
-    unsigned char *bits;
-    int            nsam, nbit, nframes;
-    FILE          *fin;
-    int            f, nread;
-
-    codec2 = codec2_create(mode);
-    nsam = codec2_samples_per_frame(codec2);
-    nframes = SPEED_TEST_SAMPLES/nsam;
-    outbuf = (short*)malloc(nsam*sizeof(short));
-    inbuf = (short*)malloc(SPEED_TEST_SAMPLES*sizeof(short));
-    nbit = codec2_bits_per_frame(codec2);
-    bits = (unsigned char*)malloc(nbit*sizeof(char));
-    dummy_buf = (short*)malloc(2*nsam*sizeof(short));
-
-    fin = fopen(inputfile, "rb");
-    if (fin == NULL) {
-        printf("Error opening input file: %s\nTerminating....\n",inputfile);
-        exit(1);
-    }
-
-    printf("reading samples ....\n");
-    nread = fread(inbuf, sizeof(short), SPEED_TEST_SAMPLES, fin);
-    if (nread != SPEED_TEST_SAMPLES) {
-        printf("error reading %s, %d samples reqd, %d read\n",
-               inputfile, SPEED_TEST_SAMPLES, nread);
-    }
-    fclose(fin);
-
-    pinbuf = inbuf;
-    for(f=0; f<nframes; f++) {
-        //printf("read ADC\n");
-        while(adc1_read(dummy_buf, nsam*2) == -1);  /* runs at Fs = 16kHz */
-
-        //printf("Codec 2 enc\n");
-	GPIOD->ODR = (1 << 13);
-        codec2_encode(codec2, bits, pinbuf);
-        pinbuf += nsam;
-	GPIOD->ODR &= ~(1 << 13);
-        //printf("Codec 2 dec\n");
-	codec2_decode(codec2, outbuf, bits);
-
-        //printf("write to DAC\n");
-        while(dac1_write(dummy_buf, nsam*2) == -1); /* runs at Fs = 16kHz */
-        //printf(".");
-    }
-
-    free(inbuf);
-    free(outbuf);
-    free(bits);
-    codec2_destroy(codec2);
-}
-
-void gpio_init() {
-    RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN; // enable the clock to GPIOD
-    GPIOD->MODER = (1 << 26);            // set pin 13 to be general
-                                         // purpose output
-}
-
-int main(int argc, char *argv[]) {
-    SystemInit();
-    gpio_init();
-    machdep_profile_init ();
-    adc_open(4*DAC_BUF_SZ);
-    dac_open(4*DAC_BUF_SZ);
-
-    printf("Starting power_ut\n");
-
-    c2speedtest(CODEC2_MODE_1600, "stm_in.raw");
-
-    printf("Finished\n");
-
-    return 0;
-}
-
diff --git a/stm32/src/si5351_ut.c b/stm32/src/si5351_ut.c
deleted file mode 100644
index d79a4da2..00000000
--- a/stm32/src/si5351_ut.c
+++ /dev/null
@@ -1,45 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: si5351_ut.c
-  AUTHOR......: David Rowe
-  DATE CREATED: June 2016
-
-  Generates a 10MHz signal on CLK0 ouput of Si5351, should be visible in 
-  attenuated form on SP7/SP7 of SM2000.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2016 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <assert.h>
-#include "new_i2c.h"
-#include "si53xx.h"
-//#include "gdb_stdio.h"
-//#define printf gdb_stdio_printf
-
-int main(void) {
-
-    //printf("starting\n");
-    I2C_Setup();
-    si5351_init(0, SI5351_CRYSTAL_LOAD_6PF, 0);
-    si5351_set_freq(1000000000ULL, 0, SI5351_CLK0);
-    // int ret = si5351_set_freq(1000000000ULL, 0, SI5351_CLK0);
-    //printf(" ret = %d\n", ret);
-
-    while(1);
-}
diff --git a/stm32/src/si53xx.c b/stm32/src/si53xx.c
deleted file mode 100644
index 48576a3b..00000000
--- a/stm32/src/si53xx.c
+++ /dev/null
@@ -1,856 +0,0 @@
-/*------------------------------------------------------------------------------
- * 
- * Ported to stm32F4xx non c++ by Leon Lessing leon@lrlabs.com or zs6lmg@gmail.com
- * 
- * 
- * Copyright (C) 2015-2016 Jason Milldrum <milldrum@gmail.com>
- *                         Dana H. Myers <k6jq@comcast.net>
- *
- * Many defines derived from clk-si5351.h in the Linux kernel.
- * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
- * Rabeeh Khoury <rabeeh@solid-run.com>
- *
- * do_div() macro derived from /include/asm-generic/div64.h in
- * the Linux kernel.
- * Copyright (C) 2003 Bernardo Innocenti <bernie@develer.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- * 
- * 
- *------------------------------------------------------------------------------
-*/
-
-#include "stm32f4xx.h"
-#include "stm32f4xx_conf.h"
-//#include "system.h"
-
-#include "new_i2c.h"
-//#include "inc/xprintf.h"
-#include "stdlib.h"
-#include "string.h"
-#include "math.h"
-#include "si53xx.h"
-
-
-void si5351_write(uint8_t REGaddr, uint8_t data) {
-    // ignoring errors
-    // Waiting for the bite
-    Si5351_Config.I2C_ErrorCode=I2C_NewWriteRegister(Si5351_Config.I2C_add, REGaddr, data);
-
-    /*
-    printf("  si5351_write: REGaddr: 0x%02x data...: 0x%02x", REGaddr, data);
-    if (Si5351_Config.I2C_ErrorCode > 0xff)
-        printf("  ErrorCode: 0x%02x\n", Si5351_Config.I2C_ErrorCode);
-    else
-        printf("\n");
-    */
-}
-
-void si5351_write_bulk(uint8_t REGaddr, uint8_t bytes, uint8_t *data) {
-    Si5351_Config.I2C_ErrorCode=I2C_NewWriteRegisterN(Si5351_Config.I2C_add, REGaddr, data, bytes);
-}
-
-
-uint8_t si5351_read(uint8_t REGaddr) {
-    uint8_t reg_val;
-    Si5351_Config.I2C_ErrorCode=I2C_NewReadRegister(Si5351_Config.I2C_add,REGaddr);
-    //printf("  si5351_read.: REGaddr: 0x%02x", REGaddr);
-    if (Si5351_Config.I2C_ErrorCode>0xff) {
-        reg_val=0;
-        //printf(" ErrorCode: 0x%02x\n", Si5351_Config.I2C_ErrorCode);
-    } else {
-        reg_val=(uint8_t)(Si5351_Config.I2C_ErrorCode & 0xff);
-        Si5351_Config.I2C_ErrorCode=0;
-        //printf(" reg_val: 0x%02x\n", reg_val);
-    }
-    return reg_val;
-}
-
-/*------------------------------------------------------------------------------
- * @brief si5351_init(uint8_t xtal_load_c, uint32_t ref_osc_freq)
- * Setup communications to the Si5351 and set the crystal
- * load capacitance.
- *
- * @param I2C_Address - enter I2C address here, use 0 to use .h file defined value
- * 
- * @param xtal_load_c - Crystal load capacitance. Use the SI5351_CRYSTAL_LOAD_*PF
- * defines in the header file
- * 
- * @param ref_osc_freq - Crystal/reference oscillator frequency in 1 Hz increments.
- * Defaults to 25000000 if a 0 is used here.
- * 
- *------------------------------------------------------------------------------
- */
-void si5351_init(uint8_t I2C_Address, uint8_t xtal_load_c, uint32_t ref_osc_freq) {
-    //printf("si5351_init\n");
-
-    Si5351_Config.clk0_freq=0;
-    Si5351_Config.lock_plla = SI5351_CLKNONE;
-    Si5351_Config.lock_pllb = SI5351_CLKNONE;
-    Si5351_Config.clk0_int_mode = 0;
-    Si5351_Config.clk1_int_mode = 0;
-    Si5351_Config.clk2_int_mode = 0;
-    Si5351_Config.plla_freq = 0;
-    Si5351_Config.pllb_freq = 0;
-    Si5351_Config.clk0_freq = 0;
-    Si5351_Config.clk1_freq = 0;
-    Si5351_Config.clk2_freq = 0;
-    Si5351_Config.xtal_freq = SI5351_XTAL_FREQ;
-    Si5351_Config.I2C_add = SI5351_BUS_BASE_ADDR << 1;
-    if (I2C_Address != 0) Si5351_Config.I2C_add=I2C_Address << 1;
-    // Set crystal load capacitance
-    uint8_t reg_val = 0x12; // 0b010010 reserved value bits
-    reg_val |= xtal_load_c;
-    si5351_write(SI5351_CRYSTAL_LOAD, reg_val);
-
-    // DR: test of I2C
-    reg_val = si5351_read(SI5351_CRYSTAL_LOAD);
-    //printf("reg_val: 0x%02x\n", reg_val);
-
-    // Change the ref osc freq if different from default
-    // Divide down if greater than 30 MHz
-    if (ref_osc_freq != 0) {
-        uint8_t reg_val;
-        reg_val = si5351_read(SI5351_PLL_INPUT_SOURCE);
-        //
-        // Clear the bits first
-        reg_val &= ~(SI5351_CLKIN_DIV_MASK);
-        if(ref_osc_freq <= 30000000) {
-            Si5351_Config.xtal_freq = ref_osc_freq;
-            reg_val |= SI5351_CLKIN_DIV_1;
-        } else if(ref_osc_freq > 30000000 && ref_osc_freq <= 60000000) {
-            Si5351_Config.xtal_freq = ref_osc_freq / 2;
-            reg_val |= SI5351_CLKIN_DIV_2;
-        } else if(ref_osc_freq > 60000000 && ref_osc_freq <= 100000000) {
-            Si5351_Config.xtal_freq = ref_osc_freq / 4;
-            reg_val |= SI5351_CLKIN_DIV_4;
-        }
-        si5351_write(SI5351_PLL_INPUT_SOURCE, reg_val);
-    }
-    // Initialize the CLK outputs according to flowchart in datasheet
-    // First, turn them off
-    si5351_write(16, 0x80);
-    si5351_write(17, 0x80);
-    si5351_write(18, 0x80);
-
-    // Turn the clocks back on...
-    si5351_write(16, 0x0c);
-    si5351_write(17, 0x0c);
-    si5351_write(18, 0x0c);
-
-    // Then reset the PLLs
-    si5351_pll_reset(SI5351_PLLA);
-    si5351_pll_reset(SI5351_PLLB);
-}
-
-
-
-
-/*------------------------------------------------------------------------------
- * @brief si5351_set_freq(uint64_t freq, uint64_t pll_freq, enum si5351_clock output)
- * Sets the clock frequency of the specified CLK output
- *
- * @param freq - Output frequency in 0.01 Hz increments, so for 10MHz 
- *               use 1000000000ULL
- * 
- * @param pll_freq - Frequency of the PLL driving the Multisynth
- *   Use a 0 to have the function choose a PLL frequency
- * 
- * @param clk - Clock output
- *   (use the si5351_clock enum)
- *------------------------------------------------------------------------------
- */
-uint8_t si5351_set_freq(uint64_t freq, uint64_t pll_freq, enum si5351_clock clk) {
-    struct Si5351RegSet ms_reg;
-    enum si5351_pll target_pll;
-    uint8_t write_pll = 0;
-    uint8_t r_div = SI5351_OUTPUT_CLK_DIV_1;
-    uint8_t int_mode = 0;
-    uint8_t div_by_4 = 0;
-
-    //printf("si5351_set_freq:\n");
-
-    // PLL bounds checking
-    if(pll_freq != 0) {
-        if ((pll_freq < SI5351_PLL_VCO_MIN * SI5351_FREQ_MULT)
-                || (pll_freq > SI5351_PLL_VCO_MAX * SI5351_FREQ_MULT)) {
-            return 1;
-        }
-    }
-
-    //printf("freq: 0x%0x 0x%0x\n", (uint32_t)(freq >> 32), (uint32_t)(freq & 0xffffffff));
-
-    // Lower bounds check
-    if(freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT) {
-        freq = SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT;
-    }
-
-    // Upper bounds check
-    if(freq > SI5351_MULTISYNTH_MAX_FREQ * SI5351_FREQ_MULT) {
-        freq = SI5351_MULTISYNTH_MAX_FREQ * SI5351_FREQ_MULT;
-    }
-
-    //printf("freq: 0x%0x 0x%0x\n", (uint32_t)(freq >> 32), (uint32_t)(freq & 0xffffffff));
-
-    // Select the proper R div value
-    r_div = si5351_select_r_div(&freq);
-
-    // Calculate the synth parameters
-    // If pll_freq is 0 and freq < 150 MHz, let the algorithm pick a PLL frequency
-    if ((pll_freq) && (freq < SI5351_MULTISYNTH_DIVBY4_FREQ * SI5351_FREQ_MULT)) {
-        si5351_multisynth_calc(freq, pll_freq, &ms_reg);
-        write_pll = 0;
-        div_by_4 = 0;
-        int_mode = 0;
-
-        switch(clk)      {
-            case SI5351_CLK0:
-                    Si5351_Config.clk0_freq = freq;
-                    break;
-            case SI5351_CLK1:
-                    Si5351_Config.clk1_freq = freq;
-                    break;
-            case SI5351_CLK2:
-                    Si5351_Config.clk2_freq = freq;
-                    break;
-            default:
-                    break;
-        }
-    } else {
-        // The PLL must be calculated and set by firmware when 150 MHz <= freq <= 160 MHz
-        if(freq >= SI5351_MULTISYNTH_DIVBY4_FREQ * SI5351_FREQ_MULT) {
-            pll_freq = si5351_multisynth_calc(freq, 0, &ms_reg);
-            write_pll = 1;
-            div_by_4 = 1;
-            int_mode = 1;
-        }
-
-        // Determine which PLL to use
-        // CLK0 gets PLLA, CLK1 gets PLLB
-        // CLK2 gets PLLB if necessary
-        // Only good for Si5351A3 variant at the moment
-        switch(clk) {
-            case SI5351_CLK0:
-                    //printf("case SI5351_CLK0\n");
-                    pll_freq = si5351_multisynth_calc(freq, 0, &ms_reg);
-                    target_pll = SI5351_PLLA;
-                    write_pll = 1;
-                    si5351_set_ms_source(SI5351_CLK0, SI5351_PLLA);
-
-                    //printf("pll_freq: 0x%0x 0x%0x\n", (uint32_t)(pll_freq >> 32), (uint32_t)(pll_freq & 0xffffffff));
-                    //printf("freq: 0x%0x 0x%0x\n", (uint32_t)(freq >> 32), (uint32_t)(freq & 0xffffffff));
-
-                    Si5351_Config.plla_freq = pll_freq;
-                    Si5351_Config.clk0_freq = freq;
-                    break;
-            case SI5351_CLK1:
-                    // Check to see if PLLB is locked due to other output being < 1.024 MHz or >= 112.5 MHz
-                    if(Si5351_Config.lock_pllb == SI5351_CLK2) {
-                        // We can't have a 2nd output < 1.024 MHz or >= 112.5 MHz on the same PLL unless exact same freq, so exit
-                        if((freq >= SI5351_MULTISYNTH_SHARE_MAX * SI5351_FREQ_MULT
-                                || freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 128)
-                                && freq != Si5351_Config.clk2_freq) {
-                            Si5351_Config.clk1_freq = 0;
-                            return 1;
-                        } else {
-                            // Else, set multisynth to same PLL freq as CLK2
-                            pll_freq = Si5351_Config.pllb_freq;
-                            si5351_multisynth_calc(freq, pll_freq, &ms_reg);
-                            write_pll = 0;
-                            si5351_set_ms_source(SI5351_CLK1, SI5351_PLLB);
-                        }
-                    } else {
-                        Si5351_Config.pllb_freq = pll_freq;
-                        pll_freq = si5351_multisynth_calc(freq, 0, &ms_reg);
-                        write_pll = 1;
-                        si5351_set_ms_source(SI5351_CLK1, SI5351_PLLB);
-                    }
-
-                    if(freq >= SI5351_MULTISYNTH_SHARE_MAX * SI5351_FREQ_MULT
-                            || freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 128) {
-                        Si5351_Config.lock_pllb = SI5351_CLK1;
-
-                        // Recalc and rewrite the multisynth parameters on CLK2
-                        if(Si5351_Config.clk2_freq != 0) {
-                            struct Si5351RegSet ms_temp_reg;
-                            r_div = si5351_select_r_div(&Si5351_Config.clk2_freq);
-                            si5351_multisynth_calc(Si5351_Config.clk2_freq, \
-                                    Si5351_Config.pllb_freq, &ms_temp_reg);
-                            si5351_set_ms(SI5351_CLK2, ms_temp_reg, 0, r_div, 0);
-                        }
-                    } else {
-                        Si5351_Config.lock_pllb = SI5351_CLKNONE;
-                    }
-
-                    target_pll = SI5351_PLLB;
-                    Si5351_Config.clk1_freq = freq;
-                    break;
-            case SI5351_CLK2:
-                    // Check to see if PLLB is locked due to other output being < 1.024 MHz or >= 112.5 MHz
-                    if(Si5351_Config.lock_pllb == SI5351_CLK1) {
-                        // We can't have a 2nd output < 1.024 MHz  or >= 112.5 MHz on the same PLL unless exact same freq, so exit
-                        if((freq >= SI5351_MULTISYNTH_SHARE_MAX * SI5351_FREQ_MULT
-                                || freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 128)
-                                && freq != Si5351_Config.clk2_freq) {
-                            Si5351_Config.clk2_freq = 0;
-                            return 1;
-                        } else {
-                            // Else, set multisynth to same PLL freq as CLK1
-                            pll_freq = Si5351_Config.pllb_freq;
-                            si5351_multisynth_calc(freq, pll_freq, &ms_reg);
-                            write_pll = 0;
-                            si5351_set_ms_source(SI5351_CLK2, SI5351_PLLB);
-                        }
-                    } else {
-                        // need to account for CLK2 set before CLK1
-                        Si5351_Config.pllb_freq = pll_freq;
-                        pll_freq = si5351_multisynth_calc(freq, 0, &ms_reg);
-                        write_pll = 1;
-                        si5351_set_ms_source(SI5351_CLK2, SI5351_PLLB);
-                    }
-
-                    if(freq >= SI5351_MULTISYNTH_SHARE_MAX * SI5351_FREQ_MULT 
-                            || freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 128) {
-                        Si5351_Config.lock_pllb = SI5351_CLK2;
-
-                        if(Si5351_Config.clk1_freq != 0) {
-                            // Recalc and rewrite the multisynth parameters on CLK1
-                            struct Si5351RegSet ms_temp_reg;
-                            r_div = si5351_select_r_div(&Si5351_Config.clk1_freq);
-                            si5351_multisynth_calc(Si5351_Config.clk1_freq, Si5351_Config.pllb_freq, &ms_temp_reg);
-                            si5351_set_ms(SI5351_CLK1, ms_temp_reg, 0, r_div, 0);
-                        }
-                    } else {
-                        Si5351_Config.lock_pllb = SI5351_CLKNONE;
-                    }
-
-                    target_pll = SI5351_PLLB;
-                    Si5351_Config.clk2_freq = freq;
-                    break;
-            default:
-                    return 1;
-        }
-    }
-
-    // Set multisynth registers (MS must be set before PLL)
-    si5351_set_ms(clk, ms_reg, int_mode, r_div, div_by_4);
-
-    // Set PLL if necessary
-    if (write_pll == 1) {
-        si5351_set_pll(pll_freq, target_pll);
-    }
-
-    return 0;
-}
-
-/*------------------------------------------------------------------------------
- * @brief si5351_set_pll(uint64_t pll_freq, enum si5351_pll target_pll)
- *
- * Set the specified PLL to a specific oscillation frequency
- *
- * @param pll_freq - Desired PLL frequency
- * 
- * @param target_pll - Which PLL to set
- *     (use the si5351_pll enum)
- *------------------------------------------------------------------------------
- */
-void si5351_set_pll(uint64_t pll_freq, enum si5351_pll target_pll) {
-  struct Si5351RegSet pll_reg;
-
-  si5351_pll_calc(pll_freq, &pll_reg, Si5351_Config.ref_correction);
-
-  // Derive the register values to write
-
-  // Prepare an array for parameters to be written to
-  uint8_t *params;
-  uint8_t buffer[20];
-  uint8_t i = 0;
-  uint8_t temp;
-  params = (uint8_t *)&buffer;
-
-  // Registers 26-27
-  temp = ((pll_reg.p3 >> 8) & 0xFF);
-  params[i++] = temp;
-
-  temp = (uint8_t)(pll_reg.p3  & 0xFF);
-  params[i++] = temp;
-
-  // Register 28
-  temp = (uint8_t)((pll_reg.p1 >> 16) & 0x03);
-  params[i++] = temp;
-
-  // Registers 29-30
-  temp = (uint8_t)((pll_reg.p1 >> 8) & 0xFF);
-  params[i++] = temp;
-
-  temp = (uint8_t)(pll_reg.p1  & 0xFF);
-  params[i++] = temp;
-
-  // Register 31
-  temp = (uint8_t)((pll_reg.p3 >> 12) & 0xF0);
-  temp += (uint8_t)((pll_reg.p2 >> 16) & 0x0F);
-  params[i++] = temp;
-
-  // Registers 32-33
-  temp = (uint8_t)((pll_reg.p2 >> 8) & 0xFF);
-  params[i++] = temp;
-
-  temp = (uint8_t)(pll_reg.p2  & 0xFF);
-  params[i++] = temp;
-
-  // Write the parameters
-  if (target_pll == SI5351_PLLA) {
-    si5351_write_bulk(SI5351_PLLA_PARAMETERS, i, params);
-  } else if (target_pll == SI5351_PLLB) {
-    si5351_write_bulk(SI5351_PLLB_PARAMETERS, i, params);
-  }
-}
-
-
-
-
-/*------------------------------------------------------------------------------
- * @brief  si5351_pll_reset(enum si5351_pll target_pll)
- * target_pll - Which PLL to reset
- *     (use the si5351_pll enum)
- *
- * Apply a reset to the indicated PLL.
- * @param SI5351_PLL_RESET_A or SI5351_PLL_RESET_B
- * 
- * @return none
- *------------------------------------------------------------------------------
- */
-void si5351_pll_reset(enum si5351_pll target_pll) {
-    if(target_pll == SI5351_PLLA) {
-        si5351_write(SI5351_PLL_RESET, SI5351_PLL_RESET_A);
-    } else if(target_pll == SI5351_PLLB) {
-        si5351_write(SI5351_PLL_RESET, SI5351_PLL_RESET_B);
-    }
-}
-
-/*------------------------------------------------------------------------------
- * @brief set_int(enum si5351_clock clk, uint8_t int_mode)
- * Set the indicated multisynth into integer mode.
- *
- * @param clk - Clock output
- *   (use the si5351_clock enum)
- * 
- * @param enable - Set to 1 to enable, 0 to disable
- *
- *------------------------------------------------------------------------------
- */
-void si5351_set_int(enum si5351_clock clk, uint8_t enable){
-    uint8_t reg_val;
-    reg_val = si5351_read(SI5351_CLK0_CTRL + (uint8_t)clk);
-
-    if(enable == 1) {
-            reg_val |= (SI5351_CLK_INTEGER_MODE);
-    } else {
-            reg_val &= ~(SI5351_CLK_INTEGER_MODE);
-    }
-
-    si5351_write(SI5351_CLK0_CTRL + (uint8_t)clk, reg_val);
-
-    // Integer mode indication
-    switch(clk) {
-	case SI5351_CLK0:
-		Si5351_Config.clk0_int_mode = enable;
-		break;
-	case SI5351_CLK1:
-		Si5351_Config.clk1_int_mode = enable;
-		break;
-	case SI5351_CLK2:
-		Si5351_Config.clk2_int_mode = enable;
-		break;
-	default:
-		break;
-    }
-}
-
-
-/*------------------------------------------------------------------------------
- * @brief si5351_set_clock_pwr(enum si5351_clock clk, uint8_t pwr)
- * Enable or disable power to a clock output (a power
- * saving feature).
- *
- * @param clk - Clock output
- *   (use the si5351_clock enum)
- * 
- * @param pwr - Set to 1 to enable, 0 to disable
- *
- *------------------------------------------------------------------------------
- */
-void si5351_set_clock_pwr(enum si5351_clock clk, uint8_t pwr) {
-    uint8_t reg_val;
-    reg_val = si5351_read(SI5351_CLK0_CTRL + (uint8_t)clk);
-    if(pwr == 1) {
-        reg_val &= 0b01111111;
-    } else {
-        reg_val |= 0b10000000;
-    }
-    si5351_write(SI5351_CLK0_CTRL + (uint8_t)clk, reg_val);
-}
-
-/*------------------------------------------------------------------------------
- * @brief si5351_set_clock_invert(enum si5351_clock clk, uint8_t inv)
- * Enable to invert the clock output waveform.
- *
- * @param clk - Clock output
- *   (use the si5351_clock enum)
- * 
- * @param inv - Set to 1 to enable, 0 to disable
- *
- * -----------------------------------------------------------------------------
- */
-void si5351_set_clock_invert(enum si5351_clock clk, uint8_t inv) {
-    uint8_t reg_val;
-    reg_val = si5351_read(SI5351_CLK0_CTRL + (uint8_t)clk);
-    if(inv == 1) {
-        reg_val |= (SI5351_CLK_INVERT);
-    } else {
-        reg_val &= ~(SI5351_CLK_INVERT);
-    }
-    si5351_write(SI5351_CLK0_CTRL + (uint8_t)clk, reg_val);
-}
-
-
-/*------------------------------------------------------------------------------
- * @brief si5351_set_ms(enum si5351_clock clk, struct Si5351RegSet ms_reg,
- *  uint8_t int_mode, uint8_t r_div, uint8_t div_by_4)
- *
- * Set the specified multisynth parameters. Not normally needed, but public for advanced users.
- *
- * @param clk - Clock output
- *   (use the si5351_clock enum)
- * 
- * @param int_mode - Set integer mode
- *  Set to 1 to enable, 0 to disable
- * 
- * @param r_div - Desired r_div ratio
- * 
- * @param div_by_4 - Set Divide By 4 mode
- *   Set to 1 to enable, 0 to disable
- *------------------------------------------------------------------------------
- */
-void si5351_set_ms(enum si5351_clock clk, struct Si5351RegSet ms_reg, uint8_t int_mode, uint8_t r_div, uint8_t div_by_4) {
-    uint8_t *params;
-    uint8_t buffer[20];
-    uint8_t i = 0;
-    uint8_t temp;
-    uint8_t reg_val;
-
-    params = (uint8_t *)&buffer;
-    // Registers 42-43 for CLK0
-    temp = (uint8_t)((ms_reg.p3 >> 8) & 0xFF);
-    params[i++] = temp;
-
-    temp = (uint8_t)(ms_reg.p3  & 0xFF);
-    params[i++] = temp;
-
-    // Register 44 for CLK0
-    reg_val = si5351_read((SI5351_CLK0_PARAMETERS + 2) + (clk * 8));
-    reg_val &= ~(0x03);
-    temp = reg_val | ((uint8_t)((ms_reg.p1 >> 16) & 0x03));
-    params[i++] = temp;
-
-    // Registers 45-46 for CLK0
-    temp = (uint8_t)((ms_reg.p1 >> 8) & 0xFF);
-    params[i++] = temp;
-
-    temp = (uint8_t)(ms_reg.p1  & 0xFF);
-    params[i++] = temp;
-
-    // Register 47 for CLK0
-    temp = (uint8_t)((ms_reg.p3 >> 12) & 0xF0);
-    temp += (uint8_t)((ms_reg.p2 >> 16) & 0x0F);
-    params[i++] = temp;
-
-    // Registers 48-49 for CLK0
-    temp = (uint8_t)((ms_reg.p2 >> 8) & 0xFF);
-    params[i++] = temp;
-
-    temp = (uint8_t)(ms_reg.p2  & 0xFF);
-    params[i++] = temp;
-
-    // Write the parameters
-    switch (clk) {
-        case SI5351_CLK0:
-                si5351_write_bulk(SI5351_CLK0_PARAMETERS, i, params);
-                break;
-        case SI5351_CLK1:
-                si5351_write_bulk(SI5351_CLK1_PARAMETERS, i, params);
-                break;
-        case SI5351_CLK2:
-                si5351_write_bulk(SI5351_CLK2_PARAMETERS, i, params);
-                break;
-        case SI5351_CLK3:
-                si5351_write_bulk(SI5351_CLK3_PARAMETERS, i, params);
-                break;
-        case SI5351_CLK4:
-                si5351_write_bulk(SI5351_CLK4_PARAMETERS, i, params);
-                break;
-        case SI5351_CLK5:
-                si5351_write_bulk(SI5351_CLK5_PARAMETERS, i, params);
-                break;
-        case SI5351_CLK6:
-                si5351_write_bulk(SI5351_CLK6_PARAMETERS, i, params);
-                break;
-        case SI5351_CLK7:
-                si5351_write_bulk(SI5351_CLK7_PARAMETERS, i, params);
-                break;
-        case SI5351_CLKNONE:
-                return;
-    }
-
-    si5351_set_int(clk, int_mode);
-    si5351_ms_div(clk, r_div, div_by_4);
-}
-
-void si5351_ms_div(enum si5351_clock clk, uint8_t r_div, uint8_t div_by_4) {
-    uint8_t reg_val, reg_addr;
-
-    switch(clk) {
-        case SI5351_CLK0:
-                reg_addr = SI5351_CLK0_PARAMETERS + 2;
-                break;
-        case SI5351_CLK1:
-                reg_addr = SI5351_CLK1_PARAMETERS + 2;
-                break;
-        case SI5351_CLK2:
-                reg_addr = SI5351_CLK2_PARAMETERS + 2;
-                break;
-        case SI5351_CLK3:
-                reg_addr = SI5351_CLK3_PARAMETERS + 2;
-                break;
-        case SI5351_CLK4:
-                reg_addr = SI5351_CLK4_PARAMETERS + 2;
-                break;
-        case SI5351_CLK5:
-                reg_addr = SI5351_CLK5_PARAMETERS + 2;
-                break;
-        case SI5351_CLK6:
-                return;
-        case SI5351_CLK7:
-                return;
-        case SI5351_CLKNONE:
-                return;
-	default:
-		return;
-    }
-
-    reg_val = si5351_read(reg_addr);
-
-    // Clear the relevant bits
-    reg_val &= ~(0x7c);
-
-    if(div_by_4 == 0) {
-            reg_val &= ~(SI5351_OUTPUT_CLK_DIVBY4);
-    } else {
-            reg_val |= (SI5351_OUTPUT_CLK_DIVBY4);
-    }
-
-    reg_val |= (r_div << SI5351_OUTPUT_CLK_DIV_SHIFT);
-
-    si5351_write(reg_addr, reg_val);
-}
-
-/*------------------------------------------------------------------------------
- * @brief set_ms_source(enum si5351_clock clk, enum si5351_pll pll)
- * Set the desired PLL source for a multisynth.
- *
- * @param clk - Clock output
- *   (use the si5351_clock enum)
- * 
- * @param pll - Which PLL to use as the source
- *     (use the si5351_pll enum)
- *
- *------------------------------------------------------------------------------
- */
-void si5351_set_ms_source(enum si5351_clock clk, enum si5351_pll pll) {
-    uint8_t reg_val;
-
-    reg_val = si5351_read(SI5351_CLK0_CTRL + (uint8_t)clk);
-
-    if(pll == SI5351_PLLA) {
-            reg_val &= ~(SI5351_CLK_PLL_SELECT);
-    } else if (pll == SI5351_PLLB) {
-            reg_val |= SI5351_CLK_PLL_SELECT;
-    }
-    si5351_write(SI5351_CLK0_CTRL + (uint8_t)clk, reg_val);
-}
-
-uint64_t si5351_multisynth_calc(uint64_t freq, uint64_t pll_freq, struct Si5351RegSet *reg) {
-    uint64_t lltmp;
-    uint32_t a, b, c, p1, p2, p3;
-    uint8_t divby4;
-    uint8_t ret_val = 0;
-
-    // Multisynth bounds checking
-    if (freq > SI5351_MULTISYNTH_MAX_FREQ * SI5351_FREQ_MULT) {
-        freq = SI5351_MULTISYNTH_MAX_FREQ * SI5351_FREQ_MULT;
-    }
-    if (freq < SI5351_MULTISYNTH_MIN_FREQ * SI5351_FREQ_MULT) {
-        freq = SI5351_MULTISYNTH_MIN_FREQ * SI5351_FREQ_MULT;
-    }
-
-    divby4 = 0;
-    if (freq >= SI5351_MULTISYNTH_DIVBY4_FREQ * SI5351_FREQ_MULT) {
-        divby4 = 1;
-    }
-
-    if(pll_freq == 0) {
-        // Find largest integer divider for max
-        // VCO frequency and given target frequency
-        if(divby4 == 0) {
-            lltmp = SI5351_PLL_VCO_MAX * SI5351_FREQ_MULT;
-            do_div(lltmp, freq);
-            a = (uint32_t)lltmp;
-        } else {
-            a = 4;
-        }
-
-        b = 0;
-        c = 1;
-        pll_freq = a * freq;
-    } else {
-        // Preset PLL, so return the actual freq for these params instead of PLL freq
-        ret_val = 1;
-        // Determine integer part of feedback equation
-        a = pll_freq / freq;
-        if (a < SI5351_MULTISYNTH_A_MIN) {
-            freq = pll_freq / SI5351_MULTISYNTH_A_MIN;
-        }
-        if (a > SI5351_MULTISYNTH_A_MAX) {
-            freq = pll_freq / SI5351_MULTISYNTH_A_MAX;
-        }
-        b = (pll_freq % freq * RFRAC_DENOM) / freq;
-        c = b ? RFRAC_DENOM : 1;
-    }
-
-    // Calculate parameters
-    if (divby4 == 1) {
-        p3 = 1;
-        p2 = 0;
-        p1 = 0;
-    } else {
-        p1 = 128 * a + ((128 * b) / c) - 512;
-        p2 = 128 * b - c * ((128 * b) / c);
-        p3 = c;
-    }
-
-    reg->p1 = p1;
-    reg->p2 = p2;
-    reg->p3 = p3;
-
-    if(ret_val == 0) {
-        return pll_freq;
-    } else {
-        return freq;
-    }
-}
-
-uint64_t si5351_pll_calc(uint64_t freq, struct Si5351RegSet *reg, int32_t correction) {
-    uint64_t ref_freq = Si5351_Config.xtal_freq * SI5351_FREQ_MULT;
-    uint32_t a, b, c, p1, p2, p3;
-    uint64_t lltmp, denom;
-
-
-    // Factor calibration value into nominal crystal frequency
-    // Measured in parts-per-billion
-
-    ref_freq = ref_freq + (int32_t)((((((int64_t)correction) << 31) / 1000000000LL) * ref_freq) >> 31);
-
-    // PLL bounds checking
-    if (freq < SI5351_PLL_VCO_MIN * SI5351_FREQ_MULT) {
-        freq = SI5351_PLL_VCO_MIN * SI5351_FREQ_MULT;
-    }
-    if (freq > SI5351_PLL_VCO_MAX * SI5351_FREQ_MULT) {
-        freq = SI5351_PLL_VCO_MAX * SI5351_FREQ_MULT;
-    }
-
-    // Determine integer part of feedback equation
-    a = freq / ref_freq;
-
-    if (a < SI5351_PLL_A_MIN) {
-        freq = ref_freq * SI5351_PLL_A_MIN;
-    }
-    if (a > SI5351_PLL_A_MAX) {
-        freq = ref_freq * SI5351_PLL_A_MAX;
-    }
-
-    // Find best approximation for b/c = fVCO mod fIN
-    denom = 1000ULL * 1000ULL;
-    lltmp = freq % ref_freq;
-    lltmp *= denom;
-    do_div(lltmp, ref_freq);
-
-    b = (((uint64_t)(freq % ref_freq)) * RFRAC_DENOM) / ref_freq;
-    c = b ? RFRAC_DENOM : 1;
-
-	// Calculate parameters
-    p1 = 128 * a + ((128 * b) / c) - 512;
-    p2 = 128 * b - c * ((128 * b) / c);
-    p3 = c;
-
-    // Recalculate frequency as fIN * (a + b/c)
-    lltmp  = ref_freq;
-    lltmp *= b;
-    do_div(lltmp, c);
-    freq = lltmp;
-    freq += ref_freq * a;
-
-    reg->p1 = p1;
-    reg->p2 = p2;
-    reg->p3 = p3;
-
-    return freq;
-}
-
-uint8_t si5351_select_r_div(uint64_t *freq) {
-    uint8_t r_div = SI5351_OUTPUT_CLK_DIV_1;
-
-    // Choose the correct R divider
-    if((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT) 
-            && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 2)) {
-        r_div = SI5351_OUTPUT_CLK_DIV_128;
-        *freq *= 128ULL;
-    } else if ((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 2)
-            && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 4)) {
-        r_div = SI5351_OUTPUT_CLK_DIV_64;
-        *freq *= 64ULL;
-    } else if ((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 4)
-            && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 8)) {
-        r_div = SI5351_OUTPUT_CLK_DIV_32;
-        *freq *= 32ULL;
-    } else if ((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 8)
-            && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 16)) {
-        r_div = SI5351_OUTPUT_CLK_DIV_16;
-        *freq *= 16ULL;
-    } else if ((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 16)
-            && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 32)) {
-        r_div = SI5351_OUTPUT_CLK_DIV_8;
-        *freq *= 8ULL;
-    } else if ((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 32)
-            && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 64)) {
-        r_div = SI5351_OUTPUT_CLK_DIV_4;
-        *freq *= 4ULL;
-    } else if ((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 64)
-            && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 128)) {
-        r_div = SI5351_OUTPUT_CLK_DIV_2;
-        *freq *= 2ULL;
-    }
-
-    return r_div;
-}
-
diff --git a/stm32/src/stm32f4_adc_tuner.c b/stm32/src/stm32f4_adc_tuner.c
deleted file mode 100644
index ad1ced3a..00000000
--- a/stm32/src/stm32f4_adc_tuner.c
+++ /dev/null
@@ -1,289 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: stm32f4_adc_tuner.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 19 Feb 2015
-
-  Single channel ADC driver module for STM32F4 that samples pin PA1 at
-  2 MHz and down converts to 50 kHz, with "tuning" centred at 500 kHz.
-
-  See codec2-dev/octave.m for a simulation model.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2015 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "stm32f4xx_adc.h"
-#include "stm32f4xx_gpio.h"
-#include "stm32f4xx_rcc.h"
-
-#include "codec2_fifo.h"
-#include "stm32f4_adc_tuner.h"
-#include "debugblinky.h"
-#include "iir_tuner.h"
-
-struct FIFO *adc1_fifo;
-unsigned short adc_buf[ADC_TUNER_BUF_SZ], *padc_buf;
-int adc_overflow1;
-int half,full;
-static short tuner_en = 1;
-
-#define ADCx_DR_ADDRESS          ((uint32_t)0x4001204C)
-#define DMA_CHANNELx             DMA_Channel_0
-#define DMA_STREAMx              DMA2_Stream0
-#define ADCx                     ADC1
-
-void adc_configure();
-
-static void tim2_config(void);
-
-//#define DUMMY_SIGNAL
-#ifdef DUMMY_SIGNAL
-unsigned short sine[ADC_TUNER_BUF_SZ];
-#endif
-
-void adc_open(int fifo_sz) {
-    adc1_fifo = codec2_fifo_create(fifo_sz);
-    assert(adc1_fifo != NULL);
-
-    tim2_config();
-    adc_configure();
-    init_debug_blinky();
-}
-
-
-/* n signed 16 bit samples in buf[] if return != -1 */
-
-int adc1_read(short buf[], int n) {
-    return codec2_fifo_read(adc1_fifo, buf, n);
-}
-
-
-void adc_set_tuner_en(short flag)
-{
-    tuner_en = flag;
-}
-
-static void tim2_config(void)
-{
-  TIM_TimeBaseInitTypeDef    TIM_TimeBaseStructure;
-
-  /* TIM2 Periph clock enable */
-  RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
-
-  /* --------------------------------------------------------
-
-  TIM2 input clock (TIM2CLK) is set to 2 * APB1 clock (PCLK1), since
-  APB1 prescaler is different from 1 (see system_stm32f4xx.c and Fig
-  13 clock tree figure in DM0031020.pdf).
-
-     Sample rate Fs = 2*PCLK1/)TIM_ClockDivision+1)
-                    = (HCLK/2)/(TIM_ClockDivision+1)
-
-  Note from David: The +1 was discovered empirically, still not sure
-  if it's right.
-
-  ----------------------------------------------------------- */
-
-  /* Time base configuration */
-
-  TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
-  TIM_TimeBaseStructure.TIM_Period = 41;
-  TIM_TimeBaseStructure.TIM_Prescaler = 0;
-  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
-  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
-  TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
-
-  /* TIM2 TRGO selection */
-
-  TIM_SelectOutputTrigger(TIM2, TIM_TRGOSource_Update);
-
-  /* TIM2 enable counter */
-
-  TIM_Cmd(TIM2, ENABLE);
-}
-
-
-void adc_configure() {
-    ADC_InitTypeDef  ADC_init_structure;
-    GPIO_InitTypeDef GPIO_initStructre;
-    DMA_InitTypeDef  DMA_InitStructure;
-    NVIC_InitTypeDef NVIC_InitStructure;
-
-    // Clock configuration
-
-    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);
-    RCC_AHB1PeriphClockCmd(RCC_AHB1ENR_GPIOAEN,ENABLE);
-    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
-
-    // Analog pin configuration ADC1->PA1
-
-    GPIO_initStructre.GPIO_Pin =  GPIO_Pin_1;
-    GPIO_initStructre.GPIO_Mode = GPIO_Mode_AN;
-    GPIO_initStructre.GPIO_PuPd = GPIO_PuPd_NOPULL;
-    GPIO_Init(GPIOA,&GPIO_initStructre);
-
-    // ADC structure configuration
-
-    ADC_DeInit();
-    ADC_init_structure.ADC_DataAlign = ADC_DataAlign_Left;
-    ADC_init_structure.ADC_Resolution = ADC_Resolution_12b;
-    ADC_init_structure.ADC_ContinuousConvMode = DISABLE;
-    ADC_init_structure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T2_TRGO;
-    ADC_init_structure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_Rising;
-    ADC_init_structure.ADC_NbrOfConversion = 1;
-    ADC_Init(ADCx,&ADC_init_structure);
-
-    // Select the channel to be read from
-
-    ADC_RegularChannelConfig(ADCx,ADC_Channel_1,1,ADC_SampleTime_3Cycles);
-
-    /* DMA  configuration **************************************/
-
-    DMA_DeInit(DMA_STREAMx);
-    DMA_InitStructure.DMA_Channel = DMA_CHANNELx;
-    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADCx_DR_ADDRESS;
-    DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)adc_buf;
-    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
-    DMA_InitStructure.DMA_BufferSize = ADC_TUNER_BUF_SZ;
-    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
-    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
-    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
-    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
-    DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
-    DMA_InitStructure.DMA_Priority = DMA_Priority_High;
-    DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
-    DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
-    DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
-    DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
-    DMA_Init(DMA_STREAMx, &DMA_InitStructure);
-
-    /* Enable DMA request after last transfer (Single-ADC mode) */
-
-    ADC_DMARequestAfterLastTransferCmd(ADCx, ENABLE);
-
-    /* Enable ADC1 DMA */
-
-    ADC_DMACmd(ADCx, ENABLE);
-
-    /* DMA2_Stream0 enable */
-
-    DMA_Cmd(DMA_STREAMx, ENABLE);
-
-    /* Enable DMA Half & Complete interrupts */
-
-    DMA_ITConfig(DMA2_Stream0, DMA_IT_TC | DMA_IT_HT, ENABLE);
-
-    /* Enable the DMA Stream IRQ Channel */
-
-    NVIC_InitStructure.NVIC_IRQChannel = DMA2_Stream0_IRQn;
-    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
-    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
-    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
-    NVIC_Init(&NVIC_InitStructure);
-
-    // Enable and start ADC conversion
-
-    ADC_Cmd(ADC1,ENABLE);
-    ADC_SoftwareStartConv(ADC1);
-
-    padc_buf = adc_buf;
-
-    #ifdef DUMMY_SIGNAL
-    int i;
-
-    /* Fs/4 sine wave, right in the middle of the pass band ! */
-
-    for(i=0; i<ADC_TUNER_BUF_SZ; i++)
-        sine[i] = 32767;
-    for(i=1; i<ADC_TUNER_BUF_SZ; i+=4)
-        sine[i] += 32767/4;
-    for(i=3; i<ADC_TUNER_BUF_SZ; i+=4)
-        sine[i] -= 32767/4;
-    padc_buf = sine;
-    #endif
-
-}
-
-
-/*
-  This function handles DMA Stream interrupt request.
-
-  ADC_TUNER_BUF_SZ = 45 * 160 = 7200, so one interrupt every 7200/2 = 3600 samples
-  or interrupts at a rate of 2E6/3600 = 555.56 Hz.
-*/
-
-void DMA2_Stream0_IRQHandler(void) {
-    float dec_buf[ADC_TUNER_N/2];
-
-    /* PE0 is asserted high for the duration of this ISR */
-
-    GPIOE->ODR |= (1 << 0);
-
-    /* Half transfer interrupt */
-
-    if(DMA_GetITStatus(DMA2_Stream0, DMA_IT_HTIF0) != RESET) {
-        half++;
-
-        if (tuner_en) {
-            iir_tuner(dec_buf, padc_buf);
-
-            /* write first half to fifo.  Note we are writing ADC_TUNER_N/2 floats,
-               which is equivalent to ADC_TUNER_N shorts.  */
-
-           if (codec2_fifo_write(adc1_fifo, (short*)dec_buf, ADC_TUNER_N) == -1) {
-                adc_overflow1++;
-            }
-        }
-        else // note: we dump signed shorts when tuner off
-            codec2_fifo_write(adc1_fifo, (short*)padc_buf, ADC_TUNER_BUF_SZ/2); 
-
-        /* Clear DMA Stream Transfer Complete interrupt pending bit */
-
-        DMA_ClearITPendingBit(DMA2_Stream0, DMA_IT_HTIF0);
-    }
-
-    /* Transfer complete interrupt */
-
-    if(DMA_GetITStatus(DMA2_Stream0, DMA_IT_TCIF0) != RESET) {
-        full++;
-
-        if (tuner_en) {
-            iir_tuner(dec_buf, &padc_buf[ADC_TUNER_BUF_SZ/2]);
-
-            /* write second half to fifo */
-
-            if (codec2_fifo_write(adc1_fifo, (short*)dec_buf, ADC_TUNER_N) == -1) {
-              adc_overflow1++;
-            }
-        }
-        else
-            codec2_fifo_write(adc1_fifo, (short*)&padc_buf[ADC_TUNER_BUF_SZ/2], ADC_TUNER_BUF_SZ/2);
-
-        /* Clear DMA Stream Transfer Complete interrupt pending bit */
-
-        DMA_ClearITPendingBit(DMA2_Stream0, DMA_IT_TCIF0);
-    }
-
-    GPIOE->ODR &= ~(1 << 0);
-}
-
diff --git a/stm32/src/tuner_ut.c b/stm32/src/tuner_ut.c
deleted file mode 100644
index 9c752c0e..00000000
--- a/stm32/src/tuner_ut.c
+++ /dev/null
@@ -1,122 +0,0 @@
-/*---------------------------------------------------------------------------*\
-
-  FILE........: tuner_ut.c
-  AUTHOR......: David Rowe
-  DATE CREATED: 20 Feb 2015
-
-  Unit test for high speed ADC radio tuner, samples signal centred at
-  500kHz using Fs=2 MHz and uploads to host at Fs=10 kHz.
-
-\*---------------------------------------------------------------------------*/
-
-/*
-  Copyright (C) 2015 David Rowe
-
-  All rights reserved.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License version 2.1, as
-  published by the Free Software Foundation.  This program is
-  distributed in the hope that it will be useful, but WITHOUT ANY
-  WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-  License for more details.
-
-  You should have received a copy of the GNU Lesser General Public License
-  along with this program; if not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <assert.h>
-#include <stdlib.h>
-#include "gdb_stdio.h"
-#include "stm32f4_dac.h"
-#include "stm32f4_adc_tuner.h"
-#include "iir_tuner.h"
-#include "sm1000_leds_switches.h"
-#include "../src/codec2_fm.h"
-#include "stm32f4xx.h"
-
-#define REC_TIME_SECS 10
-#define FS            50000
-#define N             5000
-
-extern int adc_overflow1;
-
-int main(void) {
-    float  tuner_out[IIR_TUNER_DEC_50_10_FILT_MEM+N/2];
-    float  fm_out[N/2];
-    //float  dec_10[(N/2)/5];
-    short  dec_10_short[(N/2)];
-    int    bufs, i, j, k, fifo_sz, bn;
-    FILE  *ftuner;
-    struct FM *fm;
-
-    ftuner = fopen("tuner.raw", "wb");
-    if (ftuner == NULL) {
-        printf("Error opening input file: tuner.raw\n\nTerminating....\n");
-        exit(1);
-    }
-    bufs = FS*REC_TIME_SECS/N;
-    fifo_sz = ((4*N/ADC_TUNER_N)+1)*ADC_TUNER_N;
-    printf("Starting! bufs: %d %d\n", bufs, fifo_sz);
-
-    //dac_open(DAC_BUF_SZ);
-    adc_open(fifo_sz);
-    sm1000_leds_switches_init();
-
-    fm         = fm_create(N/2);
-    fm->Fs     = 44400.0;
-    fm->fm_max = 3000.0;
-    fm->fd     = 5000.0;
-    fm->fc     = fm->Fs/4;
-
-    i = 0; bn = 0;
-    while(1) {
-        /* wait for buffer of Fs=50kHz tuner output samples */
-
-        while(adc1_read((short *)&tuner_out[IIR_TUNER_DEC_50_10_FILT_MEM], N) == -1);
-
-        /* The semi-hosting system can only handle Fs=16kHz and below so resample down
-           to Fs=10 kHz and convert to shorts */
-
-        #ifdef SSB
-        iir_tuner_dec_50_to_10(dec_10, &tuner_out[IIR_TUNER_DEC_50_10_FILT_MEM], N/2);
-        for(j=0; j<IIR_TUNER_DEC_50_10_FILT_MEM; j++)
-            tuner_out[j] = tuner_out[j+N/2];
-        for(j=0; j<(N/2)/5; j++)
-            dec_10_short[j] = dec_10[j]/ADC_TUNER_M;
-        #else
-        GPIOE->ODR |= (1 << 3);
-        /*
-        for(j=0; j<N/2; j++)
-            tuner_out[IIR_TUNER_DEC_50_10_FILT_MEM+j] = 0;
-        for(j=1; j<N/2; j+=4)
-            tuner_out[IIR_TUNER_DEC_50_10_FILT_MEM+j] = 100;
-        for(j=3; j<N/2; j+=4)
-            tuner_out[IIR_TUNER_DEC_50_10_FILT_MEM+j] = -100;
-        */
-        fm_demod(fm, fm_out, &tuner_out[IIR_TUNER_DEC_50_10_FILT_MEM]);
-        GPIOE->ODR &= ~(1 << 3);
-
-        for(j=0,k=0; j<N/2; j+=5,k++)
-            dec_10_short[k+bn] = 16384*fm_out[j];
-        bn += (N/2)/5;
-        #endif
-
-        if ((bn == N/2) && (i < bufs)) {
-            //for(j=0; j<N/2; j++)
-            //    dec_10_short[j] = tuner_out[IIR_TUNER_DEC_50_10_FILT_MEM+j];
-            fwrite(dec_10_short, sizeof(short), (N/2), ftuner);
-            bn = 0;
-            i += 5;
-            //fwrite(dec_10_short, sizeof(short), (N/2)/5, ftuner);
-            //printf("%d %d\n", i, adc_overflow1);
-        }
-        if (i == bufs) {
-            printf("finished! %d\n", adc_overflow1);
-            fclose(ftuner);
-            i++;
-        }
-    }
-}
-
-- 
2.30.2

